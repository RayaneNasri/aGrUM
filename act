#!/usr/bin/python
# -*- coding: utf-8 -*-

#***************************************************************************
#*   Copyright (C) 2010 by Pierre-Henri WUILLEMIN                          *
#*   {prenom.nom}_at_lip6.fr                                               *
#*                                                                         *
#*   This program is free software; you can redistribute it and/or modify  *
#*   it under the terms of the GNU General Public License as published by  *
#*   the Free Software Foundation; either version 2 of the License, or     *
#*   (at your option) any later version.                                   *
#*                                                                         *
#*   This program is distributed in the hope that it will be useful,       *
#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#*   GNU General Public License for more details.                          *
#*                                                                         *
#*   You should have received a copy of the GNU General Public License     *
#*   along with this program; if not, write to the                         *
#*   Free Software Foundation, Inc.,                                       *
#*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
#***************************************************************************


import sys
import os
import shelve
from optparse import OptionParser
from datetime import datetime
import glob
from distutils import sysconfig

OKGREEN = '\033[92m'
WARNING = '\033[93m'
RED = '\033[91m'
ENDC = '\033[0m'

##########################################################################################################################
def initParser(current):
    global list_options,list_rules,list_wrappers

    us="%prog [options] ["+"|".join(list_rules)+"] ["+"|".join(list_options)+"] ["+"|".join(list_wrappers)+"]"
    parser=OptionParser(usage=us,description="default invocation : %prog"+invocation,version="%prog v"+numversion)
    parser.add_option("-v", "--verbose",
                                        help="more message on what is happening",
                                        action="store_true",
                                        dest="verbose",
                                        default=current['verbose'])
    parser.add_option("-q", "--quiet",
                                        help="please be quiet",
                                        action="store_false",
                                        dest="verbose",
                                        default=current['verbose'])
    parser.add_option("", "--profile",
                                        help="Random seed is fixed once. Hence random algorithms are time-normalized.",
                                        action="store_true",
                                        dest="profile",
                                        default=False)
    parser.add_option("", "--stats",
                                        help="Consolidation on 20 runs.",
                                        action="store_true",
                                        dest="stats",
                                        default=False)
    parser.add_option("-p", "--platform",
                                        help="{linux|windows|mac}",
                                        type="choice",
                                        choices=["linux", "windows",  "mac"],
                                        action="store",
                                        dest="platform",
                                        default=current['platform'])
    parser.add_option("-d", "--dest",
                                        help="destination folder when installing",
                                        metavar="FOLDER",
                                        dest="destination",
                                        default=current['destination'])
    parser.add_option("-j", "--jobs",
                                        help="number of jobs",
                                        type='int',
                                        dest="jobs",
                                        default=current['jobs'])
    parser.add_option("-t","--testlist",
                                        help="testlist management : {show|all|test1+test2+test3}",
                                        metavar="TESTS-COMMAND",
                                        dest="testlists",
                                        default="")
    return parser

##########################################################################################################################
def testManagement(cde):
    global current
    if cde=="all":
        writeTestList(allTests())
        #current['rule']='test'
    elif cde=='list':
        afficheTests()
        sys.exit(0)
    else:
        writeTestList([x+'TestSuite.h' for x in cde.split('+')])
        current['rule']='test'

##########################################################################################################################
def checkList(l):
    for s in l:
        if not os.path.exists('src/testunits/'+s):
            print RED+'Test '+WARNING+s[:-11]+RED+' (src/testunits/'+s+') does not exists'+ENDC
            print
            afficheTests()
            sys.exit(0)

##########################################################################################################################
def writeTestList(l):
    checkList(l)
    today = datetime.now()
    f = open('src/testunits/testList.cmake', 'w')
    f.write("# file automatically generated by act\n")
    f.write("# "+today.strftime("%A, %d. %B %Y %H:%M")+"\n")
    f.write("# do not change it\n")
    f.write("set(AGRUM_TESTS \n  ")
    f.write("\n  ".join(l))
    f.write("\n)\n")
    f.close()
    f = open('src/testunits/testList.all', 'w')
    f.write("# file automatically generated by act\n")
    f.write("# "+today.strftime("%A, %d. %B %Y %H:%M")+"\n")
    f.write("# do not change it\n")
    f.write("set(AGRUM_TESTS \n  ")
    f.write("\n  ".join(l))
    f.write("\n)\n")
    f.close()

##########################################################################################################################
def allTests():
    return sorted([os.path.basename(x) for x in glob.glob('src/testunits/*TestSuite.h')])

##########################################################################################################################
def checkTestListCmake():
    if not os.path.exists('src/testunits/testList.cmake'):
      writeTestList(allTests())
    else:
      with open('src/testunits/testList.cmake') as f:
        content = f.readlines()

      res=[]
      rewrite=False
      for line in content:
        if line[0:2]=="  ":
          s=line.strip()
          if not os.path.exists('src/testunits/'+s):
            print RED+'Test '+WARNING+s[:-11]+RED+' (src/testunits/'+s+') does not exist => removing it from tests list'+ENDC
            rewrite=True
          else:
            res.append(s)
      if rewrite:
        writeTestList(res)


##########################################################################################################################
def afficheTests():
    l=allTests()
    l=[s[:-11] for s in l]
    w=max([len(x) for x in l])
    nbr=80/w
    i=0
    for s in l:
        print " "+s.ljust(w),
        i+=1
        if i>nbr:
            i=0
            print
    if i!=0:
        print
    print



##########################################################################################################################
def execute(s,exec_cde=False):
    global sh,sh_no_exec
    if(sh!=""):
        s=" && "+s
    sh+=s
    if not exec_cde:
      sh_no_exec+=s

##########################################################################################################################
def cleanAll():
    print "..."+WARNING+" cleaning"+ENDC+" ...",
    os.system("rm -rf build")
    print OKGREEN+"done"+ENDC
    print

##########################################################################################################################
def showAll():
    global persistent
    print "Actual options/args"
    print "-------------------"
    for key in persistent:
        if key in ['cleanAll']: # keys we do not need to show
            continue
        print "  "+key+" : "+persistent[key].__str__()
    print "-------------------"
    print


##########################################################################################################################
def safe_cd(folder):
    cde="[ ! -d "+folder+" ] && mkdir "+folder+" ; cd "+folder
    execute(cde)

##########################################################################################################################
def checkConstraints(parser,options,args):
    global current,persistent
    global list_rules,list_options,list_wrappers

    current['verbose']=options.verbose
    current['platform']=options.platform
    current['destination']=options.destination
    current['jobs']=options.jobs
    current['profile']=options.profile
    current['stats']=options.stats

    for key in 'rule option wrapper'.split():
        current[key]=''

    if len(args) >0: # no args for cdline, just options
        for arg in args:
            if arg in list_rules:
                current['rule']=arg
                continue
            if arg in list_options:
                current['option']=arg
                continue
            if arg in list_wrappers:
                current['wrapper']=arg
                continue
            parser.error(arg+" is an invalid argument")
    else:
        for key in 'rule option wrapper'.split():
            current[key]=persistent[key]

    if current['option']=='':
        current['option']='release'
    if current['rule']=='' and current['wrapper']!='':
        current['rule']='wrapper'
    if current['option']=='debug':
        if current['rule']=='agrum':
            current['rule']='agrum-dbg'

    if current['wrapper']!="":
        if (not current['rule'] in ["wrapper", "install","test","uninstall"]):
            parser.print_help()
            parser.error("incompatibilty between options <rule>='"+current['rule'] +"' and <wrapper>='"+current['wrapper']+"'")
        if current['option']!='release':
            parser.print_help()
            parser.error('no debug mode for wrappers compilation')

    if current['platform']=='windows':
        if not current['rule'] in ["agrum","test","run","clean",'package']:
            parser.print_help()
            parser.error("incompatibilty between options <platform>='"+current['platform']+"' and <rule>='"+current['rule']+"'")
        if not current['option']=='release':
            parser.print_help()
            parser.error("incompatibilty between options <platform>='"+current['platform']+"' and <option>='"+current['option']+"'")


##########################################################################################################################
def proceed(options,RANDOMSEED_FOR_PROFILE="10"):
    folders=cmake_options=make_options=run_cde =""

    if options['wrapper']!="": # we know rule in ["install","wrapper", "test"]
        # ensure creation of agrum/config.h (as a release version of agrum)
        folders=["build",options['platform'],'release']
        cmake_options=" -DCMAKE_BUILD_TYPE=RELEASE  ../../../src -DCMAKE_VERBOSE_MAKEFILE="
        if (options['verbose']):
            cmake_options=cmake_options+"ON"
        else:
            cmake_options=cmake_options+"OFF"
        [safe_cd(s) for s in folders]
        execute("cmake "+cmake_options)
        [execute("cd ..") for s in folders]

        folders=['build','wrappers',options['wrapper']]
        cmake_options="-DCMAKE_BUILD_TYPE=RELEASE ../../../wrappers/"+options['wrapper']+"/"
        if options['rule'] in ["install"]:
            make_options=options['rule']
        else:
            make_options=""
        if options['rule']=='test':
            if options['wrapper']=='pyAgrum':
                run_cde="PYTHONPATH=. python ../../../wrappers/pyAgrum/testunits/TestSuite.py"
            else:
                print RED+"No tests for "+options['wrapper']+ENDC
                sys.exit(0)
        else:
            run_cde=""
    else:
        if options['rule']=='package':
            folders=["build",'package_'+options['platform'],options['option']]
        elif options['rule']=='config':
            folders=["build",options['platform'],'config']
        else:
            folders=["build",options['platform'],options['option']]
        cmake_options=" -DCMAKE_BUILD_TYPE="+options['option'].upper()+" ../../../src"
        if (options['platform']=="windows"):
            cmake_options=cmake_options+" -DCMAKE_TOOLCHAIN_FILE=../../../src/cmake/Toolchain-mingw32.cmake -DCMAKE_INSTALL_PREFIX=_CPack_Packages/win32/TGZ/agrum-0.6.0-win32"

        if (options['rule']=="test" or options['rule']=="run"):
            make_options=options['rule']
            run_cde="./"+options['rule']
        else:
            make_options=options['rule']

    if (options['platform'] != "windows"):
        cmake_options=cmake_options+" -DCMAKE_INSTALL_PREFIX="+options['destination']

    cmake_options=cmake_options+" -DCMAKE_VERBOSE_MAKEFILE="
    if (options['verbose']):
        cmake_options=cmake_options+"ON"
    else:
        cmake_options=cmake_options+"OFF"

    make_options=make_options+" -j "+options['jobs'].__str__()

    option_profile=" -DGUM_RANDOMSEED="+(RANDOMSEED_FOR_PROFILE if options['profile'] else "0")
    cmake_options=cmake_options+option_profile;

    [safe_cd(s) for s in folders]
    execute("cmake "+cmake_options)
    if options['rule']!='config':
        execute("make "+make_options)
    if (run_cde!=""):
        if (options['platform'] == "windows"):
            run_cde="wine "+run_cde
        execute(run_cde,exec_cde=True)
    [execute("cd ..") for s in folders]

##########################################################################################################################
def uninstall(options):
    install_folder=options['destination']
    if options['wrapper']!='':
        install_folder=sysconfig.get_python_lib(1,0,prefix=install_folder)

        print "suppresion récursive de "+RED+install_folder+"/pyAgrum"+ENDC
        os.system('cd '+install_folder+' && rm -rf pyAgrum')
        print "suppresion récursive de "+RED+install_folder+"/gumLib"+ENDC
        os.system('cd '+install_folder+' && rm -rf gumLib')
        print "suppresion de "+RED+install_folder+"/pyAgrum*.egg-info"+ENDC
        os.system('rm -f '+install_folder+"/pyAgrum*.egg-info")
    else:
        print "suppresion de "+RED+install_folder+"/lib/libagrum*"+ENDC
        os.system('rm -f '+install_folder+"/lib/libagrum*")
        print "suppresion récursive de "+RED+install_folder+"/lib/aGrUM"+ENDC
        os.system('cd '+install_folder+'/lib && rm -rf aGrUM')
        print "suppresion récursive de "+RED+install_folder+"/include/agrum"+ENDC
        os.system('cd '+install_folder+'/include && rm -rf agrum')

##########################################################################################################################
default={}
current={}
persistent={}

list_rules="config test run agrum wrapper install doc clean default show uninstall package".split()
list_options="debug release".split()
list_wrappers="pyAgrum jAgrum".split()

default['platform']="linux"
default['option']="release"
default['rule']="agrum"
default['destination']="/usr"
default['wrapper']=""
default['jobs']="5"
default['verbose']=False
default['profile']=False
default['stats']=False

not_persistent_options=['profile','stats']


shlv=shelve.open(".options.mak.py",writeback=True)
if shlv.has_key('persistent'):
    persistent=shlv['persistent']

#shlv=shelve.open(".options.mak.py",writeback=True)
#if shlv.has_key('persistent'):
#    persistent=shlv['persistent']

for key in default.iterkeys():
  if not key in not_persistent_options:
    if persistent.has_key(key):
        current[key]=persistent[key]
    else:
        current[key]=default[key]

invocation=" agrum release -d /usr -j 5 -q -p linux"
numversion="1.5"

print ENDC+RED+"aGrUM"+ENDC+" compilation tool "+RED+"v"+numversion+ENDC
print "(c) 2010-13 "+OKGREEN+"aGrUM Team"+ENDC
print


checkTestListCmake()

parser=initParser(current)
(options, args)=parser.parse_args()

checkConstraints(parser,options,args)

if options.testlists!="":
    testManagement(options.testlists)
    
if len(args)==0:
    print WARNING+"invocation"+ENDC+" : "+OKGREEN+"act "+current['rule']+" "+current['option']+' '+current['wrapper']+ENDC
    print

#needed for cmake
if not os.path.exists('src/testunits/testList.cmake'):
    writeTestList(allTests())
    
## SPECIAL RULES
if current['rule']=='show':
    showAll()
    sys.exit(0)
if current['rule']=='clean':
    cleanAll()
    sys.exit(0)
if current['rule']=='uninstall':
    uninstall(current)
    sys.exit(0)
    
if current['rule']=='default':
    current=default
    print "invocation : act "+current['rule']+" "+current['option']+' '+current['wrapper']

for key in current:
  if not key in not_persistent_options:
    persistent[key]=current[key]
shlv['persistent']=persistent
shlv.close()

global sh,sh_no_exec
sh="";
sh_no_exec=""

proceed(current,RANDOMSEED_FOR_PROFILE="10")

if (options.verbose):
  print("")
  print(sh)
  print("")
  print(sh_no_exec)
  print("")

if not(current['stats']):
  os.system(sh)
else:
  os.system(sh_no_exec)
  print("###########################################")
  print("Processing profile for act "+current['rule']+" "+current['option']+' '+current['wrapper'])
  print("This will take a certain amount of time ...")
  print("###########################################")
  import subprocess,re,math
  time_line=re.compile(r'## Profiling :\s+(.*?)\sms ##')
  stat_line=re.compile(r"Failed (.*?) of (.*?) test")
  
  nbr_tests=20
  vals=list()
  for i in range(nbr_tests):
    p=subprocess.Popen(sh,shell=True,stderr=subprocess.PIPE,stdout=subprocess.PIPE)
    out=p.stderr.readlines()
    tps=0
    failed=0
    total=0
    for line in out:
      time_match = time_line.search(line) 
      if time_match:
        tps=int(time_match.groups()[0])
        continue
      
      stat_match = stat_line.search(line)
      if stat_match:
        failed=int(stat_match.groups()[0])
        total=int(stat_match.groups()[1])
       
    print("Stats {3}/{4} : succes rate {0}/{1} in {2} ms".format(total-failed,total,tps,i+1,nbr_tests))
    vals.append(tps)
    
  s=0.0
  s2=0.0
  for v in vals:
    s+=v
    s2+=v*v
  mean=s/nbr_tests
  var=s2/nbr_tests-mean*mean
  print("=======================")
  print("Mean :{0}".format(mean))
  print("StdDev :{0}".format(math.sqrt(var)))
