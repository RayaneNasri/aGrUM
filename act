#!/usr/bin/python
# -*- coding: utf-8 -*-

#***************************************************************************
#*   Copyright (C) 2010 by Pierre-Henri WUILLEMIN                          *
#*   {prenom.nom}_at_lip6.fr                                               *
#*                                                                         *
#*   This program is free software; you can redistribute it and/or modify  *
#*   it under the terms of the GNU General Public License as published by  *
#*   the Free Software Foundation; either version 2 of the License, or     *
#*   (at your option) any later version.                                   *
#*                                                                         *
#*   This program is distributed in the hope that it will be useful,       *
#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#*   GNU General Public License for more details.                          *
#*                                                                         *
#*   You should have received a copy of the GNU General Public License     *
#*   along with this program; if not, write to the                         *
#*   Free Software Foundation, Inc.,                                       *
#*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
#***************************************************************************


import sys,os,re,glob,math

import shelve
from optparse import OptionParser
from datetime import datetime
from distutils import sysconfig

numversion="1.6"
modulestxt="src/modules.txt" # the file to parse to find the modules

nbr_tests_for_stats=40

OKGREEN = '\033[92m'
WARNING = '\033[93m'
RED = '\033[91m'
ENDC = '\033[0m'

##########################################################################################################################
# for timeout in popen (cross-platform)
from subprocess import PIPE, Popen
from threading  import Thread

try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty  # python 3.x

ON_POSIX = 'posix' in sys.builtin_module_names

def enqueue_output(out, queue):
    for line in iter(out.readline, b''):
        queue.put(line)
    out.close()
    
##########################################################################################################################
def parseModulesTxt(filename):
  modules={}
  module_line=re.compile(r"^\s*list\s*\(\s*APPEND\s*MODULES\s*\"(.*)\"\s*\)(\s*#\s*(.*))?")
  with open(filename,"r") as f:
    for line in f:
      rep=module_line.search(line)
      if rep:
        module=rep.groups(0)[0]
        descr=rep.groups(0)[2]
        if descr==0:
          descr=module
        modules[module]=descr
  return modules

##########################################################################################################################
def initParser(current):
    global list_options,list_rules,list_wrappers

    us="%prog [options] ["+"|".join(list_rules)+"] ["+"|".join(list_options)+"] ["+"|".join(list_wrappers)+"]"
    parser=OptionParser(usage=us,description="Compilation tools for aGrUM/pyAgrum",
                        version="%prog v"+numversion)
    parser.add_option("-v", "--verbose",
                                        help="more message on what is happening",
                                        action="store_true",
                                        dest="verbose",
                                        default=current['verbose'])
    parser.add_option("-q", "--quiet",
                                        help="please be quiet",
                                        action="store_false",
                                        dest="verbose",
                                        default=current['verbose'])
    parser.add_option("", "--fixed_seed",
                                        help="Random seed is fixed once for all. Hence random algorithms should be time-normalized.",
                                        action="store_true",
                                        dest="fixed_seed",
                                        default=False)
    parser.add_option("", "--stats",
                                        help="Consolidation on "+str(nbr_tests_for_stats)+" runs.",
                                        action="store_true",
                                        dest="stats",
                                        default=False)
    parser.add_option("-p", "--platform",
                                        help="{linux|windows|mac}",
                                        type="choice",
                                        choices=["linux", "windows",  "mac"],
                                        action="store",
                                        dest="platform",
                                        default=current['platform'])
    parser.add_option("-d", "--dest",
                                        help="destination folder when installing",
                                        metavar="FOLDER",
                                        dest="destination",
                                        default=current['destination'])
    parser.add_option("-j", "--jobs",
                                        help="number of jobs",
                                        type='int',
                                        dest="jobs",
                                        default=current['jobs'])
    parser.add_option("-t","--testlist",
                                        help="testlist management : {show|all|test1+test2+test3}",
                                        metavar="TESTS-COMMAND",
                                        dest="testlist",
                                        default=current['testlist'])
    parser.add_option("","--with-test-base",
                                        help="Tests will include tests for BASE module",
                                        action="store_true",
                                        dest="test_base",
                                        default=current['test_base'])
    parser.add_option("","--without-test-base",
                                        help="Tests will not include tests for BASE module",
                                        action="store_false",
                                        dest="test_base",
                                        default=current['test_base'])
    parser.add_option("-m","--module",
                                        help="module management : {show|all|module1+module2+module3}",
                                        metavar="MODULES-COMMAND",
                                        dest="module",
                                        default=current['module'])
    return parser

##########################################################################################################################
def moduleManagement(cde):
  global current,listOfModules
  
  listM=[x.upper() for x in cde.split('+')]
  setM=set(listM)
  
  if 'ALL' in setM:
    cde='ALL'
  else:
    if not setM.issubset(set(listOfModules)):
      cde='LIST'
      
  if cde=="ALL":
      current['module']='+'.join(sorted(listOfModules))
  elif cde=='LIST':
    print("Module is in")
    print("    - ALL")
    for x in sorted(listOfModules):
      print("    - "+x+" ("+listOfModules[x]+")")
    sys.exit(0)
  else:
    current['module']='+'.join(listM)
    
def testManagement(cde):
  global current
  if cde=="all":
    writeTestList(allTests())
  elif cde=='list':
    afficheTests()
    sys.exit(0)
  else:
    l=checkTestList(cde)
    writeTestList(l)

##########################################################################################################################
def checkTestList(cde):
  res=[]
  alltests=allTests()
  for ss in cde.split('+'):
    s='/'+ss+'TestSuite.h'
    name=""
    for tryfile in alltests:
      if tryfile.endswith(s):
        name=tryfile
        break
    if name=="":
      print RED+'Test "src/testunits/[module]/'+OKGREEN+ss+RED+'TestSuite.h" does not exists for the selected modules'+ENDC
      print
      afficheTests()
      sys.exit(0)
    else:
      res.append(name)
  return res

##########################################################################################################################
def writeTestList(l):
  today = datetime.now()
  f = open('src/testunits/testList.cmake', 'w')
  f.write("# file automatically generated by act\n")
  f.write("# "+today.strftime("%A, %d. %B %Y %H:%M")+"\n")
  f.write("# do not change it\n")
  f.write("set(AGRUM_TESTS \n  ")
  f.write("\n  ".join(l))
  f.write("\n)\n")
  f.close()
  f = open('src/testunits/testList.all', 'w')
  f.write("# file automatically generated by act\n")
  f.write("# "+today.strftime("%A, %d. %B %Y %H:%M")+"\n")
  f.write("# do not change it\n")
  f.write("set(AGRUM_TESTS \n  ")
  f.write("\n  ".join(l))
  f.write("\n)\n")
  f.close()

##########################################################################################################################
def CrossPlatformRelPath(x,y):
  return os.path.relpath(x,"src/testunits").replace("\\","/") 

def allTests():
    global current
    
    s=[]
    
    if current['test_base']:
      s+=[CrossPlatformRelPath(x,"src/testunits")
          for x in glob.glob('src/testunits/module_BASE/*TestSuite.h')]
      
    for x in current['module'].split('+'):
      s+=[CrossPlatformRelPath(x,"src/testunits")
          for x in glob.glob('src/testunits/module_'+x.upper()+'/*TestSuite.h')]
    
    return sorted(s)

##########################################################################################################################
def checkTestListCmake():
    if not os.path.exists('src/testunits/testList.cmake'):
      writeTestList(allTests())
    else:
      with open('src/testunits/testList.cmake') as f:
        content = f.readlines()

      res=[]
      rewrite=False
      for line in content:
        if line[0:2]=="  ":
          s=line.strip()
          if not os.path.exists('src/testunits/'+s):
            print RED+'Test '+WARNING+s[:-11]+RED+' (src/testunits/'+s+') does not exist => removing it from tests list'+ENDC
            rewrite=True
          else:
            res.append(s)
      if rewrite:
        writeTestList(res)


##########################################################################################################################
def afficheTestsForModule(m):
  print("="*(2+len(m)))
  print(" "+m+" ")
  print("="*(2+len(m)))
  
  l=allTests()
  prefix="module_"+m.upper()+"/"
  l=[s[len(prefix):-11] for s in l if s.startswith(prefix)]
  w=max([len(x) for x in l])
  nbr=80/w
  i=0
  for s in l:
      print " "+s.ljust(w),
      i+=1
      if i>nbr:
          i=0
          print
  if i!=0:
      print
  print


def afficheTests():
  global current
  if current['test_base']:
    afficheTestsForModule('BASE')
  for modul in current['module'].split('+'):
    afficheTestsForModule(modul)

##########################################################################################################################
def schedule(act,arg,exec_cde=False):
    global sh,sh_no_exec
    
    sh.append({'action':act,'argument':arg})
    if not exec_cde:
      sh_no_exec.append({'action':act,'argument':arg})
      
    # safe_cd =>  # cde="[ ! -d "+folder+" ] && mkdir "+folder+" ; cd "+folder
    # cd .. ou autre
    # autre
def execute(actions,verbose=True):
  nberr=0
  for k in actions:
    if verbose:
      print WARNING+k['action']+' '+OKGREEN+k['argument']+ENDC
      
    action=k['action']
    if action=="safe_cd":
      folder=k['argument']
      if not os.path.exists(folder):
        os.mkdir(folder)
      os.chdir(folder)
    elif action=="cd":
      folder=k['argument'] # most probably folder=".."
      os.chdir(folder) 
    else:
      commande=action+" "+k['argument']
      proc=Popen(commande,shell=True,stdout=PIPE, bufsize=1, close_fds=ON_POSIX)
      q = Queue()
      t = Thread(target=enqueue_output, args=(proc.stdout, q))
      t.daemon = True # thread dies with the program
      t.start() 
      while True:
        try:
          line = q.get_nowait()
          sys.stdout.write(line)
          sys.stdout.flush()
        except Empty:
          if proc.poll() is not None:
            print(WARNING+"[.]"+ENDC)
            break
      
      #exitcode = proc.returncode
      
      #for line in proc.stderr.readlines():
      #  sys.stdout.write(RED+line+ENDC)
      
##########################################################################################################################

def cleanAll():
    import shutil
    print WARNING+" cleaning"+ENDC+" ...",
    #os.system("rm -rf build") # 
    shutil.rmtree("build")
    print OKGREEN+"done"+ENDC
    print

##########################################################################################################################
def showAll():
    global persistent
    print "Actual options/args"
    print "-------------------"
    for key in persistent:
        if key in ['cleanAll']: # keys we do not need to show
            continue
        print "  "+key+" : "+persistent[key].__str__()
    print "-------------------"
    print


##########################################################################################################################
def safe_cd(folder):
    schedule("safe_cd",folder)

##########################################################################################################################
def checkConstraints(parser,options,args):
    global current,persistent
    global list_rules,list_options,list_wrappers

    current['verbose']=options.verbose
    current['platform']=options.platform
    current['destination']=options.destination
    current['jobs']=options.jobs
    current['fixed_seed']=options.fixed_seed
    current['stats']=options.stats
    current['test_base']=options.test_base
    current['testlist']=options.testlist

    for key in 'rule option wrapper'.split():
        current[key]=''

    if len(args) >0: # no args for cdline, just options
        for arg in args:
            if arg in list_rules:
                current['rule']=arg
                continue
            if arg in list_options:
                current['option']=arg
                continue
            if arg in list_wrappers:
                current['wrapper']=arg
                continue
            parser.error(arg+" is an invalid argument")
    else:
        for key in 'rule option wrapper'.split():
          if key in persistent:
            current[key]=persistent[key]
          else:
            current[key]=""

    if current['option']=='':
        current['option']='release'
    if current['rule']=='' and current['wrapper']!='':
        current['rule']='wrapper'
    #if current['option']=='debug':
    #    if current['rule']=='agrum':
    #        current['rule']='agrum-dbg'

    if current['wrapper']!="":
        if (not current['rule'] in ["wrapper", "install","test","uninstall"]):
            parser.print_help()
            parser.error("incompatibilty between options <rule>='"+current['rule'] +"' and <wrapper>='"+current['wrapper']+"'")
        if current['option']!='release':
            parser.print_help()
            parser.error('no debug mode for wrappers compilation')

    if current['platform']=='windows':
        if not current['rule'] in ["agrum","test","run","clean",'package']:
            parser.print_help()
            parser.error("incompatibilty between options <platform>='"+current['platform']+"' and <rule>='"+current['rule']+"'")
        if not current['option']=='release':
            parser.print_help()
            parser.error("incompatibilty between options <platform>='"+current['platform']+"' and <option>='"+current['option']+"'")


##########################################################################################################################
def proceed(options,RANDOMSEED_FOR_FIXED_SEED="10"):
    global listOfModules
    
    folders=cmake_options=make_options=run_cde =""
      
    if options['wrapper']!="": # we know rule in ["install","wrapper", "test"]
        # ensure creation of agrum/config.h (as a release version of agrum)
        folders=["build",options['platform'],'release']
        cmake_options=" -DCMAKE_BUILD_TYPE=RELEASE  ../../../src -DCMAKE_VERBOSE_MAKEFILE="
        if (options['verbose']):
            cmake_options=cmake_options+"ON"
        else:
            cmake_options=cmake_options+"OFF"
        [safe_cd(s) for s in folders]
        schedule("cmake ",cmake_options)
        [schedule("cd","..") for s in folders]

        folders=['build','wrappers',options['wrapper']]
        cmake_options="-DCMAKE_BUILD_TYPE=RELEASE ../../../wrappers/"+options['wrapper']+"/"
        if options['rule'] in ["install"]:
            make_options=options['rule']
        else:
            make_options=""
        if options['rule']=='test':
            if options['wrapper']=='pyAgrum':
                run_cde="PYTHONPATH=. python ../../../wrappers/pyAgrum/testunits/TestSuite.py"
            else:
                print RED+"No tests for "+options['wrapper']+ENDC
                sys.exit(0)
        else:
            run_cde=""
    else:
        if options['rule']=='package':
            folders=["build",'package_'+options['platform'],options['option']]
        elif options['rule']=='config':
            folders=["build",options['platform'],'config']
        else:
            folders=["build",options['platform'],options['option']]
        cmake_options=" -DCMAKE_BUILD_TYPE="+options['option'].upper()+" ../../../src"
        if (options['platform']=="windows"):
            #cmake_options=cmake_options+" -DCMAKE_TOOLCHAIN_FILE=../../../src/cmake/Toolchain-mingw32.cmake -DCMAKE_INSTALL_PREFIX=_CPack_Packages/win32/TGZ/agrum-0.6.0-win32"
            cmake_options=cmake_options+' -G "MinGW Makefiles" -DCMAKE_INSTALL_PREFIX=_CPack_Packages/TGZ/agrum-0.6.0-win'
        if (options['rule']=="test" or options['rule']=="run"):
            make_options=options['rule']
            run_cde="./"+options['rule']
        else:
          if (options['rule']=="agrum" and options['option'].upper()=="DEBUG"):
            make_options="agrum-dbg"
          else:
            make_options=options['rule']

    if (options['platform'] != "windows"):
        cmake_options=cmake_options+" -DCMAKE_INSTALL_PREFIX="+options['destination']

    cmake_options=cmake_options+" -DCMAKE_VERBOSE_MAKEFILE="
    if (options['verbose']):
        cmake_options=cmake_options+"ON"
    else:
        cmake_options=cmake_options+"OFF"

    make_options=make_options+" -j "+options['jobs'].__str__()

    option_fixed_seed=" -DGUM_RANDOMSEED="+(RANDOMSEED_FOR_FIXED_SEED if options['fixed_seed'] else "0")
    cmake_options=cmake_options+option_fixed_seed ;

    # MANAGING MODULES
    listM=[x.upper() for x in options['module'].split('+')]
    setM=set(listM)
    
    create_build = lambda module: " -DBUILD_"+module+"="+ ("ON" if module in setM else "OFF")
    cmake_options = cmake_options+create_build("ALL")
    for module in listOfModules:
      cmake_options = cmake_options+create_build(module)

    [safe_cd(s) for s in folders]
    schedule("cmake ",cmake_options)
    if options['rule']!='config':
        schedule("make ",make_options)
    if (run_cde!=""):
        if (options['platform'] == "windows"):
            schedule("wine ",run_cde,True)
        schedule(run_cde,"",exec_cde=True)
    [schedule("cd","..") for s in folders]

##########################################################################################################################
def uninstall(options):
    if options['wrapper']!='':
        install_folder=sysconfig.get_python_lib(1,0,prefix=install_folder)

        print "suppresion récursive de "+RED+install_folder+"/pyAgrum"+ENDC
        os.system('cd '+install_folder+' && rm -rf pyAgrum')
        print "suppresion récursive de "+RED+install_folder+"/gumLib"+ENDC
        os.system('cd '+install_folder+' && rm -rf gumLib')
        print "suppresion de "+RED+install_folder+"/pyAgrum*.egg-info"+ENDC
        os.system('rm -f '+install_folder+"/pyAgrum*.egg-info")
    else:
        folders=["build",options['platform'],options['option']]
        [safe_cd(s) for s in folders]
        schedule("mak","uninstall")
        [schedule("cd","..") for s in folders]

###################################################################################################################
def _getParam(name):
  return ENDC+'--'+RED+name

def getParam(name):
  return _getParam(name)+" "

def getValParam(name,val):
  return _getParam(name)+ENDC+'='+OKGREEN+val+" "

def getCommand(name):
  return OKGREEN+name+" "

def getInvocation(current):  
    invocation=WARNING+"invocation"+ENDC+" : "+"act "
    
    invocation+=getCommand(current['rule'])
    
    if not current['rule'] in "show clean uninstall default".split():
      if current['rule']=='wrapper':
        invocation+=getCommand(current['wrapper'])
      else:
        invocation+=getCommand(current['option'])
        
      invocation+=getValParam('module',current['module'])
      
      if (current['rule']=='test'):
        invocation+=getValParam('testlist',current['testlist'])
        if current['test_base']:
          invocation+=getParam("with-test-base")
        else:
          invocation+=getParam("without-test-base")
      
      if (current['rule']=='install'):
        invocation+=getValParam('dest',current['destination'])
        
      invocation+=getValParam('platform',current['platform'])
      
      if (current['verbose']):
        invocation+=getParam('verbose')
      else:
        invocation+=getParam('quiet')

      if (current['stats']):
        invocation+=getParam('stats')

      if (current['fixed_seed']):
        invocation+=getParam('fixed_seed')
        
        
      invocation+=getValParam('jobs',str(current['jobs']))
    else:
      if current['rule']=="uninstall":
        invocation+=getCommand(current['option'])

    invocation+=ENDC
    return invocation
  
##########################################################################################################################
listOfModules=parseModulesTxt(modulestxt)

default={}
current={}
persistent={}

list_rules="config test run agrum wrapper install doc clean default show uninstall package".split()
list_options="debug release".split()
list_wrappers="pyAgrum jAgrum".split()

default['platform']="linux"
default['option']="release"
default['rule']="agrum"
default['destination']="/usr"
default['wrapper']=""
default['jobs']="5"
default['test_base']=True
default['verbose']=False
default['fixed_seed']=False
default['stats']=False
default['module']='ALL'
default['testlist']='all'

not_persistent_options=['fixed_seed','stats']


shlv=shelve.open(".options.mak.py",writeback=True)
if shlv.has_key('persistent'):
    persistent=shlv['persistent']

#shlv=shelve.open(".options.mak.py",writeback=True)
#if shlv.has_key('persistent'):
#    persistent=shlv['persistent']

for key in default.iterkeys():
  if not key in not_persistent_options:
    if persistent.has_key(key):
        current[key]=persistent[key]
    else:
        current[key]=default[key]

print ENDC+RED+"aGrUM"+ENDC+" compilation tool "+RED+"v"+numversion+ENDC
print "(c) 2010-13 "+OKGREEN+"aGrUM Team"+ENDC
print


parser=initParser(current)
(options, args)=parser.parse_args()

checkConstraints(parser,options,args)

moduleManagement(options.module)

print(getInvocation(current))
print

if options.testlist!="":
    testManagement(options.testlist)
    
checkTestListCmake()
#needed for cmake
if not os.path.exists('src/testunits/testList.cmake'):
    writeTestList(allTests())
    
global sh,sh_no_exec
sh=[];
sh_no_exec=[]

## SPECIAL RULES
if current['rule']=='show':
    showAll()
    sys.exit(0)
if current['rule']=='clean':
    cleanAll()
    sys.exit(0)
if current['rule']=='uninstall':
    uninstall(current)
    if (options.verbose):
      print("")
      print(sh)
      print("")
      print(sh_no_exec)
      print("")
    os.system(sh)
    sys.exit(0)
    
if current['rule']=='default':
    current=default
    print(getInvocation(current))

for key in current:
  if not key in not_persistent_options:
    persistent[key]=current[key]
shlv['persistent']=persistent
shlv.close()


proceed(current,RANDOMSEED_FOR_FIXED_SEED="10")

if (options.verbose):
  print("")
  print(sh)
  print("")
  print(sh_no_exec)
  print("")

if not(current['stats']):
  execute(sh)
else:
  execute(sh_no_exec)
  print("###########################################")
  print("Processing profile for "+getInvocation(current))
  print("This will take a certain amount of time ...")
  print("###########################################")
  time_line=re.compile(r'## Profiling :\s+(.*?)\sms ##')
  stat_line=re.compile(r"Failed (.*?) of (.*?) test")
  
  vals=list()
  for i in range(nbr_tests_for_stats):
    p=subprocess.Popen(sh,shell=True,stderr=subprocess.PIPE,stdout=subprocess.PIPE)
    out=p.stderr.readlines()
    tps=0
    failed=0
    total=0
    for line in out:
      time_match = time_line.search(line) 
      if time_match:
        tps=int(time_match.groups()[0])
        continue
      
      stat_match = stat_line.search(line)
      if stat_match:
        failed=int(stat_match.groups()[0])
        total=int(stat_match.groups()[1])
       
    print("Stats {3}/{4} : succes rate {0}/{1} in {2} ms".format(total-failed,total,tps,i+1,nbr_tests_for_stats))
    vals.append(tps)
    
  s=0.0
  s2=0.0
  for v in vals:
    s+=v
    s2+=v*v
  mean=s/nbr_tests_for_stats
  var=s2/nbr_tests_for_stats-mean*mean
  print("=======================")
  print("Mean :{0}".format(mean))
  print("StdDev :{0}".format(math.sqrt(var)))
