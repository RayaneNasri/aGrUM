/***************************************************************************
 *   Copyright (C) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
/** @file
 * @brief the class for computing BIC scores
 *
 * @author Christophe GONZALES and Pierre-Henri WUILLEMIN
 */

#ifndef DOXYGEN_SHOULD_SKIP_THIS


#include <agrum/learning/scoreBIC.h>


namespace gum {

  
  namespace learning {

    
    /// default constructor
    ScoreBIC::ScoreBIC ( const Database& database,
                         unsigned int max_tree_size ) :
      AsymmetricScore ( database, max_tree_size ) {
      // for debugging purposes
      GUM_CONSTRUCTOR ( ScoreBIC );
    }
    

    /// destructor
    ScoreBIC::~ScoreBIC () {
      // for debugging purposes
      GUM_DESTRUCTOR ( ScoreBIC );
    }


    /// computes the BIC score of a set of targets
    void
    ScoreBIC::_computeScores ( const std::vector<unsigned int>& db_single_ids ) {
      // initialize a vector containing the scores of each id: this should be
      // the penalty of the BIC score, i.e., -0.5 log(N) * (ri-1 ) * qi, but, here
      // we compute the common penalty to all the single nodes, i.e.,
      // -0.5 log(N) * qi
      std::vector<float> score ( db_single_ids.size (), 0.0f );
      float basic_penalty = 0.5f * _logf ( _database->nbrLines () );
      for ( unsigned int i = 0; i < _db_conditioning_ids->size(); ++i ) {
        basic_penalty *=
          _database->nbrModalities ( _db_conditioning_ids->operator[] ( i ) );
      }
      
      // get the list of target set boxes generated by parsing the database
      float score_i;
      const List<CountingTreeTargetSetBox*>& records = _tree.nbRecords ();
      for ( ListConstIterator<CountingTreeTargetSetBox*> iter =
              records.cbegin (); iter != records.cend (); ++iter ) {
        // get the target set box
        const CountingTreeTargetSetBox* const boxset = *iter;
        
        // get the number Nij of occurences of the parents
        const float Nij = boxset->nbParentRecords ();

        // add the score for each single id
        for ( unsigned int i = 0; i < db_single_ids.size (); ++i ) {
          // get the records for the ith variable
          const std::vector<unsigned int>& single_records =
            boxset->child ( i )->nbRecords ();

          // parse the records
          score_i = -Nij * _logf ( Nij );
          for ( unsigned int j = 0; j < single_records.size (); ++j ) {
            score_i += single_records[j] * _logf ( single_records[j] );
          }
          score[i] += score_i;
        }
      }

      // now, store the result into the Score class _single_scores field
      for ( unsigned int i = 0; i < db_single_ids.size (); ++i ) {
        _single_scores.insert
          ( db_single_ids[i],
            ( score[i] - basic_penalty *
              ( _database->nbrModalities ( db_single_ids[i] ) - 1 ) ) * _1log2 );
      }
    }

    
    /// computes the BIC score of a set of targets
    void
    ScoreBIC::_computeScores
    ( const std::vector< std::pair<unsigned int,
                                   unsigned int> >& db_pair_ids ) {
      // initialize a vector containing the scores of each id: this should be
      // the penalty of the BIC score, i.e., -0.5 log(N) * (ri-1 ) * qi, but, here
      // we compute the common penalty to all the pairs of target nodes, i.e.,
      // -0.5 log(N) * qi
      std::vector<float> score ( db_pair_ids.size (), 0 );
      float basic_penalty = 0.5f * _logf ( _database->nbrLines () );
      for ( unsigned int i = 0; i < _db_conditioning_ids->size(); ++i ) {
        basic_penalty *=
          _database->nbrModalities ( _db_conditioning_ids->operator[] ( i ) );
      }
      
      // for each pair, determine the offset of the corresponding induced single
      // id within the targetSetBox
      std::vector<unsigned int> single_offset ( db_pair_ids.size () );
      for ( unsigned int i = 0; i < single_offset.size (); ++i ) {
        single_offset[i] = _tree.targetIndex ( db_pair_ids[i].first );
      }

      // get the list of target set boxes generated by parsing the database
      float score_i;
      const List<CountingTreeTargetSetBox*>& records = _tree.nbRecords ();
      for ( ListConstIterator<CountingTreeTargetSetBox*> iter =
              records.cbegin (); iter != records.cend (); ++iter ) {
        // get the target set box
        const CountingTreeTargetSetBox* const boxset = *iter;
        
        // add the score for each pair of targets
        for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
          // get the records for the ith pair of variables and for its induced
          // single variable
          const std::vector<unsigned int>& pair_records =
            boxset->child ( i )->nbRecords ();
          const std::vector<unsigned int>& single_records =
            boxset->child ( single_offset[i] )->nbRecords ();

          // parse the records
          score_i = 0;
          for ( unsigned int j = 0; j < single_records.size (); ++j ) {
            // get the number Nij of occurences of the parents
            const float Nij = single_records[j];
            score_i -= Nij * _logf ( Nij );

            for ( unsigned int k = j; k < pair_records.size ();
                  k += single_records.size () ) {
              score_i += pair_records[k] * _logf ( pair_records[k] );
            }
          }
          score[i] += score_i;
        }
      }

      // now, store the result into the Score class _pair_scores field
      for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
        _pair_scores.insert
          ( db_pair_ids[i],
            ( score[i] - basic_penalty *
              _database->nbrModalities ( db_pair_ids[i].first ) *
              ( _database->nbrModalities ( db_pair_ids[i].second ) - 1 ) ) *
            _1log2  );
      }
    }
    

  } /* namespace learning */
  
  
} /* namespace gum */


#endif /* DOXYGEN_SHOULD_SKIP_THIS */
