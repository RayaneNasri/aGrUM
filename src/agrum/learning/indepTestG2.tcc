/***************************************************************************
 *   Copyright (C) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
/** @file
 * @brief the class for computing G2 scores
 *
 * @author Christophe GONZALES and Pierre-Henri WUILLEMIN
 */

#ifndef DOXYGEN_SHOULD_SKIP_THIS


#include <agrum/learning/indepTestG2.h>

namespace gum {

  
  namespace learning {

    
    /// default constructor
    IndepTestG2::IndepTestG2 ( const Database& database,
                               unsigned int max_tree_size ) :
    SymmetricIndependenceTest ( database, max_tree_size ),
      __chi2 ( database ) {
      // for debugging purposes
      GUM_CONSTRUCTOR ( IndepTestG2 );
    }


    /// destructor
    IndepTestG2::~IndepTestG2 () {
      // for debugging purposes
      GUM_DESTRUCTOR ( IndepTestG2 );
    }

    
    /// computes the G2 of (X,Y) given conditioning set Z
    void IndepTestG2::_computeScores
    ( const std::vector< std::pair<unsigned int, unsigned int> >& db_pair_ids ) {
      // indicate to the chi2 distribution the set of conditioning nodes
      __chi2.setConditioningNodes ( *_db_conditioning_ids );
      
      // for each pair, determine the offset of the corresponding induced single
      // ids within the targetSetBox
      std::vector<unsigned int> first_offset ( db_pair_ids.size () );
      std::vector<unsigned int> second_offset ( db_pair_ids.size () );
      for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
        first_offset[i] = _tree.targetIndex ( db_pair_ids[i].first );
        second_offset[i] = _tree.targetIndex ( db_pair_ids[i].second );
      }

      // initialize a vector containing the scores
      std::vector<float> score ( db_pair_ids.size (), 0 );
      
      // get the list of target set boxes generated by parsing the database
      float score_i;
      const List<CountingTreeTargetSetBox*>& records = _tree.nbRecords ();
      for ( ListConstIterator<CountingTreeTargetSetBox*> iter =
              records.cbegin (); iter != records.cend (); ++iter ) {
        // get the target set box
        const CountingTreeTargetSetBox* const boxset = *iter;

        // get the number Nz of occurences of the parents
        const float Nz = boxset->nbParentRecords ();
       
        // add the score for each pair of targets
        for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
          // get the records for the ith pair of variables and for its induced
          // single variables
          const std::vector<unsigned int>& Nxyz =
            boxset->child ( i )->nbRecords ();
          const std::vector<unsigned int>& Nxz =
            boxset->child ( first_offset[i] )->nbRecords ();
          const std::vector<unsigned int>& Nyz =
            boxset->child ( second_offset[i] )->nbRecords ();

          // get the domain size of x (consecutive occurences of Y in Nxy are
          // separated by |X| elements
          const unsigned int x_size = Nxz.size ();
          const unsigned int y_size = Nyz.size ();

          // now, perform sum_X sum_Y sum_Z ( #XYZ - #XZ * #YZ / #Z )^2 /
          // (#XZ * #YZ / #Z )
          score_i = 0;
          for ( unsigned int j = 0, k = 0; j < y_size; ++j ) {
            for ( unsigned int i = 0; i < x_size; ++i, k++ ) {
              score_i += Nxyz[k] * log ( ( Nxyz[k] * Nz ) / ( Nxz[i] * Nyz[j] ) );
            }
          }
          score[i] += score_i;
        }
      }

      // ok, here, score[i] contains the value of the chi2 formula for each
      // pair. To get a meaningful score, we shall compute the critical values
      // for the Chi2 distribution and assign as the score of the ith pair
      // (score[i] - alpha ) / alpha, where alpha is the critical value
      for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
        float alpha = __chi2.criticalValue ( db_pair_ids[i] );
        _pair_scores.insert ( db_pair_ids[i], ( score[i] - alpha ) / alpha );
      }
    }


  } /* namespace learning */
  
  
} /* namespace gum */


#endif /* DOXYGEN_SHOULD_SKIP_THIS */
