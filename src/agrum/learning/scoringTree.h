/***************************************************************************
 *   Copyright (C) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
/** @file
 * @brief a generic Scoring Tree class designed for learning.
 *
 * @author Christophe GONZALES and Pierre-Henri WUILLEMIN
 *
 * This file provides a Scoring Tree implementation that fills itself by
 * directly parsing a database. The class can also produce the list of
 * target set boxes of interest. However, it does not compute scores by itself.
 */

#ifndef GUM_LEARNING_SCORING_TREE_H
#define GUM_LEARNING_SCORING_TREE_H


#include <agrum/config.h>
#include <agrum/core/hashTable.h>
#include <agrum/learning/database.h>
#include <agrum/learning/scoringTreeBoxes.h>


namespace gum {

  
  namespace learning {

    
    /* ========================================================================= */
    /* ========================================================================= */
    /* ===                          SCORING TREE BOX                         === */
    /* ========================================================================= */
    /* ========================================================================= */
    /** @class ScoringTree
     */
    /* ========================================================================= */
    class ScoringTree {
    public:
      // ##########################################################################
      /// @name Constructors / Destructors
      // ##########################################################################
      /// @{

      /// default constructor
      /** @param database the database that will be used to fill the tree */
      ScoringTree ( const Database& database );

      /// destructor
      ~ScoringTree ();

      /// @}


      // ##########################################################################
      /// @name Accessors / Modifiers
      // ##########################################################################
      /// @{

      /// assign a new set of conditioning nodes 
      void setConditioningNodes ( const std::vector<unsigned int>& db_node_ids );

      /// assign a new set of single and pairwise target nodes
      void setTargetNodes
      ( const std::vector<unsigned int>& db_single_ids,
        const std::vector< std::pair<unsigned int,unsigned int> >& db_pair_ids);

      /// assign a new set of conditioning and target nodes
      void setNodes
      ( const std::vector<unsigned int>& db_conditioning_ids,
        const std::vector<unsigned int>& db_single_target_ids,
        const std::vector< std::pair<unsigned int,unsigned int> >&
        db_pair_target_ids );

      /// returns the index within target sets of a single target node id
      unsigned int targetIndex ( unsigned int db_target_id ) const;
        
      /// returns the index within target sets of a pair of target nodes
      unsigned int targetIndex ( const std::pair<unsigned int,unsigned int>&
                                 db_target_id ) const;

      /// returns the list of target set generated by parsing the database
      const ListBase<ScoringTreeTargetSetBox*>& nbRecords ();

      /// clear the whole tree
      void clear ();
        
      /// @}

      

    private:
      /// the database we shall parse
      const Database* __database;

      /// a vector indicating the set of conditioning ids (in the database)
      std::vector<unsigned int>* __db_conditioning_ids;

      /// a vector containing the db single target ids
      std::vector<unsigned int>* __db_single_ids;

      /// a vector containing the db pair of target ids
      std::vector< std::pair<unsigned int,unsigned int> >* __db_pair_target_ids;

      /// the index in the target sets of a given db node id
      HashTable<unsigned int,unsigned int> __dbSingle2target;

      /// the index in the target sets of a given db pair of nodes
      HashTable<std::pair<unsigned int,unsigned int>,unsigned int> __dbPair2target;
        
      /// a vector containing the sizes of each target box (pair and single nodes)
      /** the vector first contains the modalities (domain sizes) of the pair
       * ordered similarly to __db_pair_target_ids, and then those of the single
       * nodes ordered similarly to __db_single_ids */
      std::vector<unsigned int> __target_modalities;
        
       /// a Boolean indicating whether we need to recmpute the tree
      bool __requires_compute;

      /// the tree itself
      union Root {
        ScoringTreeConditioningBox* Conditioning;
        ScoringTreeTargetSetBox*    TargetSet;
      } __root;

      /// the list of all target set boxes created by parsing the database
      ListBase<ScoringTreeTargetSetBox*> __target_records;



        
      /// parse one database record to fill a given target set box
      void __fillTargetSetBox ( ScoringTreeTargetSetBox* box,
                                const DatabaseIterator& iter );

      /// traverse the conditional nodes of the tree corresponding to one db record
      /** this method starts from the root of a conditional tree and traverses
       * the tree, constructing any conditional or target set box needed, until
       * all conditioning nodes have been parsed */
      ScoringTreeTargetSetBox*
      __parseConditioningBoxes ( const DatabaseIterator& iter );
        
      /** @brief fill a whole tree by parsing the complete database when there
       * are no conditional nodes
       *
       * This method creates from sratch a new tree containing only pair targets
       * and fills it by parsing the whole database. When the method completes,
       * the __target_records fields contains all the counting for target pairs.*/
      void __fillUnconditionalPairTree ();

      /** @brief fill a whole tree by parsing the complete database when there
       * are conditional nodes
       *
       * This method creates from sratch a new tree containing only conditioning
       * nodes and pair targets, and it fills it by parsing the whole database.
       * When the method completes, the __target_records fields contains all the
       * counting for target pairs. */      
      void __fillConditionalPairTree ();

      /// fill the single targets
      /** assuming that the tree for all conditioning and target pairs has
       * been successfully created, this method */
      void __fillSingleTargetTree ();
      
    };
    

  } /* namespace learning */
  
  
} /* namespace gum */


/// include the inlined functions if necessary
#ifndef GUM_NO_INLINE
#include <agrum/learning/scoringTree.inl>
#endif /* GUM_NO_INLINE */


#endif /* GUM_LEARNING_SCORING_TREE_H */

