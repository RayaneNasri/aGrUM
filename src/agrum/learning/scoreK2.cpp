/***************************************************************************
 *   Copyright (C) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
/** @file
 * @brief the class for computing K2 scores
 *
 * @author Christophe GONZALES and Pierre-Henri WUILLEMIN
 */

#ifndef DOXYGEN_SHOULD_SKIP_THIS


#include <cmath>
#include <agrum/learning/scoreK2.h>


/// include the inlined functions if necessary
#ifdef GUM_NO_INLINE
#include <agrum/learning/scoreK2.inl>
#endif /* GUM_NO_INLINE */


namespace gum {

  
  namespace learning {

    
    /// default constructor
    ScoreK2::ScoreK2 ( const Database& database,
                       unsigned int max_tree_size ) :
    AsymmetricScore ( database, max_tree_size ),
      __log_fact ( MAX_LOG_CACHE ),
      __log_sqrt_2pi ( 0.5 * log ( 2 * M_PI) ) {
      // for debugging purposes
      GUM_CONSTRUCTOR ( ScoreK2 );

      // compute the cache for log (n!) for the first integers
      double nb = 0;
      for ( unsigned int i = 1; i < MAX_LOG_CACHE; ++i ) {
        nb += log ( i );
        __log_fact[i] = nb;
      }
    }
    

    /// destructor
    ScoreK2::~ScoreK2 () {
      // for debugging purposes
      GUM_DESTRUCTOR ( ScoreK2 );
    }

    
    /// computes the K2 score of a set of targets
    void
    ScoreK2::_computeScores ( const std::vector<unsigned int>& db_single_ids ) {
      // compute the size of the common conditioning size
      float cond_size = 1;
      for ( unsigned int i = 0; i < _db_conditioning_ids->size(); ++i ) {
        cond_size *=
          _database->nbrModalities ( _db_conditioning_ids->operator[] ( i ) );
      }
      
      // initialize a vector containing the scores of each id
      std::vector<float> score ( db_single_ids.size (), 0 );
      
      // precompute the log of (ri - 1)! and add the initial penalty to the score
      std::vector<unsigned int> ri_minus_1 ( db_single_ids.size () );
      for ( unsigned int i = 0; i < db_single_ids.size (); ++i ) {
        ri_minus_1[i] = _database->nbrModalities ( db_single_ids[i] ) - 1;
        score[i] = cond_size * __logFactorial ( ri_minus_1[i] );
      }
      
      // get the list of target set boxes generated by parsing the database
      float score_i;
      const ListBase<CountingTreeTargetSetBox*>& records = _tree.nbRecords ();
      for ( const ListBucket<CountingTreeTargetSetBox*>* iter =
              records.frontBucket (); iter; iter = iter->next () ) {
        // get the target set box
        const CountingTreeTargetSetBox* const boxset = **iter;
        
        // get the number Nij of occurences of the parents
        const float Nij = boxset->nbParentRecords ();

        // add the score for each single id
        for ( unsigned int i = 0; i < db_single_ids.size (); ++i ) {
          // get the records for the ith variable
          const std::vector<unsigned int>& single_records =
            boxset->child ( i )->nbRecords ();

          // parse the records
          score_i = - __logFactorial ( Nij + ri_minus_1[i] ); 
          for ( unsigned int k = 0; k < single_records.size (); ++k ) { 
            score_i += __logFactorial ( single_records[k] );
          }
          score[i] += score_i;
        }
      }

      // now, store the result into the Score class _single_scores field
      for ( unsigned int i = 0; i < db_single_ids.size (); ++i ) {
        _single_scores.insert ( db_single_ids[i], score[i] );
      }
    }

    
    /// computes the K2 score of a set of targets
    void
    ScoreK2::_computeScores
    ( const std::vector< std::pair<unsigned int,
                                   unsigned int> >& db_pair_ids ) {
      // compute the size of the common conditioning size
      float cond_size = 1;
      for ( unsigned int i = 0; i < _db_conditioning_ids->size(); ++i ) {
        cond_size *=
          _database->nbrModalities ( _db_conditioning_ids->operator[] ( i ) );
      }
      
      // initialize a vector containing the scores of each id
      std::vector<float> score ( db_pair_ids.size (), 0 );
 
      // precompute the log of (ri - 1)! and add the initial penalty to the score
      std::vector<unsigned int> ri_minus_1 ( db_pair_ids.size () );
      for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
        ri_minus_1[i] = _database->nbrModalities ( db_pair_ids[i].second ) - 1;
        score[i] = cond_size * _database->nbrModalities ( db_pair_ids[i].first ) *
          __logFactorial ( ri_minus_1[i] );
      }

      // for each pair, determine the offset of the corresponding induced single
      // id within the targetSetBox
      std::vector<unsigned int> single_offset ( db_pair_ids.size () );
      for ( unsigned int i = 0; i < single_offset.size (); ++i ) {
        single_offset[i] = _tree.targetIndex ( db_pair_ids[i].first );
      }

      // get the list of target set boxes generated by parsing the database
      float score_i;
      const ListBase<CountingTreeTargetSetBox*>& records = _tree.nbRecords ();
      for ( const ListBucket<CountingTreeTargetSetBox*>* iter =
              records.frontBucket (); iter; iter = iter->next () ) {
        // get the target set box
        const CountingTreeTargetSetBox* const boxset = **iter;
        
        // add the score for each pair of targets
        for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
          // get the records for the ith pair of variables and for its induced
          // single variable
          const std::vector<unsigned int>& pair_records =
            boxset->child ( i )->nbRecords ();
          const std::vector<unsigned int>& single_records =
            boxset->child ( single_offset[i] )->nbRecords ();

          // parse the records
          score_i = 0;
          for ( unsigned int j = 0; j < single_records.size (); ++j ) {
            // get the number Nij of occurences of the parents
            const float Nij = single_records[j];
            score_i -= __logFactorial ( Nij + ri_minus_1[i] ); ;

            for ( unsigned int k = j; k < pair_records.size ();
                  k += single_records.size () ) {
              score_i += __logFactorial ( pair_records[k] );
            }
          }
          score[i] += score_i;
        }
      }

      // now, store the result into the Score class _pair_scores field
      for ( unsigned int i = 0; i < db_pair_ids.size (); ++i ) {
        _pair_scores.insert ( db_pair_ids[i], score[i] );
      }
    }
    

  } /* namespace learning */
  
  
} /* namespace gum */


#endif /* DOXYGEN_SHOULD_SKIP_THIS */
