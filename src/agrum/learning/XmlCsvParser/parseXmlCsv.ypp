%{
#include <iostream>
#include <limits>
#include <string.h>
#include <vector>
#include <sstream>
#include <exception>

#include <agrum/core/exceptions.h>
#include <agrum/core/hashTable.h>
#include <agrum/learning/database.h>
%}

%output="parseXmlCsv.cpp"
%name-prefix="GUM_PARSE_XML_CSV_"
%parse-param {gum::Database& database}

%union {
  char  Char;
  int   Int;
}


%{
  // The pointer on the file being parsed
  extern FILE *GUM_PARSE_XML_CSV_in;
  
  // Declaration of the lex analyzer function
  int GUM_PARSE_XML_CSV_lex (YYSTYPE* GUM_PARSE_XML_CSV_lval);

  // Declaration of the yacc-generated parser function
  int GUM_PARSE_XML_CSV_parse ();

  // Declaration of the error routine
  int GUM_PARSE_XML_CSV_error(gum::Database&, const char*);

  // Declaration of the user-defined parser function
  bool GUM_PARSE_XML_CSV_parser (gum::Database&, const std::string&);

  // These two are used by GUM_PARSE_XML_CSV_lex.lpp
  // Key of the last value inserted in GUM_PARSE_XML_CSV_words
  unsigned int GUM_PARSE_XML_CSV_words_size;
  
  // Stores the values of GUM_PARSE_XML_CSV_text
  // this simply avoid memory leaks due to flex/yacc
  gum::HashTable<unsigned int,std::string> *GUM_PARSE_XML_CSV_words;

  // the last variable name read so far
  std::string GUM_PARSE_XML_CSV_current_variable_name;

  // In the file to be read, modalities have names (given in tags <MODALITY />)
  // and ids (also given in tags <MODALITY />). These ids are used later in
  // the file in tags <CASE></CASE> to indicate which modalities ahve been observed.
  // For instance, if we have at the beginning of the file :
  // <VARIABLE name="X">
  //   <MODALITY name="xxx" id="42"/>
  //   <MODALITY name="yyy" id="23"/>
  //   <MODALITY name="zzz" id="15"/>
  // </VARIABLE>
  // and, in the <CASE> section we observe that variable X has taken values
  // 42,23,23,15,42. Then thismeans that xxx,yyy,yyy,zzz,xxx where actually
  // observed. It is not convenient to use these ids in the database. Hence
  // we transform them into numbers from 0 to n, i.e., xxx will be assigned
  // index 0, yyy index 1 and zzz index 2. In the gum::Database, we will thus
  // only store the names of the modalities and their corresponding index.
  
  // the names of the modalities (the index in the vector corresponds to the
  // aformentioned index)
  std::vector<std::string> *GUM_PARSE_XML_CSV_modality_name;

  // hash table associating to each modality id (the key) its index (the value)
  gum::HashTable<int, unsigned int> *GUM_PARSE_XML_CSV_modality_id2index;

  // the current index generated so far
  unsigned int GUM_PARSE_XML_CSV_modality_index;
  
  // the current modality id
  unsigned int GUM_PARSE_XML_CSV_modality_id;

  // a boolean indicating wether the current modality_id has been assigned to
  // a given modality. This is used to generate new ids for new modalities for
  // which the user did not provide explicitly an id value
  bool GUM_PARSE_XML_CSV_modality_id_assigned;

  // a vector indicating, for each variable, the correspondence between
  // the ids of the variable's modalities and their index
  std::vector<gum::HashTable<int,unsigned int> >
    *GUM_PARSE_XML_CSV_modality_id2index_per_var;
  
  // a temporary vector for storing the __cases
  std::vector<unsigned int*>* GUM_PARSE_XML_CSV_database_cases;

  // a pointer to the GUM_PARSE_XML_CSV_database_cases where the current file
  // observation should be stored
  unsigned int* GUM_PARSE_XML_CSV_database_pointer;

  // the number of fields already read in the current case
  unsigned int GUM_PARSE_XML_CSV_database_field_number;

  // the number of __cases observed so far
  unsigned int GUM_PARSE_XML_CSV_database_nb_cases;

  
  
%}


%defines

%token <Int>   TOK_DATABASE_TAG_BEGIN
%token <Int>   TOK_DATABASE_TAG_END
%token <Int>   TOK_VARIABLE_TAG_BEGIN
%token <Int>   TOK_VARIABLE_TAG_END
%token <Int>   TOK_END_VARIABLE_TAG
%token <Int>   TOK_MODALITY_TAG_BEGIN
%token <Int>   TOK_MODALITY_TAG_END
%token <Int>   TOK_ID_TAG
%token <Int>   TOK_DATA_TAG
%token <Int>   TOK_END_DATA_TAG
%token <Int>   TOK_CASE_TAG
%token <Int>   TOK_END_CASE_TAG
%token <Int>   TOK_NAME_TAG
%token <Int>   TOK_STRING
%token <Char>  TOK_EQUAL
%token <Char>  TOK_ERROR
%token <Int>   TOK_INTEGER
%token         TOK_MISSING

%pure-parser

%%


DatabaseUnit:
    /* empty */
  | TOK_DATABASE_TAG_BEGIN VariablesUnit DataUnit TOK_DATABASE_TAG_END
  | error { GUM_ERROR(gum::IOError, "Invalid Syntax"); }
;


VariablesUnit:
    /* empty */
  | VariablesUnit VariableUnit
;


VariableUnit:
    TOK_VARIABLE_TAG_BEGIN VariableNameUnit TOK_VARIABLE_TAG_END
    ModalitiesUnit
    TOK_END_VARIABLE_TAG {
        // save the name of the variable
        if (GUM_PARSE_XML_CSV_current_variable_name.empty())
          GUM_PARSE_XML_CSV_error (database,
                                   "empty variable names are not allowed");
        database.__node_names.push_back (GUM_PARSE_XML_CSV_current_variable_name);
        database.__node_name_per_id.insert (GUM_PARSE_XML_CSV_current_variable_name,
                                          database.__nb_nodes);
 
        // save the modalities of the node
        database.__nb_modalities.push_back (GUM_PARSE_XML_CSV_modality_name->size());
        database.__modalities_names.push_back (*GUM_PARSE_XML_CSV_modality_name);

        // store the modalities of the variables for reading appropriately
        // the <case>s section of the file
        GUM_PARSE_XML_CSV_modality_id2index_per_var->push_back
          (*GUM_PARSE_XML_CSV_modality_id2index);
        
        // ok, let's clean up for the next variable
        ++database.__nb_nodes;
        GUM_PARSE_XML_CSV_current_variable_name.clear ();
        GUM_PARSE_XML_CSV_modality_name->clear ();
        GUM_PARSE_XML_CSV_modality_id2index->clear ();
        GUM_PARSE_XML_CSV_modality_index = 0;
        GUM_PARSE_XML_CSV_modality_id = 0;
        GUM_PARSE_XML_CSV_modality_id_assigned = false;
      }
;


VariableNameUnit:
    TOK_NAME_TAG TOK_EQUAL TOK_STRING {
        GUM_PARSE_XML_CSV_current_variable_name = (*GUM_PARSE_XML_CSV_words)[$3];
        GUM_PARSE_XML_CSV_words->erase ($3);
      }
;

 
ModalitiesUnit:
    /* empty */
  | ModalitiesUnit TOK_MODALITY_TAG_BEGIN ModalityUnit TOK_MODALITY_TAG_END
;
    

ModalityUnit:
    ModalAllAttributeUnit {
        ++GUM_PARSE_XML_CSV_modality_index;
        GUM_PARSE_XML_CSV_modality_id_assigned = true;
      }
  | ModalNameUnit {
        if (GUM_PARSE_XML_CSV_modality_id_assigned)
          ++GUM_PARSE_XML_CSV_modality_id;
        GUM_PARSE_XML_CSV_modality_id2index->insert
          (GUM_PARSE_XML_CSV_modality_id, GUM_PARSE_XML_CSV_modality_index);
        ++GUM_PARSE_XML_CSV_modality_index;
        GUM_PARSE_XML_CSV_modality_id_assigned = true;
      }
;


ModalAllAttributeUnit:
    ModalNameUnit ModalIdUnit
  | ModalIdUnit ModalNameUnit
;


ModalNameUnit:
    TOK_NAME_TAG TOK_EQUAL TOK_STRING {
        GUM_PARSE_XML_CSV_modality_name->push_back ((*GUM_PARSE_XML_CSV_words)[$3]);
        GUM_PARSE_XML_CSV_words->erase ($3);
      }
;


ModalIdUnit:
    TOK_ID_TAG TOK_EQUAL TOK_INTEGER {
        GUM_PARSE_XML_CSV_modality_id = $3;
        GUM_PARSE_XML_CSV_modality_id2index->insert
          ($3, GUM_PARSE_XML_CSV_modality_index);
      }
;


DataUnit:
    DataInitUnit CasesUnit TOK_END_DATA_TAG {
        // reserve the memory needed to store the database
        database.__nb_cases = GUM_PARSE_XML_CSV_database_nb_cases;
        database.__cases = new unsigned int [database.__nb_cases * database.__nb_nodes];

        // fill the __cases
        delete[] ((*GUM_PARSE_XML_CSV_database_cases)[database.__nb_cases]);
        GUM_PARSE_XML_CSV_database_cases->pop_back ();
        size_t line_size = database.__nb_nodes * sizeof (unsigned int);
        for (unsigned int i = 0, *ptr_cases = database.__cases;
             i < database.__nb_cases; ++i, ptr_cases += database.__nb_nodes) {
          memcpy (ptr_cases, (*GUM_PARSE_XML_CSV_database_cases)[i],line_size);
          delete[] ((*GUM_PARSE_XML_CSV_database_cases)[i]);
          (*GUM_PARSE_XML_CSV_database_cases)[i] = 0;
        }
      }
;


DataInitUnit:
    TOK_DATA_TAG  {
        // initialize the __cases vector
        GUM_PARSE_XML_CSV_database_field_number = 0;
        GUM_PARSE_XML_CSV_database_nb_cases = 0;
        unsigned int* new_case = new unsigned int[database.__nb_nodes];
        GUM_PARSE_XML_CSV_database_cases->push_back (new_case);
        GUM_PARSE_XML_CSV_database_pointer = new_case;
      }
;


CasesUnit:
    /* empty */
  | CasesUnit TOK_CASE_TAG CaseUnit TOK_END_CASE_TAG {
        // check that the preceding case had precisely __nb_nodes fields
        if (GUM_PARSE_XML_CSV_database_field_number != database.__nb_nodes)
          GUM_PARSE_XML_CSV_error
            (database, "the case does not contain observations for all variables");
        
        // reinitialize the number of fields read so far
        GUM_PARSE_XML_CSV_database_field_number = 0;
        unsigned int* new_case = new unsigned int[database.__nb_nodes];
        GUM_PARSE_XML_CSV_database_cases->push_back (new_case);
        GUM_PARSE_XML_CSV_database_pointer = new_case;
        ++GUM_PARSE_XML_CSV_database_nb_cases;
  }
;


CaseUnit:
    /* empty */
  | CaseUnit TOK_INTEGER {
        // check if the current field actually corresponds to a variable
        if (GUM_PARSE_XML_CSV_database_field_number >= database.__nb_nodes)
          GUM_PARSE_XML_CSV_error
            (database, "the case contains more fields than there are variables");
  
        // get the id of the current modality and convert it into an index
        // then store the result into the gum::Database
        *GUM_PARSE_XML_CSV_database_pointer =
          (*GUM_PARSE_XML_CSV_modality_id2index_per_var)
          [GUM_PARSE_XML_CSV_database_field_number][$2];
        ++GUM_PARSE_XML_CSV_database_pointer;
        ++GUM_PARSE_XML_CSV_database_field_number;
      }
  | CaseUnit TOK_MISSING {
				GUM_ERROR(gum::OperationNotAllowed,"Missing value in XML database is not implemented yet.");
      }
;


%%
  
/* ========================================================================== */
/* === function for printing error messages                               === */
/* ========================================================================== */
int GUM_PARSE_XML_CSV_error(gum::Database& database, const char* s) {
  if (database.__cases) {
    delete database.__cases;
    database.__cases = 0;
  }
  GUM_ERROR(gum::IOError, s);
  return 1;
}


/* ========================================================================== */
/* === function that parses the input file                                === */
/* ========================================================================== */
bool GUM_PARSE_XML_CSV_parser (gum::Database& database,
                               const std::string& filename) {
  //  open the input file
  GUM_PARSE_XML_CSV_in = fopen (filename.c_str(), "r");
  if (GUM_PARSE_XML_CSV_in == NULL) {
    fprintf(stderr, "unable to open file %s\n", filename.c_str());
    return false;
  }

  // create a hashtable for storing the names of the variables and modalities
  // this avoids memory leaks due to flex/bison
  GUM_PARSE_XML_CSV_words = new gum::HashTable<unsigned int,std::string>;
  GUM_PARSE_XML_CSV_modality_name = new std::vector<std::string>;
  GUM_PARSE_XML_CSV_modality_id2index = new gum::HashTable<int,unsigned int>;
  GUM_PARSE_XML_CSV_modality_id2index_per_var =
    new std::vector<gum::HashTable<int,unsigned int> >;
  GUM_PARSE_XML_CSV_database_cases = new std::vector<unsigned int*>;
  
  GUM_PARSE_XML_CSV_words_size = 0;
  GUM_PARSE_XML_CSV_modality_id_assigned = false;
  GUM_PARSE_XML_CSV_modality_index = 0;
  GUM_PARSE_XML_CSV_current_variable_name.clear ();
  GUM_PARSE_XML_CSV_database_nb_cases = 0;

  // indicate that, right now, on the first case line, we did not
  // read any field yet (this is used to check that each case of the
  // <DATA> section actually contains __nb_nodes fields
  GUM_PARSE_XML_CSV_database_field_number = 0;
  
  // parse the input file
  bool result = true;
  try {
    GUM_PARSE_XML_CSV_parse (database);
  }
  catch (gum::Exception& e) {
    if (database.__cases) {
      delete[] database.__cases;
      database.__cases = 0;
    }
    //std::cerr << std::endl << "erreur"; //e.getContent() << std::endl;
    result = false;
    throw e;
  }

  // close the file
  fclose (GUM_PARSE_XML_CSV_in);

  // reset the parser
  for (unsigned int i = 0; i < GUM_PARSE_XML_CSV_database_cases->size(); ++i)
    if ((*GUM_PARSE_XML_CSV_database_cases)[i])
      delete[] (*GUM_PARSE_XML_CSV_database_cases)[i];
  delete GUM_PARSE_XML_CSV_database_cases;  
  delete GUM_PARSE_XML_CSV_words;
  delete GUM_PARSE_XML_CSV_modality_name;
  delete GUM_PARSE_XML_CSV_modality_id2index;
  delete GUM_PARSE_XML_CSV_modality_id2index_per_var;
  GUM_PARSE_XML_CSV_current_variable_name.clear ();
  
  return true;
}

