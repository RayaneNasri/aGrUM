//##############################################################################
//
//                               HEADERS
//
//##############################################################################

#include <string>
#include <vector>
#include <agrum/PRM/newo3prm/o3prm.h>

//##############################################################################
//
//                             class Parser
//
//##############################################################################

COMPILER NEWO3PRM

private:

using O3List = std::vector<std::string>;
using O3Type = gum::prm::o3prm::O3Type;
using O3PRM = gum::prm::o3prm::O3PRM;

O3PRM* __prm;

bool ok (int n) { return errors().error_count == n; }

public:
// Set the parser factory.
void set_prm(O3PRM* prm) {
  __prm = prm;
}

O3PRM* get_prm() {
  return __prm;
}

//##############################################################################
//
//                              SCANNER RULES
//
//##############################################################################

//________________________
CHARACTERS
letter = 'A'..'Z' + 'a'..'z'+ '_' .
digit  = '0'..'9'.
eol    = '\n'.
noQuote1 = ANY - '"' .
noQuote2 = ANY - "'" .

//________________________
TOKENS
integer    = ['+'|'-'] digit {digit}.
float      = ['+'|'-'] digit {digit} '.' digit {digit} [ ('E'|'e') ['+'|'-'] digit {digit} ].
label      = letter {(letter | digit)}.
eol        = '\n'.
dot        = '.'.
comma      = ','.
colon      = ':'.
semicolon  = ';'.
type       = "type".
class      = "class".
interface  = "interface".
extends    = "extends".
system     = "system".
dependson  = "dependson".
default    = "default".
implements = "implements".
int        = "int".
real       = "real".
string     = '"' { noQuote1 } '"' | "'" {noQuote2 } "'" .

//________________________
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\r' + eol + '\t'

$checkEOF=false // disable the end of file check

//##############################################################################
//
//                              PARSER RULES
//
//##############################################################################

PRODUCTIONS

//________________________
NEWO3PRM = UNIT { UNIT } . 

//________________________
UNIT = TYPE_UNIT .

//________________________
TYPE_UNIT = 
  (. auto n = errors().error_count; .)
  (. auto name = std::string(); .)
  (. auto labels = O3List(); .)
  TYPE_BODY<name, labels>
  (. if (ok(n)) { get_prm()->types().push_back( O3Type(name, labels) ); } .)
  .

TYPE_BODY<std::string& name, O3List& labels> =
  type WORD<name> LIST<labels> ';' . 

LIST< O3List& list > =
  (. auto w = std::string(); .)
  WORD<w>
  (. list.push_back(w); .)
  ','
  WORD<w>
  (. list.push_back(w); .)
  {
    ','
    WORD<w>
    (. list.push_back(w); .)
  }
  .

WORD<std::string& w> =
  label (. w = narrow(t->val); .) .

END NEWO3PRM.
