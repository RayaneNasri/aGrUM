//##############################################################################
//
//                               HEADERS
//
//##############################################################################

#include <string>
#include <vector>
#include <utility>
#include <agrum/core/hashTable.h>
#include <agrum/PRM/newo3prm/o3prm.h>

//##############################################################################
//
//                             class Parser
//
//##############################################################################

COMPILER NEWO3PRM

private:

using LabelMap = gum::prm::o3prm::O3Type::LabelMap;
using Position = gum::prm::o3prm::Position;
using O3Integer = gum::prm::o3prm::O3Integer;
using O3Float = gum::prm::o3prm::O3Float;
using O3FloatList = gum::prm::o3prm::O3Attribute::O3FloatList;
using O3Label = gum::prm::o3prm::O3Label;
using O3LabelList = gum::prm::o3prm::O3Class::O3LabelList;

using O3Type = gum::prm::o3prm::O3Type;
using O3IntType = gum::prm::o3prm::O3IntType;

using O3Interface = gum::prm::o3prm::O3Interface;
using O3InterfaceElement = gum::prm::o3prm::O3InterfaceElement;
using O3InterfaceElementList = gum::prm::o3prm::O3Interface::O3InterfaceElementList;

using O3Class = gum::prm::o3prm::O3Class;
using O3Attribute = gum::prm::o3prm::O3Attribute;
using O3AttributeList = gum::prm::o3prm::O3Class::O3AttributeList;

using O3PRM = gum::prm::o3prm::O3PRM;

O3PRM* __prm;

bool __ok (int n) { return errors().error_count == n; }
void __addO3Type( Position& pos,
                  const O3Label& name,
                  const O3Label& super,
                  LabelMap& labels ) {
  auto t = std::unique_ptr<O3Type>( new O3Type( pos, name, super, labels ) );
  get_prm()->types().push_back( std::move( t ) ); 
}

void __addO3IntType( Position& pos,
                     const O3Label& name,
                     const O3Integer& start,
                     const O3Integer& end ) {
  auto t = std::unique_ptr<O3IntType>( new O3IntType( pos, name, start, end ) );
  get_prm()->int_types().push_back( std::move( t ) );
}

void __addO3Interface( Position& pos,
                       const O3Label& name,
                       const O3Label& super,
                       const O3InterfaceElementList& elts ) {
  auto i =
      std::unique_ptr<O3Interface>( new O3Interface( pos, name, super, elts ) );
  get_prm()->interfaces().push_back( std::move( i ) );
}

void __addO3Class( Position& pos,
                   O3Label& name,
                   O3Label& super,
                   O3LabelList& interfaces,
                   O3AttributeList& elts ) {
  auto c = std::unique_ptr<O3Class>(
      new O3Class( pos, name, super, interfaces, elts ) );
  get_prm()->classes().push_back( std::move( c ) );
}

public:
// Set the parser factory.
void set_prm(O3PRM* prm) {
  __prm = prm;
}

O3PRM* get_prm() {
  return __prm;
}

//##############################################################################
//
//                              SCANNER RULES
//
//##############################################################################

//________________________
CHARACTERS
letter = 'A'..'Z' + 'a'..'z'+ '_' .
digit  = '0'..'9'.
eol    = '\n'.
noQuote1 = ANY - '"' .
noQuote2 = ANY - "'" .

//________________________
TOKENS
integer    = ['+'|'-'] digit {digit}.
float      = ['+'|'-'] digit {digit} '.' digit {digit} [ ('E'|'e') ['+'|'-'] digit {digit} ].
label      = letter {(letter | digit)}.
eol        = '\n'.
dot        = '.'.
comma      = ','.
colon      = ':'.
semicolon  = ';'.
type       = "type".
class      = "class".
interface  = "interface".
extends    = "extends".
system     = "system".
dependson  = "dependson".
default    = "default".
implements = "implements".
int        = "int".
real       = "real".
string     = '"' { noQuote1 } '"' | "'" {noQuote2 } "'" .

//________________________
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\r' + eol + '\t'

$checkEOF=false // disable the end of file check

//##############################################################################
//
//                              PARSER RULES
//
//##############################################################################

PRODUCTIONS

//________________________
NEWO3PRM = UNIT { UNIT } . 

//________________________
UNIT = 
  (
    TYPE_UNIT
  |
    INTERFACE_UNIT
  |
    CLASS_UNIT
  )
  .

//________________________
CLASS_UNIT =
  (. auto n = errors().error_count; .)
  (. auto pos = Position(); .)
  (. auto name = O3Label(); .)
  (. auto super = O3Label(); .)
  (. auto interfaces = O3LabelList(); .)
  (. auto elts = O3AttributeList(); .)
  CLASS_DECLARATION<pos, name, super, interfaces, elts >
  (. if (__ok(n)) { __addO3Class( pos, name, super, interfaces, elts ); } .)
  .

//________________________
CLASS_DECLARATION<Position& pos,
                  O3Label& name,
                  O3Label& super,
                  O3LabelList& interfaces,
                  O3AttributeList& elts> =
  CLASS<pos>
  LABEL<name>
  [
    extends LABEL<super>
  ]
  [
    implements LABEL_LIST<interfaces>
  ]
  '{' { CLASS_BODY<elts> } '}'
  .
                   
//________________________
CLASS<Position& pos> =
  class
  (. pos.file( narrow( scanner->filename() ) ); .)
  (. pos.line( t->line ); .)
  (. pos.column( t->col ); .)
  .

//________________________
CLASS_BODY<O3AttributeList& elts> =
  (. auto type = O3Label(); .)
  (. auto name = O3Label(); .)
  (. auto parents = O3LabelList(); .)
  (. auto values = O3FloatList(); .)
  LABEL<type>
  LABEL<name>
  [
    dependson
    LABEL_LIST<parents> 
  ]
  '{'
  '['
    FLOAT_LIST<values>
  ']'
  '}'
  ';'
  (. elts.push_back( O3Attribute(type, name, parents, values) ); .)
  .

//________________________
FLOAT_LIST<O3FloatList& values> =
  (. auto val = O3Float(); .)
  FLOAT<val>
  (. values.push_back( val ); .)
  {
    ','
    FLOAT<val>
    (. values.push_back( val ); .)
  }
  .

//________________________
INTERFACE_UNIT =
  (. auto n = errors().error_count; .)
  (. auto pos = Position(); .)
  (. auto name = O3Label(); .)
  (. auto super = O3Label(); .)
  (. auto elts = O3InterfaceElementList(); .)
  INTERFACE_DECLARATION<pos, name, super, elts >
  (. if (__ok(n)) { __addO3Interface( pos, name, super, elts ); } .)
  .

//________________________
INTERFACE_DECLARATION<Position& pos,
                      O3Label& name,
                      O3Label& super,
                      O3InterfaceElementList& elts> =
  INTERFACE<pos>
  LABEL<name>
  [
    extends LABEL<super>
  ]
  '{' { INTERFACE_BODY<elts> } '}'
  .

//________________________
INTERFACE<Position& pos> =
  interface
  (. pos.file( narrow( scanner->filename() ) ); .)
  (. pos.line( t->line ); .)
  (. pos.column( t->col ); .)
  .

//________________________
INTERFACE_BODY<O3InterfaceElementList& elts> =
  (. auto type = O3Label(); .)
  (. auto name = O3Label(); .)
  LABEL<type> LABEL<name> ';'
  (. elts.push_back( O3InterfaceElement( type, name ) ); .)
  .

//________________________
TYPE_UNIT = 
  (. auto n = errors().error_count; .)
  (. auto pos = Position(); .)
  (. auto name = O3Label(); .)
  (
    (. auto super = O3Label(); .)
    (. auto labels = LabelMap(); .)
    TYPE_DECLARATION<pos, name, super, labels>
    (. if ( __ok( n ) ) { __addO3Type( pos, name, super, labels ); } .)
  |
    (. auto start = O3Integer(); .)
    (. auto end = O3Integer(); .)
    INT_TYPE_DECLARATION<pos, name, start, end>
    (. if ( __ok( n ) ) { __addO3IntType( pos, name, start, end ); } .)
  )
  .

//________________________
TYPE_DECLARATION<Position& pos, O3Label& name, O3Label& super, LabelMap& labels> =
  TYPE<pos>
  LABEL<name> 
  (
    TYPE_VALUE_LIST<labels>
    |
    extends LABEL<super> MAP<labels>
  )
  ';'
  . 

//________________________
TYPE<Position& pos> = 
  type
  (. pos.file( narrow( scanner->filename() ) ); .)
  (. pos.line( t->line ); .)
  (. pos.column( t->col ); .)
  .

//________________________
INT_TYPE_DECLARATION<Position& pos, O3Label& name, O3Integer& start, O3Integer& end> =
  INT<pos>
  '('
  INTEGER<start>
  ','
  INTEGER<end>
  ')'
  LABEL<name>
  ';'
  .

//________________________
INT<Position& pos> =
  int
  (. pos.file( narrow( scanner->filename() ) ); .)
  (. pos.line( t->line ); .)
  (. pos.column( t->col ); .)
  .

//________________________
MAP< LabelMap& labels > =
  (. auto first = O3Label(); .)
  (. auto second = O3Label(); .)
  (. auto pair = std::pair<O3Label, O3Label>(); .)
  LABEL<first> ':' LABEL<second>
  (. pair.first = first; .)
  (. pair.second = second; .)
  (. labels.push_back( pair ); .)
  ','
  LABEL<first> ':' LABEL<second>
  (. pair.first = first; .)
  (. pair.second = second; .)
  (. labels.push_back( pair ); .)
  {
    ','
    LABEL<first> ':' LABEL<second>
    (. pair.first = first; .)
    (. pair.second = second; .)
    (. labels.push_back( pair ); .)
  }
  .

//________________________
TYPE_VALUE_LIST< LabelMap& labels > =
  (. auto l = O3Label(); .)
  (. auto pair = std::pair<O3Label, O3Label>(); .)
  LABEL<l>
  (. pair.first = l; .)
  (. labels.push_back( pair ); .)
  ','
  LABEL<l>
  (. pair.first = l; .)
  (. labels.push_back( pair ); .)
  {
    ','
    LABEL<l>
    (. pair.first = l; .)
    (. labels.push_back( pair ); .)
  }
  .

//________________________
FLOAT<O3Float& f> =
  float
  (. auto pos = Position( narrow( scanner->filename() ), t->line, t->col ); .)
  (. f = O3Float( pos, coco_atof( t->val ) ); .)
  .
  

//________________________
INTEGER<O3Integer& i> =
  integer
  (. auto pos = Position( narrow( scanner->filename() ), t->line, t->col ); .)
  (. i = O3Integer( pos, coco_atoi( t->val ) ); .)
  .

//________________________
LABEL<O3Label& l> =
  label
  (. auto pos = Position( narrow( scanner->filename() ), t->line, t->col ); .)
  (. l = O3Label( pos, narrow( t->val ) ); .)
  .

//________________________
LABEL_LIST<O3LabelList& list> =
  (. auto label = O3Label(); .)
  LABEL<label>
  (. list.push_back( label ); .)
  {
    ','
    LABEL<label> 
    (. list.push_back( label ); .)
  }
  .

//________________________
END NEWO3PRM.
