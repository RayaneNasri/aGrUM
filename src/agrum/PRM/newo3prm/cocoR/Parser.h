/***************************************************************************
 *  aGrUM modified frames and atg files for cocoR
 *   Copyright (c) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr
***************************************************************************/
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(gum_prm_newo3prm_COCO_PARSER_H__)
#define gum_prm_newo3prm_COCO_PARSER_H__

#include <string>
#include <vector>
#include <utility>
#include <agrum/core/hashTable.h>
#include <agrum/PRM/newo3prm/o3prm.h>

#include <iostream>
#include <string>
#include <fstream>
#include "Scanner.h"

namespace gum {
namespace prm {
namespace newo3prm {


class Parser {
  private:
    	enum {
		_EOF=0,
		_integer=1,
		_float=2,
		_label=3,
		_eol=4,
		_dot=5,
		_comma=6,
		_colon=7,
		_semicolon=8,
		_type=9,
		_class=10,
		_interface=11,
		_extends=12,
		_system=13,
		_dependson=14,
		_default=15,
		_implements=16,
		_int=17,
		_real=18,
		_string=19
	};
	int maxT;

    Token* dummyToken;
    int errDist;
    int minErrDist;

    void SynErr( int n );
    void Get();
    void Expect( int n );
    bool StartOf( int s );
    void ExpectWeak( int n, int follow );
    bool WeakSeparator( int n, int syFol, int repFol );

    ErrorsContainer  __errors;

  public:
    Scanner* scanner;

    Token* t;     // last recognized token
    Token* la;      // lookahead token

    private:

using LabelMap = gum::prm::o3prm::O3Type::LabelMap;
using Position = gum::prm::o3prm::Position;
using O3Integer = gum::prm::o3prm::O3Integer;
using O3Float = gum::prm::o3prm::O3Float;
using O3FloatList = gum::prm::o3prm::O3Attribute::O3FloatList;
using O3Label = gum::prm::o3prm::O3Label;
using O3LabelList = gum::prm::o3prm::O3Class::O3LabelList;

using O3Type = gum::prm::o3prm::O3Type;
using O3IntType = gum::prm::o3prm::O3IntType;

using O3Interface = gum::prm::o3prm::O3Interface;
using O3InterfaceElement = gum::prm::o3prm::O3InterfaceElement;
using O3InterfaceElementList = gum::prm::o3prm::O3Interface::O3InterfaceElementList;

using O3Class = gum::prm::o3prm::O3Class;
using O3Attribute = gum::prm::o3prm::O3Attribute;
using O3AttributeList = gum::prm::o3prm::O3Class::O3AttributeList;

using O3PRM = gum::prm::o3prm::O3PRM;

O3PRM* __prm;

bool __ok (int n) { return errors().error_count == n; }
void __addO3Type( Position& pos,
                  const O3Label& name,
                  const O3Label& super,
                  LabelMap& labels ) {
  auto t = std::unique_ptr<O3Type>( new O3Type( pos, name, super, labels ) );
  get_prm()->types().push_back( std::move( t ) ); 
}

void __addO3IntType( Position& pos,
                     const O3Label& name,
                     const O3Integer& start,
                     const O3Integer& end ) {
  auto t = std::unique_ptr<O3IntType>( new O3IntType( pos, name, start, end ) );
  get_prm()->int_types().push_back( std::move( t ) );
}

void __addO3Interface( Position& pos,
                       const O3Label& name,
                       const O3Label& super,
                       const O3InterfaceElementList& elts ) {
  auto i =
      std::unique_ptr<O3Interface>( new O3Interface( pos, name, super, elts ) );
  get_prm()->interfaces().push_back( std::move( i ) );
}

void __addO3Class( Position& pos,
                   O3Label& name,
                   O3Label& super,
                   O3LabelList& interfaces,
                   O3AttributeList& elts ) {
  auto c = std::unique_ptr<O3Class>(
      new O3Class( pos, name, super, interfaces, elts ) );
  get_prm()->classes().push_back( std::move( c ) );
}

public:
// Set the parser factory.
void set_prm(O3PRM* prm) {
  __prm = prm;
}

O3PRM* get_prm() {
  return __prm;
}

//##############################################################################
//
//                              SCANNER RULES
//
//##############################################################################

//________________________

    Parser( Scanner* scanner );
    ~Parser();
    void SemErr( const wchar_t* msg );
    void SynErr( const std::wstring& filename,int line, int col, int n );
    void Warning( const wchar_t* msg );
    const ErrorsContainer& errors() const;

    	void NEWO3PRM();
	void UNIT();
	void TYPE_UNIT();
	void INTERFACE_UNIT();
	void CLASS_UNIT();
	void CLASS_DECLARATION(Position& pos,
O3Label& name,
O3Label& super,
O3LabelList& interfaces,
O3AttributeList& elts);
	void CLASS(Position& pos);
	void LABEL(O3Label& l);
	void LABEL_LIST(O3LabelList& list);
	void CLASS_BODY(O3AttributeList& elts);
	void FLOAT_LIST(O3FloatList& values);
	void FLOAT(O3Float& f);
	void INTERFACE_DECLARATION(Position& pos,
O3Label& name,
O3Label& super,
O3InterfaceElementList& elts);
	void INTERFACE(Position& pos);
	void INTERFACE_BODY(O3InterfaceElementList& elts);
	void TYPE_DECLARATION(Position& pos, O3Label& name, O3Label& super, LabelMap& labels);
	void INT_TYPE_DECLARATION(Position& pos, O3Label& name, O3Integer& start, O3Integer& end);
	void TYPE(Position& pos);
	void TYPE_VALUE_LIST(LabelMap& labels );
	void MAP(LabelMap& labels );
	void INT(Position& pos);
	void INTEGER(O3Integer& i);

    void Parse();

}; // end Parser

} // namespace
} // namespace
} // namespace


#endif // !defined(COCO_PARSER_H__)

