/***************************************************************************
 *  aGrUM modified frames and atg files for cocoR
 *   Copyright (c) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr
***************************************************************************/
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(gum_COCO_PARSER_H__)
#define gum_COCO_PARSER_H__

#include <algorithm>
#include <cmath>
#include <fstream>
#include <list>
#include <sstream>
#include <stack>
#include <string>
#include <vector>

#include <agrum/core/utils_dir.h>

#include <iostream>
#include <string>
#include <fstream>
#include "Scanner.h"

namespace gum {



class Parser {
  private:
    	enum {
		_EOF=0,
		_integer=1,
		_float=2,
		_operator=3,
		_word=4,
		_eol=5
	};
	int maxT;

    Token* dummyToken;
    int errDist;
    int minErrDist;

    void SynErr( int n );
    void Get();
    void Expect( int n );
    bool StartOf( int s );
    void ExpectWeak( int n, int follow );
    bool WeakSeparator( int n, int syFol, int repFol );

    ErrorsContainer  __errors;

  public:
    Scanner* scanner;

    Token* t;     // last recognized token
    Token* la;      // lookahead token

    private:
  enum token_type { NUMBER, OPERATOR, PARENTHESIS };

  struct EvalToken {
    token_type type;
    double number;
    char character;

    EvalToken(token_type t, double n): type(t), number(n), character('\0') { };
    EvalToken(token_type t, char c): type(t), number(NAN), character(c) { };

    EvalToken(const EvalToken & source): type(source.type), number(source.number), character(source.character) { };
    EvalToken& operator= (const EvalToken & source) {
      type = source.type;
      number = source.number;
      character = source.character;
      return *this;
    }

    std::string str() const {
      std::ostringstream s;
      switch (type) {
        case token_type::NUMBER: {
                                   s << number; 
                                   break;
                                 }
        case token_type::PARENTHESIS:
        case token_type::OPERATOR: {
                                     s << character;
                                     break;
                                   }

        default: { GUM_ERROR(OperationNotAllowed, "unknown type"); }
      }
      return s.str();
    }

    bool isLeftAssociative() const {
      switch (character) {
        case '+':
        case '-':
        case '*':
        case '/': {
          return true;
        }

        case '^': {
          return false;
        }

        default : {
          GUM_ERROR( OperationNotAllowed, "A - not an operator");
        }
      }
    }

    bool isRightAssociative() const {
      return not isLeftAssociative();
    }

    int precedence() const {
      switch (character) {
        case '+':
        case '-': {
          return 2;
        }

        case '*':
        case '/': {
          return 3;
        }

        case '^': {
          return 4;
        }

        default : {
          GUM_ERROR( OperationNotAllowed, "B - not an operator");
        }
      }
    }

    size_t argc() const {
      switch (character) {
        case '-': {
          return (size_t) 1;
        }
        case '+':
        case '*':
        case '/': 
        case '^': {
          return (size_t) 2;
        }

        default : {
          GUM_ERROR( OperationNotAllowed, "C - not an operator");
        }
      }
    }

    /// Args are backwards !
    double __eval(const std::vector<EvalToken>& args) const {
      switch (character) {
        case '+': {
                    return args[1].number + args[0].number;
                  }

        case '-': {
                    return args[1].number - args[0].number;
                  }

        case '*': {
                    return args[1].number * args[0].number;
                  }

        case '/': {
                    return args[1].number / args[0].number;
                  }

        case '^': {
                    return std::pow(args[1].number, args[0].number);
                  }

        default : {
                    GUM_ERROR( OperationNotAllowed, "D - not an operator");
                  }
      }
    }

    /// Args are backwards !
    EvalToken eval(const std::vector<EvalToken>& args) const {
      return EvalToken(token_type::NUMBER, __eval(args));
    }

  };

  double __result;

  std::vector<EvalToken> __output;
  std::stack<EvalToken> __stack;

  void __number(const double &v) {
    std::cout << "number(" << v << ")" << std::endl;
    __output.push_back(EvalToken(token_type::NUMBER, v));
  }

  bool __popOperator(EvalToken o) {
    if (__stack.empty() or __stack.top().type != token_type::OPERATOR) {
      return false;
    }

    if (o.isLeftAssociative() and o.precedence() <= __stack.top().precedence() ) {
      return true;
    }

    if (o.isRightAssociative() and o.precedence() < __stack.top().precedence() ) {
      return true;
    }
    
    return false;
  }

  void __operator(char o) {
    std::cout << "operator(" << o << ")" << std::endl;
    EvalToken t(token_type::OPERATOR, o);

    while ( __popOperator(t) ) {
      __output.push_back(__stack.top());
      __stack.pop();
    }

    __stack.push(t);
  }

  void __leftParenthesis() {
    std::cout << "parenthesis( '(' )" << std::endl;
    EvalToken t(token_type::PARENTHESIS, '(');
    __stack.push(t);
  }

  void __rightParenthesis() {

    while ( (not __stack.empty()) and ( __stack.top().character != '(' ) ) {

      __output.push_back( __stack.top() );
      __stack.pop();

    }

    if (__stack.empty()) {

      GUM_ERROR(OperationNotAllowed, "expecting '('");

    } else if (__stack.top().character != '(') {

      GUM_ERROR(OperationNotAllowed, "expecting '('");

    }

    __stack.pop();

  }

  void __finished() {

    while (not __stack.empty()) {
      if (__stack.top().character == '(') {

        GUM_ERROR(OperationNotAllowed, "expecting ')'");

      }

      __output.push_back( __stack.top() );
      __stack.pop();

    }

  }

  void __reduceOperator(EvalToken item, std::stack<EvalToken> &stack) const {

    std::vector<EvalToken> args;

    if (stack.size() < item.argc()) {
      GUM_ERROR(OperationNotAllowed, "not enought inputs for " + item.character);
    }

    // We need to handle the minus vs negative case
    if (item.character == '-') {

      args.push_back(stack.top());
      stack.pop();

      if (not stack.empty()) {
        if (stack.top().type == token_type::NUMBER) {
          args.push_back(stack.top());
          stack.pop();
        }
      }

      // It is a negative sign 
      if (args.size() == 1) {
        args.push_back(EvalToken(token_type::NUMBER, 0.0));
      }

    } else  {

      while (item.argc() > args.size()) {

        args.push_back(stack.top());
        stack.pop();

      }
    }

    stack.push(item.eval(args));
  }

  public:
    double result() const {
      std::stack<EvalToken> stack;
      if (__output.empty()) {
        GUM_ERROR(OperationNotAllowed, "no output found");
      }

      
      std::cout << "input: " << std::endl;
      for ( auto item: __output ) {
        std::cout << item.str() << " ";
      }
      std::cout << std::endl;

      for ( auto item: __output ) {


        switch (item.type) {
          case token_type::NUMBER: {
                                     stack.push(item);
                                     break;
                                   }

          case token_type::OPERATOR: {
                                       __reduceOperator(item, stack);
                                       break;
                                     }

          default: {
                     GUM_ERROR(OperationNotAllowed, "expecting numbers, operators or functions");
                   }
        }

      }

      if (stack.size() != 1) {

        GUM_ERROR(OperationNotAllowed, "too many inputs");

      } else if (stack.top().type != token_type::NUMBER) {

        GUM_ERROR(OperationNotAllowed, "too many inputs");
      }
      return stack.top().number;
    }

//##############################################################################
//
//                              SCANNER RULES
//
//##############################################################################

//________________________

    Parser( Scanner* scanner );
    ~Parser();
    void SemErr( const wchar_t* msg );
    void SynErr( const std::wstring& filename,int line, int col, int n );
    void Warning( const wchar_t* msg );
    const ErrorsContainer& errors() const;

    	void EVAL();
	void expression();

    void Parse();

}; // end Parser

} // namespace


#endif // !defined(COCO_PARSER_H__)

