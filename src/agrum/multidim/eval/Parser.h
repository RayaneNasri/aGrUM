/***************************************************************************
 *  aGrUM modified frames and atg files for cocoR
 *   Copyright (c) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr
***************************************************************************/
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(gum_COCO_PARSER_H__)
#define gum_COCO_PARSER_H__

#include <algorithm>
#include <cmath>
#include <fstream>
#include <list>
#include <sstream>
#include <stack>
#include <string>
#include <vector>

#include <agrum/core/utils_dir.h>
#include <agrum/multidim/eval/formula.h>

#include <iostream>
#include <string>
#include <fstream>
#include "Scanner.h"

namespace gum {



class Parser {
  private:
    	enum {
		_EOF=0,
		_integer=1,
		_float=2,
		_operator=3,
		_word=4,
		_eol=5,
		_exp=6,
		_log=7,
		_ln=8,
		_pow=9,
		_sqrt=10,
		_bernoulli=11,
		_binomial=12,
		_geometric=13,
		_negative_binomial=14,
		_poisson=15,
		_exponential=16,
		_gamma=17,
		_weibull=18,
		_extreme_value=19,
		_normal=20,
		_lognormal=21,
		_chi_squared=22,
		_cauchy=23,
		_fisher_f=24,
		_student_t=25,
		_discrete=26,
		_piecewise_constant=27,
		_piecewise_linear=28
	};
	int maxT;

    Token* dummyToken;
    int errDist;
    int minErrDist;

    void SynErr( int n );
    void Get();
    void Expect( int n );
    bool StartOf( int s );
    void ExpectWeak( int n, int follow );
    bool WeakSeparator( int n, int syFol, int repFol );

    ErrorsContainer  __errors;

  public:
    Scanner* scanner;

    Token* t;     // last recognized token
    Token* la;      // lookahead token

    private:
  Formula __formula;

public:
  Formula& formula() { return __formula; }
  const Formula& formula() const { return __formula; }

//##############################################################################
//
//                              SCANNER RULES
//
//##############################################################################

//________________________

    Parser( Scanner* scanner );
    ~Parser();
    void SemErr( const wchar_t* msg );
    void SynErr( const std::wstring& filename,int line, int col, int n );
    void Warning( const wchar_t* msg );
    const ErrorsContainer& errors() const;

    	void EVAL();
	void expression();

    void Parse();

}; // end Parser

} // namespace


#endif // !defined(COCO_PARSER_H__)

