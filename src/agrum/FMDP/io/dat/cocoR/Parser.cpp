/***************************************************************************
 *  aGrUM modified frames and atg files for cocoR
 *   Copyright (c) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr   
***************************************************************************/
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#include <iostream>
#include <wchar.h>

#include "Parser.h"
#include "Scanner.h"


namespace gum {
namespace MDPDAT {


void Parser::SynErr(int n) {
	if (errDist >= minErrDist) SynErr(scanner->filename(),la->line, la->col, n);
	errDist = 0;
}


const ErrorsContainer& Parser::errors(void) const {
	return __errors;
}

void Parser::Get() {
	for (;;) {
		t = la;
		la = scanner->Scan();
		if (la->kind <= maxT) { ++errDist; break; }

		if (dummyToken != t) {
			dummyToken->kind = t->kind;
			dummyToken->pos = t->pos;
			dummyToken->col = t->col;
			dummyToken->line = t->line;
			dummyToken->next = NULL;
			coco_string_delete(dummyToken->val);
			dummyToken->val = coco_string_create(t->val);
			t = dummyToken;
		}
		la = t;
	}
}

void Parser::Expect(int n) {
	if (la->kind==n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::MDPDAT() {
		VARIABLES_DECLARATION();
		while (la->kind == 9) {
			ACTION();
		}
		REWARD_DECISION_DIAGRAM();
		DISCOUNT();
		TOLERANCE();
}

void Parser::VARIABLES_DECLARATION() {
		Expect(6);
		Expect(7);
		while (la->kind == 6) {
			VARIABLE();
		}
		Expect(8);
}

void Parser::ACTION() {
		std::string name_of_action; 
		Expect(9);
		__factory->startActionDeclaration(); 
		if (la->kind == 1) {
			IDENT(name_of_action);
		} else if (la->kind == 4) {
			STRING(name_of_action);
		} else SynErr(16);
		TRY( __factory->addAction( name_of_action ) ); 
		while (la->kind == 1) {
			TRANSITION_DECISION_DIAGRAM();
		}
		if (la->kind == 11) {
			COST_DECISION_DIAGRAM();
		}
		Expect(10);
		TRY( __factory->endActionDeclaration() ); 
}

void Parser::REWARD_DECISION_DIAGRAM() {
		std::string name_of_var;
		__factory->startRewardDeclaration(); 
		Expect(12);
		if (IsFollowedByIdent() ) {
			Expect(6);
			SUB_DECISION_DIAGRAM();
			Expect(8);
		} else if (la->kind == 6) {
			Get();
			LEAF();
			Expect(8);
		} else SynErr(17);
		TRY( __factory->addReward( ) );
		__factory->endRewardDeclaration();
		__parentModality.clear();
		__parentNode.clear(); 
}

void Parser::DISCOUNT() {
		float value;
		__factory->startDiscountDeclaration( ); 
		Expect(13);
		FLOAT(value);
		__factory->addDiscount( value );
		__factory->endDiscountDeclaration( ); 
}

void Parser::TOLERANCE() {
		float value; 
		Expect(14);
		FLOAT(value);
}

void Parser::VARIABLE() {
		std::string name_of_var; 
		Expect(6);
		__factory->startVariableDeclaration(); 
		IDENT(name_of_var);
		TRY( __factory->variableName( name_of_var ) ); 
		MODALITY_LIST();
		Expect(8);
		TRY( __factory->endVariableDeclaration() ); 
}

void Parser::IDENT(std::string& name) {
		Expect(1);
		name=narrow(t->val);  
}

void Parser::MODALITY_LIST() {
		std::string label; 
		IDENT_OR_INTEGER(label);
		TRY( __factory->addModality( label ) ); 
		if (la->kind == 1 || la->kind == 2) {
			MODALITY_LIST();
		}
}

void Parser::IDENT_OR_INTEGER(std::string& name) {
		if (la->kind == 1) {
			IDENT(name);
		} else if (la->kind == 2) {
			Get();
			name=narrow(t->val);  
		} else SynErr(18);
}

void Parser::STRING(std::string& str) {
		Expect(4);
		str=narrow(t->val); 
}

void Parser::TRANSITION_DECISION_DIAGRAM() {
		std::string name_of_var;
		__factory->startTransitionDeclaration(); 
		IDENT(name_of_var);
		std::string prime_name_of_var = name_of_var + "'";
		__currentDecisionDiagramVar = prime_name_of_var; 
		if (IsFollowedByIdent() ) {
			Expect(6);
			SUB_TRANSITION_DECISION_DIAGRAM();
			Expect(8);
		} else if (la->kind == 6) {
			Get();
			TRANSITION_LEAF();
			Expect(8);
		} else SynErr(19);
		TRY( __factory->addTransition( name_of_var ) );
		__factory->endTransitionDeclaration();
		__parentModality.clear();
		__parentNode.clear(); 
}

void Parser::COST_DECISION_DIAGRAM() {
		std::string name_of_var;
		__factory->startCostDeclaration(); 
		Expect(11);
		Expect(6);
		SUB_DECISION_DIAGRAM();
		Expect(8);
		TRY( __factory->addCost( ) );
		__factory->endCostDeclaration();
		__parentModality.clear();
		__parentNode.clear(); 
}

void Parser::SUB_TRANSITION_DECISION_DIAGRAM() {
		std::string name_of_var;
		std::string modality_of_var;
		NodeId var_id; 
		IDENT(name_of_var);
		var_id = __factory->addNonTerminalNode( name_of_var );
		if( !__parentNode.empty() )
		__factory->insertArc( __parentNode.back(), var_id, __parentModality.back() ); 
		while (la->kind == 6) {
			Get();
			IDENT_OR_INTEGER(modality_of_var);
			__parentNode.push_back( var_id );
			__parentModality.push_back( (* (__factory->variable( name_of_var )))[modality_of_var] ); 
			if (IsFollowedByIdent() ) {
				Expect(6);
				SUB_TRANSITION_DECISION_DIAGRAM();
				Expect(8);
			} else if (la->kind == 6) {
				Get();
				TRANSITION_LEAF();
				Expect(8);
			} else SynErr(20);
			__parentModality.pop_back(); 
			Expect(8);
		}
		__parentNode.pop_back(); 
}

void Parser::TRANSITION_LEAF() {
		float value;
		gum::Idx i = 0;
		NodeId var_id = __factory->addNonTerminalNode( __currentDecisionDiagramVar );
		if( !__parentNode.empty() )
		__factory->insertArc( __parentNode.back(), var_id, __parentModality.back() ); 
		FLOAT(value);
		NodeId val_id = __factory->addTerminalNode( value );
		__factory->insertArc( var_id, val_id, i ); 
		while (la->kind == 2 || la->kind == 3) {
			FLOAT(value);
			++i;
			val_id = __factory->addTerminalNode( value );
			__factory->insertArc( var_id, val_id, i ); 
		}
}

void Parser::FLOAT(float& val) {
		if (la->kind == 3) {
			Get();
			val=coco_atof(t->val); 
		} else if (la->kind == 2) {
			Get();
			val=coco_atoi(t->val); 
		} else SynErr(21);
}

void Parser::SUB_DECISION_DIAGRAM() {
		std::string name_of_var;
		std::string modality_of_var;
		NodeId var_id;
		IDENT(name_of_var);
		var_id = __factory->addNonTerminalNode( name_of_var );
		if( !__parentNode.empty() )
		__factory->insertArc( __parentNode.back(), var_id, __parentModality.back() ); 
		while (la->kind == 6) {
			Get();
			IDENT_OR_INTEGER(modality_of_var);
			__parentNode.push_back( var_id );
			__parentModality.push_back( (* (__factory->variable( name_of_var )))[modality_of_var] );  
			if (IsFollowedByIdent() ) {
				Expect(6);
				SUB_DECISION_DIAGRAM();
				Expect(8);
			} else if (la->kind == 6) {
				Get();
				LEAF();
				Expect(8);
			} else SynErr(22);
			__parentModality.pop_back(); 
			Expect(8);
		}
		__parentNode.pop_back(); 
}

void Parser::LEAF() {
		float value; 
		FLOAT(value);
		NodeId val_id = __factory->addTerminalNode( value );
		__factory->insertArc( __parentNode.back(), val_id, __parentModality.back() ); 
		while (la->kind == 2 || la->kind == 3) {
			FLOAT(value);
			NodeId val_id = __factory->addTerminalNode( value );
			__factory->insertArc( __parentNode.back(), val_id, __parentModality.back() ); 
		}
}



// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};
void Parser::Parse() {
	t = NULL;
	la = dummyToken = new Token();
	la->val = coco_string_create(L"Dummy Token");
	Get();
	MDPDAT();
	Expect(0);
}

Parser::Parser(Scanner *scanner) {
	maxT = 15;

	ParserInitCaller<Parser>::CallInit(this);
	dummyToken = NULL;
	t = la = NULL;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[1][17] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
	delete dummyToken;
}
void Parser::SemErr(const wchar_t* msg) {
	if (errDist >= minErrDist) __errors.Error(scanner->filename(),t->line, t->col, msg);
	errDist = 0;
}

void Parser::Warning(const wchar_t* msg) {
	__errors.Warning(scanner->filename(),t->line, t->col, msg);
}

void Parser::SynErr(const std::wstring& filename,int line, int col, int n) {
	wchar_t* s;
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"ident expected"); break;
			case 2: s = coco_string_create(L"integer expected"); break;
			case 3: s = coco_string_create(L"number expected"); break;
			case 4: s = coco_string_create(L"string expected"); break;
			case 5: s = coco_string_create(L"largestring expected"); break;
			case 6: s = coco_string_create(L"lpar expected"); break;
			case 7: s = coco_string_create(L"\"variables\" expected"); break;
			case 8: s = coco_string_create(L"\")\" expected"); break;
			case 9: s = coco_string_create(L"\"action\" expected"); break;
			case 10: s = coco_string_create(L"\"endaction\" expected"); break;
			case 11: s = coco_string_create(L"\"cost\" expected"); break;
			case 12: s = coco_string_create(L"\"reward\" expected"); break;
			case 13: s = coco_string_create(L"\"discount\" expected"); break;
			case 14: s = coco_string_create(L"\"tolerance\" expected"); break;
			case 15: s = coco_string_create(L"??? expected"); break;
			case 16: s = coco_string_create(L"invalid ACTION"); break;
			case 17: s = coco_string_create(L"invalid REWARD_DECISION_DIAGRAM"); break;
			case 18: s = coco_string_create(L"invalid IDENT_OR_INTEGER"); break;
			case 19: s = coco_string_create(L"invalid TRANSITION_DECISION_DIAGRAM"); break;
			case 20: s = coco_string_create(L"invalid SUB_TRANSITION_DECISION_DIAGRAM"); break;
			case 21: s = coco_string_create(L"invalid FLOAT"); break;
			case 22: s = coco_string_create(L"invalid SUB_DECISION_DIAGRAM"); break;

		default:
		{
			wchar_t format[20];
			coco_swprintf(format, 20, L"error %d", n);
			s = coco_string_create(format);
		}
		break;
	}
	//wprintf(L"-- line %d col %d: %ls\n", line, col, s);
	std::wstring ss=L"Syntax error : "+std::wstring(s);
  __errors.Error(filename,line,col,ss.c_str());
	coco_string_delete(s);
}

} // namespace
} // namespace


