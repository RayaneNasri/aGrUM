%option prefix="GUM_BIF_"
%option nounput

%{
#include <iostream>
#include <vector>

#include <agrum/core/hashTable.h>
#include "parseBIF.hpp"

#define YY_DECL int GUM_BIF_lex (YYSTYPE* GUM_BIF_lval)

int  GUM_BIF_property_caller;
extern unsigned int GUM_BIF_words_size;
extern gum::HashTable<unsigned int,std::string> *GUM_BIF_words;

#define string_yylval() GUM_BIF_lval->Int = GUM_BIF_words_size; \
        GUM_BIF_words->insert (GUM_BIF_words_size,GUM_BIF_text); \
        ++GUM_BIF_words_size;
#define int_yylval()    sscanf(GUM_BIF_text, "%d", &GUM_BIF_lval->Int)
#define float_yylval()  sscanf(GUM_BIF_text, "%f", &GUM_BIF_lval->Float)

extern int line_no;

void GUM_BIF_reset_lexer(void) {
  BEGIN(0);
  YY_FLUSH_BUFFER;
}
%}


DIGIT    [0-9]
LETTER   [a-zA-Z_.?-]
WORD     {LETTER}({LETTER}|{DIGIT})*
MODALITY [a-zA-Z0-9_-]+
NET_NAME [a-zA-Z0-9._-]+
INTEGER  [1-9][0-9]*
COMMENT  ("//"[^\n]*|"/*"([^*]*|("*"[^/])*)*"*/")
EXPONENT [eE]([+,-])?([0-9])+
FLOAT    (([0-9])+"."([0-9])*{EXPONENT}?|"."([0-9])+{EXPONENT}?|([0-9])+{EXPONENT})
EQUAL    [[:blank:]]*=[[:blank:]]*
PROP_VAL [^ =;\n]([^;\n])*

NETWORK         "network"
VARIABLE        "variable"
PROBABILITY     "probability"
PROPERTY        "property"
TYPE            "type"
DISCRETE        "discrete"
DEFAULTVALUE    "default"
TABLE           "table"

%x IN_PROPERTY
%x IN_BEG_PROPERTY
%x IN_DISCRETE
%x IN_BEG_DISCRETE
%x IN_PROBA
%x IN_BEG_PROBA
%x IN_COND_PROBA
%x IN_BEG_NETWORK
%x IN_NETWORK

%%

<*>{COMMENT}   /* remove comments */
{VARIABLE}     { return TOK_VARIABLE; }
{TYPE}         { return TOK_TYPE; }

"{" { return TOK_BEG_CURLY; }
"}" { return TOK_END_CURLY; }
"(" { return TOK_BEG_PARENTHESIS; }
")" { return TOK_END_PARENTHESIS; }

<*>{PROPERTY}              { GUM_BIF_property_caller=YYSTATE; BEGIN (IN_BEG_PROPERTY); return TOK_PROPERTY; }
<IN_BEG_PROPERTY>{WORD}    { BEGIN (IN_PROPERTY); string_yylval(); return TOK_WORD;}
<IN_PROPERTY>{EQUAL}       /* remove superfluous characters */
<IN_PROPERTY>{PROP_VAL}    { string_yylval(); return TOK_PROPERTY_VALUE; }
<IN_PROPERTY>[;\n]         { BEGIN (GUM_BIF_property_caller); }

{NETWORK}                  { BEGIN(IN_BEG_NETWORK); return TOK_NETWORK; }
<IN_BEG_NETWORK>{NET_NAME} { string_yylval(); return TOK_NET_NAME; }
<IN_BEG_NETWORK>"{"        { BEGIN (IN_NETWORK); return TOK_BEG_CURLY; }
<IN_NETWORK>"}"            { BEGIN (INITIAL); return TOK_END_CURLY; }

<INITIAL>{DISCRETE}        { BEGIN (IN_BEG_DISCRETE); return TOK_DISCRETE; }
<IN_BEG_DISCRETE>{INTEGER} { int_yylval(); return TOK_INTEGER; }
<IN_BEG_DISCRETE>"["       { return TOK_BEG_BRACKET; }
<IN_BEG_DISCRETE>"]"       { return TOK_END_BRACKET; }
<IN_BEG_DISCRETE>"{"       { BEGIN (IN_DISCRETE); return TOK_BEG_CURLY; }
<IN_DISCRETE>{MODALITY}    { string_yylval(); return TOK_MODALITY; }
<IN_DISCRETE>"}"           { BEGIN (INITIAL); return TOK_END_CURLY; }

<INITIAL>{PROBABILITY}     { BEGIN (IN_BEG_PROBA); return TOK_PROBABILITY; }
<IN_BEG_PROBA>"("          { return TOK_BEG_PARENTHESIS; }
<IN_BEG_PROBA>")"          { return TOK_END_PARENTHESIS; }
<IN_BEG_PROBA>{WORD}       { string_yylval(); return TOK_WORD; }
<IN_BEG_PROBA>{INTEGER}    { int_yylval(); return TOK_INTEGER; }
<IN_BEG_PROBA>"{"          { BEGIN (IN_PROBA); return TOK_BEG_CURLY; }
<IN_PROBA>"("              { BEGIN (IN_COND_PROBA); return TOK_BEG_PARENTHESIS; }
<IN_COND_PROBA>{MODALITY}  { string_yylval(); return TOK_MODALITY; }
<IN_COND_PROBA>")"         { BEGIN (IN_PROBA); return TOK_END_PARENTHESIS; }
<IN_PROBA>{DEFAULTVALUE}   { return TOK_DEFAULT; }
<IN_PROBA>{TABLE}          { return TOK_TABLE; }
<IN_PROBA>{FLOAT}          { float_yylval(); return TOK_FLOAT; }
<IN_PROBA>{DIGIT}          { int_yylval(); return TOK_INTEGER; }
<IN_PROBA>{INTEGER}        { int_yylval(); return TOK_INTEGER; }
<IN_PROBA>"}"              { BEGIN (INITIAL); return TOK_END_CURLY; }

{FLOAT}    { float_yylval();  return TOK_FLOAT; }
{INTEGER}  { int_yylval();    return TOK_INTEGER; }
{WORD}     { string_yylval(); return TOK_WORD; }
{MODALITY} { string_yylval(); return TOK_MODALITY; }

<*>"\n" {line_no++;}
<*>.    /* remove superfluous characters */

%%

int GUM_BIF_wrap () {
   BEGIN(INITIAL);
   YY_FLUSH_BUFFER;
   return 1;
}

