#define UAI_TRACE(x) std::cout<<"** "<<x<<std::endl
#define UAI_WARN(x)  
//std::cout<<"                  "<<x<<std::endl
#include <iostream>

#include <agrum/core/cast_unicode.h>

#include <agrum/BN/IBayesNet.h>
#include <agrum/BN/IBayesNetFactory.h>

#undef TRY
#define  TRY(inst) try { inst; } catch (gum::Exception& e) { SemErr(e.errorType());}

COMPILER UAI

gum::IBayesNetFactory* __factory;

void setFactory(gum::IBayesNetFactory* f) {
  __factory=f;
}

gum::IBayesNetFactory& factory(void) {
  if (__factory) return *__factory;
  GUM_ERROR(gum::OperationNotAllowed,"Please set a factory for scanning UAI file...");
}

void SemErr(std::string s) {
  SemErr(widen(s).c_str());
}

void Warning(std::string s) {
  Warning(widen("Warning : "+s).c_str());
}

void __checkSizeOfProbabilityAssignation(const std::vector<float>&v,const std::string& var, int res) {
  if ((int) v.size()<res)
    Warning("Not enough data in probability assignation for node "+var);
  if ((int) v.size()>res)
    Warning("Too many data in probability assignation for node "+var);
}

//=====================
CHARACTERS
  digit  = '0'..'9'.

//=====================
TOKENS
  eol    = '\n'.
  integer = digit { digit }.              /* integer part */
  number = (
            [ "+" | "-" ] digit { digit }"." digit { digit }              /* digits after the mandatory point */
            [ ( "E" | "e" ) [ "+" | "-" ] digit { digit } ]                 /* optional exponent part */
           |
            [ "+" | "-" ] digit { digit }                 /* integer part */
            ( "E" | "e" ) [ "+" | "-" ] digit { digit }   /* mandatory exponent part */
            )
.


//=====================
//COMMENTS FROM "#" TO '\n'

IGNORE '\t'+'\r'

//=====================
PRODUCTIONS

EOLS = eol { eol}.

INT<int& val> = integer (. UAI_WARN("INT "<<coco_string_create_char(t->val));val=coco_atoi(t->val); .).

FLOAT<float& val> =
  number  (. UAI_WARN("FLOAT "<<coco_string_create_char(t->val));val=coco_atof(t->val); .)
  |
  integer (. UAI_WARN("FLOAT "<<coco_string_create_char(t->val));val=coco_atoi(t->val); .)
.


UNIQUE_INT<int & v> = (. int val; .)
    INT<val> (. UAI_WARN("Unique "<<val);v=val; .)
    EOLS
.

LISTE_FLOAT<. std::vector<float>& v .> =   (. float value; .)
  FLOAT<value>                             (. UAI_WARN("pushing X "<<value);v.push_back(value); .)
  FLOAT<value>                             (. UAI_WARN("pushing Y "<<value);v.push_back(value); .)
  {
  FLOAT<value>                            (. UAI_WARN("pushing Z "<<value);v.push_back(value); .)
  }
  EOLS
  .
  

LISTE_INT<. std::vector<int>& v .> =   (. int v1,v2,v3; .)
  INT<v1>                            (. UAI_WARN("pushing A "<<v1);v.push_back(v1); .)
  INT<v2>                            (. UAI_WARN("pushing B "<<v2);v.push_back(v2); .)
  {
  INT<v3>                            (. UAI_WARN("pushing C "<<v3);v.push_back(v3); .)
  }
  EOLS
.


LISTE_PARENTS = (. std::vector<int> v; .) 
  LISTE_INT<v> (. UAI_TRACE("parents :"<<v);v.clear(); .)
  {
  LISTE_INT<v> (. UAI_TRACE("parents :"<<v);v.clear(); .)
  }
.

//==============
UAI =
    EOLS
    "BAYES" "\n" (. UAI_TRACE("BAYES found"); .)
    EOLS
    PREAMBULE
    CPTS
.

PREAMBULE = (. int val; std::vector<int> v;std::vector<int > vv; .)
    UNIQUE_INT<val> (. UAI_TRACE("nbr de var :"<<val); .)
    LISTE_INT<v> (. UAI_TRACE("domains :"<<v); .)
    UNIQUE_INT<val> (. UAI_TRACE("nbr de pot :"<<val); .)
    LISTE_PARENTS
.

CPTS =
    CPT
    {CPT}
.

CPT = (. int val;std::vector<float> vv; .)
    UNIQUE_INT<val> (. UAI_TRACE("nbr de params "<<val);vv.clear(); .)
    LISTE_FLOAT<vv> 
    { 
      LISTE_FLOAT<vv> 
    }                   (. UAI_TRACE("probas :"<<vv); .)
.


END UAI.

