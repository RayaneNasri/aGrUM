
#include <agrum/core/cast_unicode.h>

#include <agrum/BN/BayesNet.h>
#include <agrum/BN/BayesNetFactory.h>

#define  TRY(inst) try { inst; } catch (gum::Exception& e) { SemErr(e.getType());}
COMPILER DSL


gum::AbstractBayesNetFactory* __factory;

void setFactory(gum::AbstractBayesNetFactory* f) {
  __factory=f;
}

gum::AbstractBayesNetFactory& factory(void) {
  if (__factory) return *__factory;
  GUM_ERROR(gum::OperationNotAllowed,"Please set a factory for scanning DSL file...");
}

void SemErr(std::string s) {
  SemErr(widen(s).c_str());
}

void Warning(std::string s) {
  Warning(widen("Warning : "+s).c_str());
}

void __checkSizeOfProbabilityAssignation(const std::vector<float>&v,const std::string& var, int res) {
  if ((int) v.size()<res)
    Warning("Not enough data in probability assignation for node "+var);
  if ((int) v.size()>res)
    Warning("Too many data in probability assignation for node "+var);
}



//=====================
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'+ '_' + '='.
  odd_letter = letter - 'e' - 'E'.
  nextletter = letter + '.' + '?' + '-'+'%'.
  digit  = '0'..'9'.

  eol = '\n'.
  inString   = ANY - '"'. /* set of all easy characters within a string */
  nocomma = ANY - ';'.

//=====================
TOKENS
  ident  =   ( letter {nextletter | digit} )
            |
            ( digit {digit} odd_letter {nextletter | digit} ).

  integer = [ "+" | "-" ] digit { digit }.              /* integer part */

  number = (
            [ "+" | "-" ] digit { digit }"." digit { digit }              /* digits after the mandatory point */
            [ ( "E" | "e" ) [ "+" | "-" ] digit { digit } ]                 /* optional exponent part */
           |
            [ "+" | "-" ] digit { digit }                 /* integer part */
            ( "E" | "e" ) [ "+" | "-" ] digit { digit }   /* mandatory exponent part */
            )
.

  string = '"' {inString } '"'.

  largestring = '=' {nocomma} ';'.

//=====================
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\r' + eol + '\t' + '='

//=====================
PRODUCTIONS

//==============
DSL = NETWORK { NODE } '}' ';'.

//==============
NETWORK = 	(.
           	 	std::string name_of_network;
           	 	factory().startNetworkDeclaration();
          	.)
  "net" (IDENT<name_of_network> | STRING<name_of_network>) 
  			(. 	factory().addNetworkProperty("name", name_of_network); .)
  '{'
			(. 	factory().endNetworkDeclaration(); .)
.

//==============
NODE =	(.
			std::string var;
			std::vector<std::string> parents;
			int nbrMod = 0;
		.)
	
	"node" IDENT<var>
	HEADER
					
	PARENTS<parents>
					
	VARIABLE_DEFINITION<nbrMod, var>
					
	
	(. 
		gum::Size i;
		TRY(factory().startParentsDeclaration(var));
		
		for(i = 0; i < parents.size(); i++){
		   	TRY(factory().variableId(parents[i]));
		   	TRY(factory().addParent(parents[i]));
		}
	
		TRY(factory().endParentsDeclaration());
	.)
	
	PROBA<var, parents>
	
				(.
					int nbr=0;
					TRY(nbr=factory().varInBN(factory().variableId(var)).domainSize());
					if (nbrMod<nbr) SemErr("Too much modalities for variable "+var);
					if (nbrMod>nbr) SemErr("Too many modalities for variable "+var);
				.)
	
.

//==============
HEADER = (. std::string content; .)
	'{'
	"TYPE" ident ';'
	
	"HEADER" '{'
		"ID" ident ';'
		"NAME" string ';'
	'}' ';'
.

//==============
PARENTS<. std::vector<std::string>& parents .> =
	"PARENTS" '('
	[ PARENTS_LIST<parents> ]
	')' ';'
.

//==============
PARENTS_LIST<. std::vector<std::string>& parents .> =
	(.std::string parent; .)
	
	IDENT<parent> 		(.	parents.push_back(parent);	.)
		
	[ WEAK ',' PARENTS_LIST<parents> ]
.

//==============
VARIABLE_DEFINITION< int& nbrMod, std::string& var > =
	"DEFINITION" '{'
		"NAMESTATES" '('
									(. 
										TRY(factory().startVariableDeclaration());
										TRY(factory().variableName(var));
									.)

	MODALITY_LIST<nbrMod>
	
		')' ';'
									(. 	TRY(factory().endVariableDeclaration()); .)								
.

//==============
MODALITY_LIST<int& nbrMod> = 
								(. std::string label; .)	
	IDENT_OR_INTEGER<label>
  							 	(. 
									if ((label=="") && (nbrMod == 0)) SemErr("Not enough modalities for a discrete variable");
  									TRY(factory().addModality(label)); 
  									nbrMod++;
  								.)
	[ "," MODALITY_LIST<nbrMod> ]
.


//==============
PROBA<. const std::string& var, const std::vector<std::string>& parents .> =

	"PROBABILITIES"
	
	'('
	
	RAW_PROBA<var, parents>
	
	')' ';'
	
	'}' ';'
	'}' ';'

.

//==============
RAW_PROBA<. const std::string& var, const std::vector<std::string>& parents .> =
	(. 
		std::vector<float> v;
		std::vector<float> prob;
		gum::Size i,j, k;
		gum::Size res, max, nbLabels;
	.)

	FLOAT_LIST<v>
                            
	(. 
		res = factory().varInBN(factory().variableId(var)).domainSize();
		
		for(i = 0; i < parents.size(); i++){
			res = res*(factory().varInBN(factory().variableId(parents[i])).domainSize());
		}
		

		nbLabels = factory().varInBN(factory().variableId(var)).domainSize();
		max = res / nbLabels;
		
		j = 0;
		k = 0;
		for(i = 0; i < res; i++){
			if(i%max == 0){
				prob.push_back(v[k]);
				k++; j=1;
			}
			else{
				prob.push_back(v[j*nbLabels + k-1]);
				j++;
			}
		}
		
		
		TRY(factory().startRawProbabilityDeclaration(var));
        gum::Size s=(gum::Size)0;
        TRY(s=factory().cptDomainSize(factory().variableId(var)));
        if ((int)prob.size()<(int)s) Warning("Not enough data for cpt of node "+var);
        if ((int)prob.size()>(int)s) Warning("Too many data for cpt of node "+var);
        TRY(factory().rawConditionalTable(prob));
        TRY(factory().endRawProbabilityDeclaration());

	.)
	
.

//==============
// no "," for proba values
FLOAT_LIST<. std::vector<float>& v .> =   	(. float value; .)
	FLOAT<value>  							(. v.push_back(value); .)
	[ [ (',' | '|' )] FLOAT_LIST<v>]
.


//==============
STRING<std::string& str> = string	(. str=narrow(t->val); .).

//==============
IDENT<std::string& name> = ident	(. name=narrow(t->val); .).

//==============
IDENT_OR_INTEGER<std::string& name> =
  IDENT<name>
  |
  integer    (. name=narrow(t->val);.)
.

//==============
FLOAT<float& val> =
  number  (. swscanf(t->val, L"%f", &val); .)
  |
  integer (. swscanf(t->val, L"%f", &val); .)
.



END DSL.
