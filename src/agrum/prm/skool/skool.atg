#include <string>
#include <sstream>

#include <agrum/prm/PRMFactory.h>

#define  TRY(inst) try { inst; } catch (gum::Exception& e) { SemErr(e.getType());}
COMPILER Skool;

gum::prm::PRMFactory* __factory;

void setFactory(gum::prm::PRMFactory* f) {
  __factory = f;
}

gum::prm::PRMFactory& factory() {
  if (__factory) {
    return *__factory;
  }
  GUM_ERROR(gum::OperationNotAllowed,"Please set a factory for scanning BIF file...");
}

bool isPath() {
  return (la->kind == _word) and (scanner->Peek()->kind == _dot);
}

bool isBaseType() {
  Token* n1 = scanner->Peek();
  Token* n2 = scanner->Peek();
  return (la->kind == _type) and (n1->kind == _word) and (n2->kind != _extends);
}

bool isBaseClass() {
  Token* n1 = scanner->Peek();
  Token* n2 = scanner->Peek();
  return (la->kind == _class) and (n1->kind == _word) and (n2->kind != _extends);
}

bool isBaseInterface() {
  Token* n1 = scanner->Peek();
  Token* n2 = scanner->Peek();
  return (la->kind == _interface) and (n1->kind == _word) and (n2->kind != _extends);
}

bool isClassOrInterface(std::string type) {
  std::string dot = ".";
  return factory().prm()->isClass(type) or factory().prm()->isClass(factory().currentPackage() + dot + type) or
         factory().prm()->isInterface(type) or factory().prm()->isInterface(factory().currentPackage() + dot + type) ;
}

//=====================
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'+ '_' .
  digit  = '0'..'9'.
  eol    = '\n'.

//=====================
TOKENS
  integer   = ['+'|'-'] digit {digit}.
  float     = ['+'|'-'] digit {digit} '.' digit {digit} [ ('E'|'e') ['+'|'-'] digit {digit} ].
  word      = letter {(letter | digit)}.
  eol       = '\n'.
  dot       = '.'.
  comma     = ','.
  colon     = ':'.
  semicolon = ';'.
  type      = "type".
  class     = "class".
  interface = "interface".
  extends   = "extends".
  system    = "system".

//=====================
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\r' + eol + '\t'

//=====================
PRODUCTIONS

//=====================
Skool = {Header} { Unit }.

//=====================
Header  = (Package | Import).

Package = "package"         (. std::string name; .)
          Ident<name> ';'   (. factory().setPackage(name); .).

Import  = "import"          (. std::string name; .)
          Ident<name> ';'   (. std::cerr << "Import disabled."; .).

//=====================
Unit = Type|  Interface| Class | System.

//=====================
Type =   IF(isBaseType())
         BaseType
       | SuperType
       .

//=====================
BaseType =                      (. std::string l; .)
           "type" word          (. factory().startDiscreteType(narrow(t->val)); .)
           Label<l> ','         (. factory().addLabel(l); .)
           Label<l>             (. factory().addLabel(l); .)
           {
             ',' Label<l>       (. factory().addLabel(l); .)
           }
           ';'                  (. factory().endDiscreteType(); .)
           .

//=====================
SuperType   = "type" word                   (. std::string s, l, name, super; name = narrow(t->val); .)
              "extends" Ident<super>        (. factory().startDiscreteType(name, super); .)
              Label<l> ':' Label<s> ','     (. factory().addLabel(l, s); .)
              Label<l> ':' Label<s>         (. factory().addLabel(l, s); .)
              {
                ',' Label<l> ':' Label<s>   (. factory().addLabel(l, s); .)
              }
              ';'                           (. factory().endDiscreteType(); .)
              .

//=====================

Interface = "interface" word              (. std::string name, extends; name = narrow(t->val); .)
            [ "extends" Ident<extends> ]  (. factory().startInterface(name, extends); .)
            InterfaceBody                 (. factory().endInterface(); .)
            .

InterfaceBody = '{' { InterfaceStatement } '}'.

InterfaceStatement =                      (. std::string type, name; .)
                      Ident<type> word    (. name = narrow(t->val); .)
                      RefOrAttr<type, name>
                      .

RefOrAttr<std::string& type, std::string& name> =   IF(isClassOrInterface(type))
                                                    Reference<type, name>
                                                  | ';' (. factory().startAttribute(type, name); factory().endAttribute(); .)
                                                  .

//=====================
Class = "class" word                      (. std::string name, super; name = narrow(t->val); .)
        [ "extends" Ident<super> ]        (. gum::Set<std::string> set; .)
        [ "implements" IdentSet<set> ]    (. factory().startClass(name, super, (set.empty()?0:&set)); .)
        ClassBody                         (. factory().endClass(); .)
        .

//=====================
ClassBody = '{' { ClassStatement } '}'.

ClassStatement =                                                     (. std::string name, type; .)
                  Ident<type> word                                   (. name = narrow(t->val); .)
                  (
                      RefOrParam<type, name>
                    | Attribute<type, name>
                    | Aggregate<type, name>
                  )
                  .

//=====================
RefOrParam<std::string type, std::string name> =    IF(isClassOrInterface(type))
                                                    Reference<type, name>
                                                 |  Parameter<type, name>
                                                 .

Reference<std::string type, std::string name> =   ';'           (. factory().addReferenceSlot(type, name, false); .)
                                                | '[' ']' ';'   (. factory().addReferenceSlot(type, name, true); .)
                                                .

Parameter<std::string type, std::string name> =   ';'                    (. factory().addParameter(type, name); .)
                                                |                        (. std::string l; .) 
                                                  "default" Label<l> ';' (. factory().addParameter(type, name, l); .)
                                                .

//=====================
Attribute<std::string type, std::string name> =                           (. factory().startAttribute(type, name); .)
                                                [Dependecies] '{'
                                                (                         (. std::vector<float> cpt; .)
                                                   '[' FloatList<cpt> ']' (. factory().setRawCPFByColumns(cpt); .)
                                                 | FactorizedCPT
                                                ) '}' ';'                 (. factory().endAttribute(); .)
                                                .

Dependecies =                               (. std::vector<std::string> prnts; .)
              "dependson" IdentList<prnts>  (. for (size_t i = 0; i < prnts.size(); ++i) factory().addParent(prnts[i]); .)
              .

FactorizedCPT = CPTRule {CPTRule}.

CPTRule = (. std::vector<std::string> labels; std::vector<float> values; .)
          LabelList<labels> ':' FloatList<values> ';'
          (. factory().setCPFByRule(labels, values); .)
          .

Aggregate<std::string type, std::string name> =                                         (. std::string func; std::vector<std::string> chains, params; .)
                                                '=' Function<func, chains, params> ';'  (. factory().addAggregator(name, func, chains, params); .)
                                                .

Function<. std::string& name,
           std::vector<std::string>& chains,
           std::vector<std::string>& params .> = word                                                   (. name = narrow(t->val); .)
                                                 '(' ( '[' IdentList<chains> ']' ',' LabelList<params>
                                                            |                                           (. std::vector<std::string> vec; .)
                                                              IdentList<vec>                            (. chains.push_back(vec.front());
                                                                                                           for (size_t idx = 1; idx < vec.size(); ++idx) params.push_back(vec[idx]); .)
                                                     ) ')' .


//=====================
LabelList<. std::vector<std::string>& list .> = ( word                  (. list.push_back(narrow(t->val)); .)
                                                  | '*'                 (. list.push_back(narrow(t->val)); .)
                                                ) [ ',' LabelList<list> ]
                                                .

IdentSet<. gum::Set<std::string>& set .> =                          (. std::string ident; .)
                                             Ident<ident>           (. set.insert(ident); .)
                                             [',' IdentSet<set> ]
                                             .

IdentList<. std::vector<std::string>& set .> =                    (. std::string ident; .)
                                                SlotChain<ident>
                                                                  (. set.push_back(ident); .)
                                                [',' IdentList<set> ]
                                                .
FloatList<. std::vector<float>& list .> =                          (. float f; .)
                                          Number<f>                (. list.push_back(f); .)
                                          [ ',' FloatList<list> ]
                                          .


Ident<std::string& s> = word        (. s = narrow(t->val); .)
                        { '.' word  (. s += '.'; s += narrow(t->val); .) }
                        .

SlotChain<std::string& s> = [ '<'           (. s += '<'; std::string val; .)
                              Ident<val>    (. s += val; .)
                              '>'           (. s += narrow(t->val); .)
                            ] word          (. s += narrow(t->val); .)
                            {
                              '.'             (. s += '.'; .)
                              [ '<'           (. s += '<'; std::string val; .)
                                Ident<val>    (. s += val; .)
                                '>'           (. s += narrow(t->val); .)
                              ] word          (. s += narrow(t->val); .)
                            }
                            .

Label<std::string& s> =   word        (. s = narrow(t->val); .)
                        |             (. float val; .)
                          Number<val> (. std::stringstream sBuff; sBuff << val; s = sBuff.str(); .)
                        .

Number<float& val> =    integer (. swscanf(t->val, L"%f", &val); .)
                      | float   (. swscanf(t->val, L"%f", &val); .)
                      .

// ====================================
System = system word            (. factory().startSystem(narrow(t->val)); .)
         '{' { SystemDecl } '}' (. factory().endSystem(); .)
         .

SystemDecl =  (. std::string left, last; std::string dot = "."; .)
              SysLeftValue<left, last>
              (. std::string tmp = left; tmp += (last.size())?dot + last:""; .)
              ( SysInstDecl<tmp> | SysArray<tmp> | SysAffect<left, last> )
              .

SysInstDecl<std::string type> = word (. factory().addInstance(type, narrow(t->val)); .) ';'.

SysArray<std::string array> =
  (. int size = 0; .)
  '[' integer (. swscanf(t->val, L"%d", &size); .) ']'
  (
    word (. factory().addArray(array, narrow(t->val), size); .) ';'
  | '.' word (. std::string ref = narrow(t->val); std::stringstream sBuff; sBuff << '[' << size << ']'; std::string inst = array + sBuff.str(); .)
    SysAffect<inst, ref>
  )
  .

SysAffect<std::string inst, std::string ref> =
    (. bool ref_inc = false; .)
    [ '+' (. ref_inc = true; .)] '=' word 
    (.
       gum::prm::System& sys = factory().getCurrentSystem();
       if (sys.isInstance(inst) or sys.isArray(inst)) {
         gum::prm::Class& c = (sys.isInstance(inst))?sys.get(inst).type():sys.getArray(inst).front()->type();
         if (c.get(ref).elt_type() == ClassElement::prm_refslot) {
           factory().setReferenceSlot(inst, ref, narrow(t->val));
         } else if (c.get(ref).elt_type() == ClassElement::prm_attribute) {
           factory().setParameter(inst, ref, narrow(t->val));
         } else {
           GUM_ERROR(NotFound, "unfound class element");
         }
       } else {
         GUM_ERROR(NotFound, "unknown instance");
       }
     .)
    ';'
    .

SysLeftValue<std::string& left, std::string& last> =
  word (. left = narrow(t->val); .)
  { '.' word (. if (last != "") {left += '.'; left += last;} last = narrow(t->val); .) }
  .

END Skool.
