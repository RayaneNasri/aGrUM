#include <string>
#include <sstream>
#include <algorithm>
#include <fstream>

namespace std {
  #include<dirent.h>
}

#include <agrum/prm/PRMFactory.h>

#undef TRY
#define  TRY(inst) try { inst; } catch (gum::Exception& e) { SemErr(e.getContent());}
COMPILER Skool;

gum::prm::PRMFactory* __factory;
std::vector<std::string> __class_path;
gum::Set<std::string> __imports;
std::string __file_name;

void SemErr(std::string s) {
  SemErr(widen(s).c_str());
}

void setFactory(gum::prm::PRMFactory* f) {
  __factory = f;
}

void setClassPath(const std::vector<std::string>& class_path) {
  __class_path = class_path;
}

void setImports(const gum::Set<std::string>& imports) {
  __imports = imports;
}

const gum::Set<std::string>& getImports() const {
  return __imports;
}

void addImports(const gum::Set<std::string>& imports) {
  for (gum::Set<std::string>::iterator iter = imports.begin(); iter != imports.end(); ++iter) {
    if (not __imports.exists(*iter)) {
      __imports.insert(*iter);
    }
  }
}

void setFileName(const std::string& file) {
  __file_name = file;
}

void import(std::string s) {
  if (not __imports.exists(s)) {
    __imports.insert(s);
    std::string sep = "/";
    std::string ext = ".skool";
    std::string import;
    std::ifstream file_test;
    std::replace(s.begin(), s.end(), '.', '/');
    bool found = false;
    for (std::vector<std::string>::iterator iter = __class_path.begin(); iter != __class_path.end(); ++iter) {
      import = (*iter) + sep + s + ext;
      file_test.open(import.c_str());
      if (file_test.is_open()) {
        file_test.close();
        found = true;
        Scanner s(import);
        Parser p(&s);
        p.setFactory(__factory);
        p.setClassPath(__class_path);
        p.setImports(__imports);
        p.setFileName(import);
        p.Parse();
        addImports(p.getImports());
        break;
      }
    }
    if (not found) {
      GUM_ERROR(gum::NotFound, "import not found");
    }
  }
}

gum::prm::PRMFactory& factory() {
  if (__factory) {
    return *__factory;
  }
  GUM_ERROR(OperationNotAllowed,"Please set a factory for scanning BIF file...");
}

bool isClass(std::string type) {
  std::string dot = ".";
  return factory().prm()->isClass(type) or factory().prm()->isClass(factory().currentPackage() + dot + type);
}

bool isClassOrInterface(std::string type) {
  std::string dot = ".";
  return factory().prm()->isClass(type) or factory().prm()->isClass(factory().currentPackage() + dot + type) or
         factory().prm()->isInterface(type) or factory().prm()->isInterface(factory().currentPackage() + dot + type) ;
}

void setRefOrParam(std::string s, std::string r) {
  size_t dot = s.find_first_of('.');
  if (dot != std::string::npos) {
    std::string instance = s.substr(0, dot);
    std::string member = s.substr(dot+1);
    gum::prm::System& sys = static_cast<gum::prm::System&>(*(factory().getCurrent()));
    gum::prm::ClassElementContainer* c = 0;
    if (sys.isInstance(instance)) {
      c = &(sys.get(instance).type());
    } else if (sys.isArray(instance)) {
      c = &(sys.getArrayType(instance));
    } else {
      GUM_ERROR(gum::NotFound, "unknown instance in system");
    }
    if (not c->exists(member)) {
      GUM_ERROR(gum::NotFound, "unknown member in instance");
    }
    if (c->obj_type() == gum::prm::PRMObject::prm_interface) {
      factory().setReferenceSlot(instance, member, r);
    } else {
      switch (c->get(member).elt_type()) {
        case gum::prm::ClassElement::prm_refslot:
          {
            factory().setReferenceSlot(instance, member, r);
            break;
          }
        case gum::prm::ClassElement::prm_attribute:
          {
            if (static_cast<gum::prm::Class*>(c)->isParameter(c->get(member))) {
              factory().setParameter(instance, member, r);
              break;
            } // If it is not a parameter goto to the default case
          }
        default: {
                   GUM_ERROR(WrongClassElement, "wrong ClassElement for this operation");
                 }
      }
    }
  } else {
    GUM_ERROR(gum::SyntaxError, "invalid right value");
  }
}

void setReferenceSlot(std::string s, std::string r) {
  size_t dot = s.find_first_of('.');
  if (dot != std::string::npos) {
    std::string instance = s.substr(0, dot);
    std::string member = s.substr(dot+1);
    gum::prm::System& sys = static_cast<gum::prm::System&>(*(factory().getCurrent()));
    gum::prm::ClassElementContainer* c = 0;
    if (sys.isInstance(instance)) {
      c = &(sys.get(instance).type());
    } else if (sys.isArray(instance)) {
      c = &(sys.getArrayType(instance));
    } else {
      GUM_ERROR(NotFound, "unknown instance in system");
    }
    if (not c->exists(member)) {
      GUM_ERROR(NotFound, "unknown member in instance");
    }
    factory().setReferenceSlot(instance, member, r);
  } else {
    GUM_ERROR(gum::SyntaxError, "invalid right value");
  }
}

//=====================
CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'+ '_' .
  digit  = '0'..'9'.
  eol    = '\n'.

//=====================
TOKENS
  integer    = ['+'|'-'] digit {digit}.
  float      = ['+'|'-'] digit {digit} '.' digit {digit} [ ('E'|'e') ['+'|'-'] digit {digit} ].
  word       = letter {(letter | digit)}.
  eol        = '\n'.
  dot        = '.'.
  comma      = ','.
  colon      = ':'.
  semicolon  = ';'.
  type       = "type".
  class      = "class".
  interface  = "interface".
  extends    = "extends".
  system     = "system".
  dependson  = "dependson".
  default    = "default".
  implements = "implements".
  LEFT_CAST  = "(".
  RIGHT_CAST = ")".

//=====================
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\r' + eol + '\t'

//=====================
PRODUCTIONS

//=====================
Skool = [Package] {Import} {Unit} (. factory().popPackage(); .) .

//=====================
Package = "package"         (. std::string name; .)
          Ident<name> ';'   (. factory().pushPackage(name); .).

Import  = "import"          (. std::string name; .)
          Ident<name> ';'   (. TRY(import(name)) .).

//=====================
Unit = Type | Interface | Class | System.

//=====================
Type = type word                                (. std::string name, extends, l, s; name = narrow(t->val); .)
       [ extends Ident<extends> ]               (. TRY(factory().startDiscreteType(name, extends)) .)
       Label<l> [ ':' Label<s> ]                (. TRY(factory().addLabel(l, s)) .)
       {                                        (. s = ""; .)
         ',' Label<l> [ ':' Label<s> ]          (. TRY(factory().addLabel(l, s)) .)
       }
       ';'                                      (. TRY(factory().endDiscreteType()) .)
       .

//=====================
Interface = interface word                                    (. std::string interface, extends; interface = narrow(t->val); .)
            [ extends Ident<extends> ]                        (. TRY(factory().startInterface(interface, extends)) .)
            '{'
            {                                                 (. std::string type, name; .)
              Ident<type> (
                            '[' ']' word                      (. name = narrow(t->val); bool array = true; .)
                            Reference<type, name, array>
                           | word                             (. name = narrow(t->val); bool array = false; .)
                             (
                              IF(isClassOrInterface(type))
                                Reference<type, name, array>
                              | ';'                           (. TRY(factory().addAttribute(type, name)) .)
                             )
                          )
            }
            '}'                                               (. TRY(factory().endInterface()) .)
            .

//=====================
Class = class word                                            (. std::string c, super; c = narrow(t->val); .)
        [ extends Ident<super> ]                              (. gum::Set<std::string> set; .)
        [                                                     (. std::string i; .)
          implements Ident<i>                                 (. set.insert(i); .)
          {
            ',' Ident<i>                                      (. set.insert(i); .)
          }
        ]                                                     (. TRY(factory().startClass(c, super, (set.empty()?0:&set))) .)
        '{'
        {                                                     (. std::string type, name; bool array = false; .)
          Ident<type> ( '[' ']' word                          (. name = narrow(t->val); array = true; .)
                         Reference<type, name, array>
                       | word                                 (. name = narrow(t->val); array = false; .)
                         (
                            RefOrParam<type, name, array>
                          | Attribute<type, name>
                          | Aggregate<type, name>
                          | Functions<type, name>
                         )
                      )
        }
        '}'                               (. TRY(factory().endClass()) .)
        .

//=====================
RefOrParam<std::string type, std::string name, bool array> =    IF(isClassOrInterface(type))
                                                                     Reference<type, name, array>
                                                                  |  Parameter<type, name>
                                                                  .

Reference<std::string type, std::string name, bool array> =  ';' (. TRY(factory().addReferenceSlot(type, name, array)) .) .

Parameter<std::string type, std::string name> =                         (. std::string l; .)
                                                [ default Label<l> ]
                                                ';'                     (. TRY(factory().addParameter(type, name, l)) .)
                                                .

//=====================
Attribute<std::string type, std::string name> =                           (. TRY(factory().startAttribute(type, name)) .)
                                                [                         (. std::string p; .)
                                                  dependson CastIdent<p>  (. TRY(factory().addParent(p)) .)
                                                  {
                                                    ',' CastIdent<p>      (. TRY(factory().addParent(p)) .)
                                                  }
                                                ]
                                                '{'
                                                (
                                                   '['                    (. std::vector<float> cpt; float f; .)
                                                      Number<f>           (. cpt.push_back(f); .)
                                                      {
                                                        ',' Number<f>     (. cpt.push_back(f); .)
                                                      }
                                                   ']'                    (. TRY(factory().setRawCPFByColumns(cpt)) .)
                                                 |
                                                   CPTRule { CPTRule }
                                                )
                                                '}'
                                                ';'                       (. TRY(factory().endAttribute()) .)
                                                .

CPTRule =                                             (. std::vector<std::string> labels; std::vector<float> values; .)
                                                      (. std::string s; float f; .)
          CPTRuleValue<s>                             (. labels.push_back(s); .)
          {
            ',' CPTRuleValue<s>                       (. labels.push_back(s); .)
          }
          ':'
          Number<f>                                   (. values.push_back(f); .)
          {
            ',' Number<f>                             (. values.push_back(f); .)
          }
          ';'                                         (. TRY(factory().setCPFByRule(labels, values)) .)
          .

CPTRuleValue<. std::string& s .> =    word   (. s = narrow(t->val); .)
                                   |  '*'    (. s = "*"; .)
                                   .

Aggregate<std::string type, std::string name> =                                                 (. std::string func, s; std::vector<std::string> chains, labels; .)
                                                '=' word                                        (. func = narrow(t->val); .)
                                                '(' AggChains<chains> ',' AggLabels<labels> ')'
                                                ';'                                             (. TRY(factory().addAggregator(name, func, chains, labels)) .)
                                                .

AggChains<. std::vector<std::string>& chains .> =                       (. std::string s; .)
                                                    CastIdent<s>        (. chains.push_back(s); .)
                                                  | '['                 (. std::string s; .)
                                                    CastIdent<s>        (. chains.push_back(s); .)
                                                    {
                                                      ',' CastIdent<s>  (. chains.push_back(s); .)
                                                    }
                                                    ']'
                                                  .

AggLabels<. std::vector<std::string>& labels .> =   word            (. labels.push_back(narrow(t->val)); .)
                                                  | '['
                                                    word            (. labels.push_back(narrow(t->val)); .)
                                                    {
                                                      ',' word      (. labels.push_back(narrow(t->val)); .)
                                                    }
                                                    ']'
                                                  .

Functions<std::string type, std::string name> =                   (. if (type != "boolean") {TRY(throw gum::OperationNotAllowed("noisy-or attributes must be booleans"))} .)
                                                '~' "noisyOr" '(' (. std::vector<std::string> chains, labels; std::vector<float> numbers; float leak = 0.0; .)
                                                AggChains<chains> ',' NumberList<numbers> [ ',' Number<leak> [ ',' AggLabels<labels> ] ]
                                                ')' ';'           (. TRY(factory().addNoisyOrCompound(name, chains, numbers, leak, labels)) .)
                                                .

NumberList<. std::vector<float>& numbers .> =                 (. float f; .)
                                              Number<f>       (. numbers.push_back(f); .)
                                            | '['             (. float f; .)
                                              Number<f>       (. numbers.push_back(f); .)
                                              {
                                                ',' Number<f> (. numbers.push_back(f); .)
                                              }
                                              ']'
                                            .

//=====================
System = system word                  (. TRY(factory().startSystem(narrow(t->val))) .)
         '{'
         {                                            (. std::string l1, r1; .)
           Ident<l1> (   ArrayDecl<l1>
                       | word                         (. TRY(factory().addInstance(l1, narrow(t->val))) .)
                       | "+=" Ident<r1>               (. if (static_cast<gum::prm::System*>(factory().getCurrent())->isArray(l1))
                                                         { TRY(factory().incArray(l1, r1)) }
                                                         else
                                                         { TRY(factory().setReferenceSlot(l1, r1)) } .)
                       | '='  Ident<r1>               (. TRY( try {factory().setReferenceSlot(l1, r1);}
                                                              catch (gum::Exception& e) {
                                                                size_t pos = l1.find_last_of('.');
                                                                if (pos != std::string::npos) {
                                                                  std::string i = l1.substr(0, pos);
                                                                  std::string p = l1.substr(pos+1, std::string::npos);
                                                                  factory().setParameter(i, p, r1);
                                                                }
                                                              }) .)
           ) ';'
         }
         '}' (. TRY(factory().endSystem()) .)
         .

ArrayDecl<std::string l1> = (. std::string r1; std::stringstream sBuff; sBuff << l1; int size = 0; .)
                            '[' [ integer (. sBuff << '[' << narrow(t->val) << ']'; swscanf(t->val, L"%d", &size); .) ] ']'
                            (   word                (. TRY(factory().addArray(l1, narrow(t->val), size)) .)
                              | '.' word            (. std::string l2 = narrow(t->val); .)
                                (   "+=" Ident<r1>  (. TRY(factory().setReferenceSlot(sBuff.str(), l2, r1)) .)
                                  | '='  Ident<r1>  (. TRY(try { factory().setReferenceSlot(sBuff.str(), l2, r1); }
                                                       catch (gum::Exception& e) {factory().setParameter(sBuff.str(), l2, r1);}) .) )
                            )
                            .

//=====================
Ident<std::string& s> =             (. std::stringstream sBuff; .)
                        word        (. sBuff << narrow(t->val); .)
                        {
                          '.' word  (. sBuff << "." << narrow(t->val); .)
                        }           (. s = sBuff.str(); .)
                        .

CastIdent<std::string& s> = (. std::string cast, open(gum::prm::ClassElement::LEFT_CAST()), close(gum::prm::ClassElement::RIGHT_CAST()); std::stringstream sBuff; .)
                            [
                              LEFT_CAST Ident<cast> RIGHT_CAST            (. sBuff << open << cast << close; .)
                            ] word                                        (. sBuff << narrow(t->val); .)
                            {                                             (. cast = ""; .)
                              '.'                                         (. sBuff << '.'; .)
                              [
                                LEFT_CAST Ident<cast> RIGHT_CAST          (. sBuff << open << cast << close; .)
                              ] word                                      (. sBuff << narrow(t->val); .)
                            }                                             (. s = sBuff.str(); .)
                            .


Label<std::string& s> =   word        (. s = narrow(t->val); .)
                        |             (. float val; .)
                          Number<val> (. std::stringstream sBuff; sBuff << val; s = sBuff.str(); .)
                        .

Number<float& val> =    integer (. swscanf(t->val, L"%f", &val); .)
                      | float   (. swscanf(t->val, L"%f", &val); .)
                      .


END Skool.
