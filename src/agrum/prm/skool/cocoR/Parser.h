/***************************************************************************
 *  aGrUM modified frames and atg files for cocoR
 *   Copyright (c) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr   
***************************************************************************/
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(COCO_PARSER_H__)
#define COCO_PARSER_H__

#include <string>
#include <sstream>
#include <algorithm>
#include <fstream>

namespace std {
  #include<dirent.h>
}

#include <agrum/prm/PRMFactory.h>

#undef TRY
// Redefine try / catch to add a semantic error when errors are raised.
#define  TRY(inst) try { inst; } catch (gum::Exception& e) { SemErr(e.getContent()); }
#define  TRY2(inst,msg) try { inst; } catch (gum::Exception& e) { SemErr(msg+" ("+e.getContent()+")."); }
#define  TRY3(inst,msg,error) try { if (!error) {inst;} } catch (gum::Exception& e) { SemErr(msg+" ("+e.getContent()+")."); error=true; }

#include <iostream>
#include <string>
#include <fstream>
#include "Scanner.h"

namespace gum {
namespace prm {
namespace skool {



class Parser {
private:
	enum {
		_EOF=0,
		_integer=1,
		_float=2,
		_word=3,
		_eol=4,
		_dot=5,
		_comma=6,
		_colon=7,
		_semicolon=8,
		_type=9,
		_class=10,
		_interface=11,
		_extends=12,
		_system=13,
		_dependson=14,
		_default=15,
		_implements=16,
		_noisyOr=17,
		_LEFT_CAST=18,
		_RIGHT_CAST=19
	};
	int maxT;

	Token *dummyToken;
	int errDist;
	int minErrDist;

	void SynErr(int n);
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
	
	ErrorsContainer  __errors;

public:
	Scanner *scanner;

	Token *t;			// last recognized token
	Token *la;			// lookahead token

private:
    gum::prm::PRMFactory*       __factory;
    std::vector<std::string>    __class_path;
    gum::Set<std::string>       __imports;

    // Convert string to wstring.
    void SemErr(std::string s) {
      SemErr(widen(s).c_str());
    }

    // Return true if type is a class or an interface.
    bool isClassOrInterface(std::string type) {
      std::string dot = ".";
      return factory().prm()->isClass(type) or factory().prm()->isClass(factory().currentPackage() + dot + type) or
             factory().prm()->isInterface(type) or factory().prm()->isInterface(factory().currentPackage() + dot + type) ;
    }
    
    void import( std::string fileID ) {
        // If fileID has not yet been imported.
        if ( ! __imports.exists(fileID) ) {
            // We add it to file imported (even if import desn't succeed).
            __imports.insert(fileID);
                
            std::string realFilename;
            std::ifstream file_test;
            bool fileFound = false;

            std::replace(fileID.begin(), fileID.end(), '.', '/');

            // Search filename in each path stored in __class_path
            for (std::vector<std::string>::iterator path = __class_path.begin(); path != __class_path.end(); ++path) {
                // Construct complete filePath
                realFilename = (*path) + "/" + fileID + ".skool";

                // We try to open it
                file_test.open(realFilename.c_str());
                if (file_test.is_open()) {
                    file_test.close();
                    fileFound = true;
                                        
                    // If we have already import this file, skip it.
                    if ( __imports.exists( realFilename ) )
                        break;
                    
                    // Remember we have found it.
                    __imports.insert(realFilename);

                    // We parse it
                    Scanner s(realFilename.c_str());
                    Parser p(&s);
                    p.setFactory(__factory);
                    p.setClassPath(__class_path);
                    p.setImports(__imports);
                    p.Parse();

                    // We add file imported in p to file imported here.
                    gum::Set<std::string> parserImports = p.getImports();
                    for (gum::Set<std::string>::iterator iter = parserImports.begin(); iter != parserImports.end(); ++iter)
                        if (not __imports.exists(*iter))
                        __imports.insert(*iter);

                    // We add warnings and errors to this
                    __errors += p.__errors;

                    // Stop to search
                    break;
                }
            }

            // If import filename has not been found, add an error.
            if (not fileFound) SemErr("import not found");
        }
    }

    // Set files already import in factory.
    void setImports(const gum::Set<std::string>& imports) {
      __imports = imports;
    }

    // Get files imports.
    const gum::Set<std::string>& getImports() const {
      return __imports;
    }

    // Add these import to this parser.
    void addImports(const gum::Set<std::string>& imports) {
      for (gum::Set<std::string>::iterator iter = imports.begin(); iter != imports.end(); ++iter) {
        if (not __imports.exists(*iter)) {
          __imports.insert(*iter);
        }
      }
    }
    
public:
    // Set the parser factory.
    void setFactory(gum::prm::PRMFactory* f) {
      __factory = f;
    }

    // Retrieve the factory.
    gum::prm::PRMFactory& factory() {
      if (__factory) {
        return *__factory;
      }
      GUM_ERROR(OperationNotAllowed,"Please set a factory for scanning BIF file...");
    }

    // Set the paths to search for imports.
    void setClassPath(const std::vector<std::string>& class_path) {
      __class_path = class_path;
    }
    

//##############################################################################
//
//                              SCANNER RULES
//
//##############################################################################

//=====================

	Parser(Scanner *scanner);
	~Parser();
	void SemErr(const wchar_t* msg);
  void SynErr(const std::wstring& filename,int line, int col, int n);
	void Warning(const wchar_t* msg);
	const ErrorsContainer& errors() const;

	void Skool();
	void Package();
	void Import();
	void Unit();
	void Ident(std::string& s);
	void Type();
	void Interface();
	void Class();
	void System();
	void Label(std::string& s);
	void Reference(std::string type, std::string name, bool array);
	void RefOrParam(std::string type, std::string name, bool array);
	void Attribute(std::string type, std::string name);
	void Aggregate(std::string type, std::string name);
	void Functions(std::string type, std::string name);
	void Parameter(std::string type, std::string name);
	void CastIdent(std::string& s);
	void Number(float& val);
	void CPTRule(bool &error);
	void CPTRuleValue(std::string& s );
	void AggChains(std::vector<std::string>& chains );
	void AggLabels(std::vector<std::string>& labels );
	void NumberList(std::vector<float>& numbers );
	void ArrayDecl(std::string l1);

	void Parse();

}; // end Parser

} // namespace
} // namespace
} // namespace


#endif // !defined(COCO_PARSER_H__)

