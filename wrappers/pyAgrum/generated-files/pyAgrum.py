# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
pyAgrum is a Python wrapper for the C++ aGrUM library. It provides a high-level
interface to the part of agrum allowing to create, handle and make computations
into Bayesian Networks. The module is a straightforward application of the SWIG
interface generator. Custom-written code was added to make the interface similar
to OpenBayes, a free Bayesian Network library for Python.
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyAgrum', [dirname(__file__)])
        except ImportError:
            import _pyAgrum
            return _pyAgrum
        if fp is not None:
            try:
                _mod = imp.load_module('_pyAgrum', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyAgrum = swig_import_helper()
    del swig_import_helper
else:
    import _pyAgrum
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import numpy

class PythonBNListener(_object):
    """Proxy of C++ PythonBNListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonBNListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonBNListener, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(PythonBNListener self, DiGraph g, VariableNodeMap vnm) -> PythonBNListener"""
        this = _pyAgrum.new_PythonBNListener(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonBNListener
    __del__ = lambda self : None;
    def whenNodeAdded(self, *args):
        """whenNodeAdded(PythonBNListener self, void const * source, gum::NodeId id)"""
        return _pyAgrum.PythonBNListener_whenNodeAdded(self, *args)

    def whenNodeDeleted(self, *args):
        """whenNodeDeleted(PythonBNListener self, void const * arg2, gum::NodeId id)"""
        return _pyAgrum.PythonBNListener_whenNodeDeleted(self, *args)

    def whenArcAdded(self, *args):
        """whenArcAdded(PythonBNListener self, void const * arg2, gum::NodeId src, gum::NodeId dst)"""
        return _pyAgrum.PythonBNListener_whenArcAdded(self, *args)

    def whenArcDeleted(self, *args):
        """whenArcDeleted(PythonBNListener self, void const * arg2, gum::NodeId src, gum::NodeId dst)"""
        return _pyAgrum.PythonBNListener_whenArcDeleted(self, *args)

    def setWhenArcAdded(self, *args):
        """setWhenArcAdded(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcAdded(self, *args)

    def setWhenArcDeleted(self, *args):
        """setWhenArcDeleted(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcDeleted(self, *args)

    def setWhenNodeAdded(self, *args):
        """setWhenNodeAdded(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeAdded(self, *args)

    def setWhenNodeDeleted(self, *args):
        """setWhenNodeDeleted(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeDeleted(self, *args)

PythonBNListener_swigregister = _pyAgrum.PythonBNListener_swigregister
PythonBNListener_swigregister(PythonBNListener)

class PythonLoadListener(_object):
    """Proxy of C++ PythonLoadListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonLoadListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonLoadListener, name)
    __repr__ = _swig_repr
    def whenLoading(self, *args):
        """whenLoading(PythonLoadListener self, void const * buffer, int percent)"""
        return _pyAgrum.PythonLoadListener_whenLoading(self, *args)

    def setPythonListener(self, *args):
        """setPythonListener(PythonLoadListener self, PyObject * l) -> bool"""
        return _pyAgrum.PythonLoadListener_setPythonListener(self, *args)

    def __init__(self): 
        """__init__(PythonLoadListener self) -> PythonLoadListener"""
        this = _pyAgrum.new_PythonLoadListener()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonLoadListener
    __del__ = lambda self : None;
PythonLoadListener_swigregister = _pyAgrum.PythonLoadListener_swigregister
PythonLoadListener_swigregister(PythonLoadListener)


def __fillLoadListeners(*args):
  """
    __fillLoadListeners(std::vector< PythonLoadListener,std::allocator< PythonLoadListener > > & py_listener, 
        PyObject * l) -> int
    """
  return _pyAgrum.__fillLoadListeners(*args)
class PythonApproximationListener(_object):
    """Proxy of C++ PythonApproximationListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonApproximationListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonApproximationListener, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(PythonApproximationListener self, ApproximationScheme algo) -> PythonApproximationListener"""
        this = _pyAgrum.new_PythonApproximationListener(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonApproximationListener
    __del__ = lambda self : None;
    def whenProgress(self, *args):
        """whenProgress(PythonApproximationListener self, void const * src, gum::Size step, double error, double duration)"""
        return _pyAgrum.PythonApproximationListener_whenProgress(self, *args)

    def whenStop(self, *args):
        """whenStop(PythonApproximationListener self, void const * src, std::string message)"""
        return _pyAgrum.PythonApproximationListener_whenStop(self, *args)

    def setWhenProgress(self, *args):
        """setWhenProgress(PythonApproximationListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenProgress(self, *args)

    def setWhenStop(self, *args):
        """setWhenStop(PythonApproximationListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenStop(self, *args)

PythonApproximationListener_swigregister = _pyAgrum.PythonApproximationListener_swigregister
PythonApproximationListener_swigregister(PythonApproximationListener)


def generateBN(n_nodes=10, n_arcs=15, n_modmax=4):
  """
    generateBN(gum::Size n_nodes=10, gum::Size n_arcs=15, gum::Size n_modmax=4) -> BayesNet_double
    generateBN(gum::Size n_nodes=10, gum::Size n_arcs=15) -> BayesNet_double
    generateBN(gum::Size n_nodes=10) -> BayesNet_double
    generateBN() -> BayesNet_double
    """
  return _pyAgrum.generateBN(n_nodes, n_arcs, n_modmax)
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_value(self)

    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _pyAgrum.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_copy(self)

    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator___next__(self)

    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _pyAgrum.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _pyAgrum.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Vector_double(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector_double, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(Vector_double self) -> SwigPyIterator"""
        return _pyAgrum.Vector_double_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(Vector_double self) -> bool"""
        return _pyAgrum.Vector_double___nonzero__(self)

    def __bool__(self):
        """__bool__(Vector_double self) -> bool"""
        return _pyAgrum.Vector_double___bool__(self)

    def __len__(self):
        """__len__(Vector_double self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double___len__(self)

    def pop(self):
        """pop(Vector_double self) -> std::vector< double >::value_type"""
        return _pyAgrum.Vector_double_pop(self)

    def __getslice__(self, *args):
        """__getslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> Vector_double"""
        return _pyAgrum.Vector_double___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            Vector_double v=std::vector< double,std::allocator< double > >())
        __setslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _pyAgrum.Vector_double___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _pyAgrum.Vector_double___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(Vector_double self, std::vector< double >::difference_type i)
        __delitem__(Vector_double self, PySliceObject * slice)
        """
        return _pyAgrum.Vector_double___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(Vector_double self, PySliceObject * slice) -> Vector_double
        __getitem__(Vector_double self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _pyAgrum.Vector_double___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(Vector_double self, PySliceObject * slice, Vector_double v)
        __setitem__(Vector_double self, PySliceObject * slice)
        __setitem__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _pyAgrum.Vector_double___setitem__(self, *args)

    def append(self, *args):
        """append(Vector_double self, std::vector< double >::value_type const & x)"""
        return _pyAgrum.Vector_double_append(self, *args)

    def empty(self):
        """empty(Vector_double self) -> bool"""
        return _pyAgrum.Vector_double_empty(self)

    def size(self):
        """size(Vector_double self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double_size(self)

    def clear(self):
        """clear(Vector_double self)"""
        return _pyAgrum.Vector_double_clear(self)

    def swap(self, *args):
        """swap(Vector_double self, Vector_double v)"""
        return _pyAgrum.Vector_double_swap(self, *args)

    def get_allocator(self):
        """get_allocator(Vector_double self) -> std::vector< double >::allocator_type"""
        return _pyAgrum.Vector_double_get_allocator(self)

    def begin(self):
        """begin(Vector_double self) -> std::vector< double >::iterator"""
        return _pyAgrum.Vector_double_begin(self)

    def end(self):
        """end(Vector_double self) -> std::vector< double >::iterator"""
        return _pyAgrum.Vector_double_end(self)

    def rbegin(self):
        """rbegin(Vector_double self) -> std::vector< double >::reverse_iterator"""
        return _pyAgrum.Vector_double_rbegin(self)

    def rend(self):
        """rend(Vector_double self) -> std::vector< double >::reverse_iterator"""
        return _pyAgrum.Vector_double_rend(self)

    def pop_back(self):
        """pop_back(Vector_double self)"""
        return _pyAgrum.Vector_double_pop_back(self)

    def erase(self, *args):
        """
        erase(Vector_double self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(Vector_double self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _pyAgrum.Vector_double_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> Vector_double
        __init__(std::vector<(double)> self, Vector_double arg2) -> Vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> Vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> Vector_double
        """
        this = _pyAgrum.new_Vector_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(Vector_double self, std::vector< double >::value_type const & x)"""
        return _pyAgrum.Vector_double_push_back(self, *args)

    def front(self):
        """front(Vector_double self) -> std::vector< double >::value_type const &"""
        return _pyAgrum.Vector_double_front(self)

    def back(self):
        """back(Vector_double self) -> std::vector< double >::value_type const &"""
        return _pyAgrum.Vector_double_back(self)

    def assign(self, *args):
        """assign(Vector_double self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _pyAgrum.Vector_double_assign(self, *args)

    def resize(self, *args):
        """
        resize(Vector_double self, std::vector< double >::size_type new_size)
        resize(Vector_double self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _pyAgrum.Vector_double_resize(self, *args)

    def insert(self, *args):
        """
        insert(Vector_double self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(Vector_double self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _pyAgrum.Vector_double_insert(self, *args)

    def reserve(self, *args):
        """reserve(Vector_double self, std::vector< double >::size_type n)"""
        return _pyAgrum.Vector_double_reserve(self, *args)

    def capacity(self):
        """capacity(Vector_double self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double_capacity(self)

    __swig_destroy__ = _pyAgrum.delete_Vector_double
    __del__ = lambda self : None;
Vector_double_swigregister = _pyAgrum.Vector_double_swigregister
Vector_double_swigregister(Vector_double)

GUM_MAJOR_VERSION = _pyAgrum.GUM_MAJOR_VERSION
GUM_MINOR_VERSION = _pyAgrum.GUM_MINOR_VERSION
GUM_PATCH_VERSION = _pyAgrum.GUM_PATCH_VERSION
GUM_VERSION = _pyAgrum.GUM_VERSION
GUM_CHAR_SIZE = _pyAgrum.GUM_CHAR_SIZE
GUM_INT_SIZE = _pyAgrum.GUM_INT_SIZE
GUM_LONG_SIZE = _pyAgrum.GUM_LONG_SIZE
GUM_FLOAT_SIZE = _pyAgrum.GUM_FLOAT_SIZE
GUM_DOUBLE_SIZE = _pyAgrum.GUM_DOUBLE_SIZE

def __createMsg(*args):
  """__createMsg(std::string const & filename, std::string const & function, int const line, std::string const & msg) -> std::string const"""
  return _pyAgrum.__createMsg(*args)
class Exception(Exception):
    """Proxy of C++ gum::Exception class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Exception, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Exception, name)
    __repr__ = _swig_repr
    def __init__(self, aMsg="", aType="Generic error"): 
        """
        __init__(gum::Exception self, std::string const aMsg="", std::string const aType="Generic error") -> Exception
        __init__(gum::Exception self, std::string const aMsg="") -> Exception
        __init__(gum::Exception self) -> Exception
        """
        this = _pyAgrum.new_Exception(aMsg, aType)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Exception
    __del__ = lambda self : None;
    def errorContent(self):
        """errorContent(Exception self) -> std::string const"""
        return _pyAgrum.Exception_errorContent(self)

    def errorType(self):
        """errorType(Exception self) -> std::string const"""
        return _pyAgrum.Exception_errorType(self)

    def errorCallStack(self):
        """errorCallStack(Exception self) -> std::string const"""
        return _pyAgrum.Exception_errorCallStack(self)

    def __str__(self):
        """__str__(Exception self) -> char const *"""
        return _pyAgrum.Exception___str__(self)

Exception_swigregister = _pyAgrum.Exception_swigregister
Exception_swigregister(Exception)

class IdError(Exception):
    """Proxy of C++ gum::IdError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IdError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::IdError self, std::string aMsg, std::string aType="potential problem with an ID") -> IdError
        __init__(gum::IdError self, std::string aMsg) -> IdError
        """
        this = _pyAgrum.new_IdError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IdError
    __del__ = lambda self : None;
IdError_swigregister = _pyAgrum.IdError_swigregister
IdError_swigregister(IdError)

class FatalError(Exception):
    """Proxy of C++ gum::FatalError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FatalError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FatalError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FatalError self, std::string aMsg, std::string aType="Fatal error") -> FatalError
        __init__(gum::FatalError self, std::string aMsg) -> FatalError
        """
        this = _pyAgrum.new_FatalError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FatalError
    __del__ = lambda self : None;
FatalError_swigregister = _pyAgrum.FatalError_swigregister
FatalError_swigregister(FatalError)

class UndefinedIteratorValue(Exception):
    """Proxy of C++ gum::UndefinedIteratorValue class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorValue, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorValue, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::UndefinedIteratorValue self, std::string aMsg, std::string aType="Iterator\'s value is undefined") -> UndefinedIteratorValue
        __init__(gum::UndefinedIteratorValue self, std::string aMsg) -> UndefinedIteratorValue
        """
        this = _pyAgrum.new_UndefinedIteratorValue(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorValue
    __del__ = lambda self : None;
UndefinedIteratorValue_swigregister = _pyAgrum.UndefinedIteratorValue_swigregister
UndefinedIteratorValue_swigregister(UndefinedIteratorValue)

class UndefinedIteratorKey(Exception):
    """Proxy of C++ gum::UndefinedIteratorKey class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorKey, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorKey, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::UndefinedIteratorKey self, std::string aMsg, std::string aType="Iterator\'s key is undefined") -> UndefinedIteratorKey
        __init__(gum::UndefinedIteratorKey self, std::string aMsg) -> UndefinedIteratorKey
        """
        this = _pyAgrum.new_UndefinedIteratorKey(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorKey
    __del__ = lambda self : None;
UndefinedIteratorKey_swigregister = _pyAgrum.UndefinedIteratorKey_swigregister
UndefinedIteratorKey_swigregister(UndefinedIteratorKey)

class NullElement(Exception):
    """Proxy of C++ gum::NullElement class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NullElement, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NullElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NullElement self, std::string aMsg, std::string aType="Null Element") -> NullElement
        __init__(gum::NullElement self, std::string aMsg) -> NullElement
        """
        this = _pyAgrum.new_NullElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NullElement
    __del__ = lambda self : None;
NullElement_swigregister = _pyAgrum.NullElement_swigregister
NullElement_swigregister(NullElement)

class UndefinedElement(Exception):
    """Proxy of C++ gum::UndefinedElement class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedElement, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::UndefinedElement self, std::string aMsg, std::string aType="could not find the so-called element") -> UndefinedElement
        __init__(gum::UndefinedElement self, std::string aMsg) -> UndefinedElement
        """
        this = _pyAgrum.new_UndefinedElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedElement
    __del__ = lambda self : None;
UndefinedElement_swigregister = _pyAgrum.UndefinedElement_swigregister
UndefinedElement_swigregister(UndefinedElement)

class HashSize(Exception):
    """Proxy of C++ gum::HashSize class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HashSize, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HashSize, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::HashSize self, std::string aMsg, std::string aType="size not admissible in a HashTable") -> HashSize
        __init__(gum::HashSize self, std::string aMsg) -> HashSize
        """
        this = _pyAgrum.new_HashSize(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_HashSize
    __del__ = lambda self : None;
HashSize_swigregister = _pyAgrum.HashSize_swigregister
HashSize_swigregister(HashSize)

class SizeError(Exception):
    """Proxy of C++ gum::SizeError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SizeError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SizeError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::SizeError self, std::string aMsg, std::string aType="size not admissible in a HashTable") -> SizeError
        __init__(gum::SizeError self, std::string aMsg) -> SizeError
        """
        this = _pyAgrum.new_SizeError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_SizeError
    __del__ = lambda self : None;
SizeError_swigregister = _pyAgrum.SizeError_swigregister
SizeError_swigregister(SizeError)

class EmptySet(Exception):
    """Proxy of C++ gum::EmptySet class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptySet, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptySet, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::EmptySet self, std::string aMsg, std::string aType="an empty set has been found where it should not be") -> EmptySet
        __init__(gum::EmptySet self, std::string aMsg) -> EmptySet
        """
        this = _pyAgrum.new_EmptySet(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptySet
    __del__ = lambda self : None;
EmptySet_swigregister = _pyAgrum.EmptySet_swigregister
EmptySet_swigregister(EmptySet)

class InvalidArgumentsNumber(Exception):
    """Proxy of C++ gum::InvalidArgumentsNumber class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgumentsNumber, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgumentsNumber, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidArgumentsNumber self, std::string aMsg, std::string aType="the number of arguments passed differs from what was expected") -> InvalidArgumentsNumber
        __init__(gum::InvalidArgumentsNumber self, std::string aMsg) -> InvalidArgumentsNumber
        """
        this = _pyAgrum.new_InvalidArgumentsNumber(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgumentsNumber
    __del__ = lambda self : None;
InvalidArgumentsNumber_swigregister = _pyAgrum.InvalidArgumentsNumber_swigregister
InvalidArgumentsNumber_swigregister(InvalidArgumentsNumber)

class InvalidArgument(Exception):
    """Proxy of C++ gum::InvalidArgument class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgument, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgument, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidArgument self, std::string aMsg, std::string aType="at least one argument passed differs from what was expected") -> InvalidArgument
        __init__(gum::InvalidArgument self, std::string aMsg) -> InvalidArgument
        """
        this = _pyAgrum.new_InvalidArgument(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgument
    __del__ = lambda self : None;
InvalidArgument_swigregister = _pyAgrum.InvalidArgument_swigregister
InvalidArgument_swigregister(InvalidArgument)

class IOError(Exception):
    """Proxy of C++ gum::IOError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::IOError self, std::string aMsg, std::string aType="an input/output error occurred") -> IOError
        __init__(gum::IOError self, std::string aMsg) -> IOError
        """
        this = _pyAgrum.new_IOError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IOError
    __del__ = lambda self : None;
IOError_swigregister = _pyAgrum.IOError_swigregister
IOError_swigregister(IOError)

class FormatNotFound(IOError):
    """Proxy of C++ gum::FormatNotFound class"""
    __swig_setmethods__ = {}
    for _s in [IOError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormatNotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormatNotFound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FormatNotFound self, std::string aMsg, std::string aType="could not find the specified format") -> FormatNotFound
        __init__(gum::FormatNotFound self, std::string aMsg) -> FormatNotFound
        """
        this = _pyAgrum.new_FormatNotFound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FormatNotFound
    __del__ = lambda self : None;
FormatNotFound_swigregister = _pyAgrum.FormatNotFound_swigregister
FormatNotFound_swigregister(FormatNotFound)

class OperationNotAllowed(Exception):
    """Proxy of C++ gum::OperationNotAllowed class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OperationNotAllowed, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OperationNotAllowed, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OperationNotAllowed self, std::string aMsg, std::string aType="this operation is not allowed") -> OperationNotAllowed
        __init__(gum::OperationNotAllowed self, std::string aMsg) -> OperationNotAllowed
        """
        this = _pyAgrum.new_OperationNotAllowed(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OperationNotAllowed
    __del__ = lambda self : None;
OperationNotAllowed_swigregister = _pyAgrum.OperationNotAllowed_swigregister
OperationNotAllowed_swigregister(OperationNotAllowed)

class NotFound(Exception):
    """Proxy of C++ gum::NotFound class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotFound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NotFound self, std::string aMsg, std::string aType="could not find this object") -> NotFound
        __init__(gum::NotFound self, std::string aMsg) -> NotFound
        """
        this = _pyAgrum.new_NotFound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NotFound
    __del__ = lambda self : None;
NotFound_swigregister = _pyAgrum.NotFound_swigregister
NotFound_swigregister(NotFound)

class ReferenceError(Exception):
    """Proxy of C++ gum::ReferenceError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReferenceError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReferenceError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::ReferenceError self, std::string aMsg, std::string aType="Reference error") -> ReferenceError
        __init__(gum::ReferenceError self, std::string aMsg) -> ReferenceError
        """
        this = _pyAgrum.new_ReferenceError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_ReferenceError
    __del__ = lambda self : None;
ReferenceError_swigregister = _pyAgrum.ReferenceError_swigregister
ReferenceError_swigregister(ReferenceError)

class OutOfBounds(ReferenceError):
    """Proxy of C++ gum::OutOfBounds class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfBounds, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfBounds, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OutOfBounds self, std::string aMsg, std::string aType="Out of bound") -> OutOfBounds
        __init__(gum::OutOfBounds self, std::string aMsg) -> OutOfBounds
        """
        this = _pyAgrum.new_OutOfBounds(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfBounds
    __del__ = lambda self : None;
OutOfBounds_swigregister = _pyAgrum.OutOfBounds_swigregister
OutOfBounds_swigregister(OutOfBounds)

class OutOfLowerBound(OutOfBounds):
    """Proxy of C++ gum::OutOfLowerBound class"""
    __swig_setmethods__ = {}
    for _s in [OutOfBounds]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfLowerBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfLowerBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OutOfLowerBound self, std::string aMsg, std::string aType="Out of bound") -> OutOfLowerBound
        __init__(gum::OutOfLowerBound self, std::string aMsg) -> OutOfLowerBound
        """
        this = _pyAgrum.new_OutOfLowerBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfLowerBound
    __del__ = lambda self : None;
OutOfLowerBound_swigregister = _pyAgrum.OutOfLowerBound_swigregister
OutOfLowerBound_swigregister(OutOfLowerBound)

class OutOfUpperBound(OutOfBounds):
    """Proxy of C++ gum::OutOfUpperBound class"""
    __swig_setmethods__ = {}
    for _s in [OutOfBounds]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfUpperBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfUpperBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OutOfUpperBound self, std::string aMsg, std::string aType="Out of bound") -> OutOfUpperBound
        __init__(gum::OutOfUpperBound self, std::string aMsg) -> OutOfUpperBound
        """
        this = _pyAgrum.new_OutOfUpperBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfUpperBound
    __del__ = lambda self : None;
OutOfUpperBound_swigregister = _pyAgrum.OutOfUpperBound_swigregister
OutOfUpperBound_swigregister(OutOfUpperBound)

class DuplicateElement(ReferenceError):
    """Proxy of C++ gum::DuplicateElement class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateElement, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DuplicateElement self, std::string aMsg, std::string aType="A similar element already exists") -> DuplicateElement
        __init__(gum::DuplicateElement self, std::string aMsg) -> DuplicateElement
        """
        this = _pyAgrum.new_DuplicateElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateElement
    __del__ = lambda self : None;
DuplicateElement_swigregister = _pyAgrum.DuplicateElement_swigregister
DuplicateElement_swigregister(DuplicateElement)

class DuplicateLabel(ReferenceError):
    """Proxy of C++ gum::DuplicateLabel class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateLabel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DuplicateLabel self, std::string aMsg, std::string aType="A similar label already exists") -> DuplicateLabel
        __init__(gum::DuplicateLabel self, std::string aMsg) -> DuplicateLabel
        """
        this = _pyAgrum.new_DuplicateLabel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateLabel
    __del__ = lambda self : None;
DuplicateLabel_swigregister = _pyAgrum.DuplicateLabel_swigregister
DuplicateLabel_swigregister(DuplicateLabel)

class GraphError(Exception):
    """Proxy of C++ gum::GraphError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GraphError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GraphError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::GraphError self, std::string aMsg, std::string aType="Graph error") -> GraphError
        __init__(gum::GraphError self, std::string aMsg) -> GraphError
        """
        this = _pyAgrum.new_GraphError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GraphError
    __del__ = lambda self : None;
GraphError_swigregister = _pyAgrum.GraphError_swigregister
GraphError_swigregister(GraphError)

class NoNeighbour(GraphError):
    """Proxy of C++ gum::NoNeighbour class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoNeighbour, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoNeighbour, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NoNeighbour self, std::string aMsg, std::string aType="No neighbour can be found to the given node") -> NoNeighbour
        __init__(gum::NoNeighbour self, std::string aMsg) -> NoNeighbour
        """
        this = _pyAgrum.new_NoNeighbour(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoNeighbour
    __del__ = lambda self : None;
NoNeighbour_swigregister = _pyAgrum.NoNeighbour_swigregister
NoNeighbour_swigregister(NoNeighbour)

class NoParent(GraphError):
    """Proxy of C++ gum::NoParent class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoParent, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoParent, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NoParent self, std::string aMsg, std::string aType="No parent can be found w.r.t the given node") -> NoParent
        __init__(gum::NoParent self, std::string aMsg) -> NoParent
        """
        this = _pyAgrum.new_NoParent(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoParent
    __del__ = lambda self : None;
NoParent_swigregister = _pyAgrum.NoParent_swigregister
NoParent_swigregister(NoParent)

class NoChild(GraphError):
    """Proxy of C++ gum::NoChild class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoChild, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoChild, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NoChild self, std::string aMsg, std::string aType="No child can be found w.r.t the given node") -> NoChild
        __init__(gum::NoChild self, std::string aMsg) -> NoChild
        """
        this = _pyAgrum.new_NoChild(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoChild
    __del__ = lambda self : None;
NoChild_swigregister = _pyAgrum.NoChild_swigregister
NoChild_swigregister(NoChild)

class InvalidEdge(GraphError):
    """Proxy of C++ gum::InvalidEdge class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidEdge, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidEdge self, std::string aMsg, std::string aType="the edge is not correct") -> InvalidEdge
        __init__(gum::InvalidEdge self, std::string aMsg) -> InvalidEdge
        """
        this = _pyAgrum.new_InvalidEdge(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidEdge
    __del__ = lambda self : None;
InvalidEdge_swigregister = _pyAgrum.InvalidEdge_swigregister
InvalidEdge_swigregister(InvalidEdge)

class InvalidArc(GraphError):
    """Proxy of C++ gum::InvalidArc class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArc, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArc, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidArc self, std::string aMsg, std::string aType="the arc is not correct") -> InvalidArc
        __init__(gum::InvalidArc self, std::string aMsg) -> InvalidArc
        """
        this = _pyAgrum.new_InvalidArc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArc
    __del__ = lambda self : None;
InvalidArc_swigregister = _pyAgrum.InvalidArc_swigregister
InvalidArc_swigregister(InvalidArc)

class InvalidNode(GraphError):
    """Proxy of C++ gum::InvalidNode class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidNode self, std::string aMsg, std::string aType="the node does not exist") -> InvalidNode
        __init__(gum::InvalidNode self, std::string aMsg) -> InvalidNode
        """
        this = _pyAgrum.new_InvalidNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidNode
    __del__ = lambda self : None;
InvalidNode_swigregister = _pyAgrum.InvalidNode_swigregister
InvalidNode_swigregister(InvalidNode)

class EmptyBSTree(GraphError):
    """Proxy of C++ gum::EmptyBSTree class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptyBSTree, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptyBSTree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::EmptyBSTree self, std::string aMsg, std::string aType="the binary search tree is empty") -> EmptyBSTree
        __init__(gum::EmptyBSTree self, std::string aMsg) -> EmptyBSTree
        """
        this = _pyAgrum.new_EmptyBSTree(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptyBSTree
    __del__ = lambda self : None;
EmptyBSTree_swigregister = _pyAgrum.EmptyBSTree_swigregister
EmptyBSTree_swigregister(EmptyBSTree)

class DefaultInLabel(GraphError):
    """Proxy of C++ gum::DefaultInLabel class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultInLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultInLabel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DefaultInLabel self, std::string aMsg, std::string aType="Error on label") -> DefaultInLabel
        __init__(gum::DefaultInLabel self, std::string aMsg) -> DefaultInLabel
        """
        this = _pyAgrum.new_DefaultInLabel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DefaultInLabel
    __del__ = lambda self : None;
DefaultInLabel_swigregister = _pyAgrum.DefaultInLabel_swigregister
DefaultInLabel_swigregister(DefaultInLabel)

class InvalidDirectedCycle(GraphError):
    """Proxy of C++ gum::InvalidDirectedCycle class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidDirectedCycle, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidDirectedCycle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidDirectedCycle self, std::string aMsg, std::string aType="the graph contains a directed cycle") -> InvalidDirectedCycle
        __init__(gum::InvalidDirectedCycle self, std::string aMsg) -> InvalidDirectedCycle
        """
        this = _pyAgrum.new_InvalidDirectedCycle(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidDirectedCycle
    __del__ = lambda self : None;
InvalidDirectedCycle_swigregister = _pyAgrum.InvalidDirectedCycle_swigregister
InvalidDirectedCycle_swigregister(InvalidDirectedCycle)

class CPTError(Exception):
    """Proxy of C++ gum::CPTError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::CPTError self, std::string aMsg, std::string aType="CPT error") -> CPTError
        __init__(gum::CPTError self, std::string aMsg) -> CPTError
        """
        this = _pyAgrum.new_CPTError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTError
    __del__ = lambda self : None;
CPTError_swigregister = _pyAgrum.CPTError_swigregister
CPTError_swigregister(CPTError)

class CPTNoSumTo1(CPTError):
    """Proxy of C++ gum::CPTNoSumTo1 class"""
    __swig_setmethods__ = {}
    for _s in [CPTError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTNoSumTo1, name, value)
    __swig_getmethods__ = {}
    for _s in [CPTError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTNoSumTo1, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::CPTNoSumTo1 self, std::string aMsg, std::string aType="CPT does not sum to 1") -> CPTNoSumTo1
        __init__(gum::CPTNoSumTo1 self, std::string aMsg) -> CPTNoSumTo1
        """
        this = _pyAgrum.new_CPTNoSumTo1(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTNoSumTo1
    __del__ = lambda self : None;
CPTNoSumTo1_swigregister = _pyAgrum.CPTNoSumTo1_swigregister
CPTNoSumTo1_swigregister(CPTNoSumTo1)

class FactoryError(Exception):
    """Proxy of C++ gum::FactoryError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FactoryError self, std::string aMsg, std::string aType="factory error") -> FactoryError
        __init__(gum::FactoryError self, std::string aMsg) -> FactoryError
        """
        this = _pyAgrum.new_FactoryError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryError
    __del__ = lambda self : None;
FactoryError_swigregister = _pyAgrum.FactoryError_swigregister
FactoryError_swigregister(FactoryError)

class FactoryInvalidState(FactoryError):
    """Proxy of C++ gum::FactoryInvalidState class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryInvalidState, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryInvalidState, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FactoryInvalidState self, std::string aMsg, std::string aType="invalid state error") -> FactoryInvalidState
        __init__(gum::FactoryInvalidState self, std::string aMsg) -> FactoryInvalidState
        """
        this = _pyAgrum.new_FactoryInvalidState(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryInvalidState
    __del__ = lambda self : None;
FactoryInvalidState_swigregister = _pyAgrum.FactoryInvalidState_swigregister
FactoryInvalidState_swigregister(FactoryInvalidState)

class WrongType(FactoryError):
    """Proxy of C++ gum::WrongType class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongType, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongType, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::WrongType self, std::string aMsg, std::string aType="wrong type for this operation") -> WrongType
        __init__(gum::WrongType self, std::string aMsg) -> WrongType
        """
        this = _pyAgrum.new_WrongType(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongType
    __del__ = lambda self : None;
WrongType_swigregister = _pyAgrum.WrongType_swigregister
WrongType_swigregister(WrongType)

class WrongClassElement(FactoryError):
    """Proxy of C++ gum::WrongClassElement class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongClassElement, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongClassElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::WrongClassElement self, std::string aMsg, std::string aType="wrong ClassElement for this operation") -> WrongClassElement
        __init__(gum::WrongClassElement self, std::string aMsg) -> WrongClassElement
        """
        this = _pyAgrum.new_WrongClassElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongClassElement
    __del__ = lambda self : None;
WrongClassElement_swigregister = _pyAgrum.WrongClassElement_swigregister
WrongClassElement_swigregister(WrongClassElement)

class TypeError(FactoryError):
    """Proxy of C++ gum::TypeError class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeError, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TypeError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::TypeError self, std::string aMsg, std::string aType="wrong subtype or subclass") -> TypeError
        __init__(gum::TypeError self, std::string aMsg) -> TypeError
        """
        this = _pyAgrum.new_TypeError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_TypeError
    __del__ = lambda self : None;
TypeError_swigregister = _pyAgrum.TypeError_swigregister
TypeError_swigregister(TypeError)

class SyntaxError(IOError):
    """Proxy of C++ gum::SyntaxError class"""
    __swig_setmethods__ = {}
    for _s in [IOError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SyntaxError, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SyntaxError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::SyntaxError self, std::string const & aMsg, gum::Size nol, gum::Size noc, std::string aType="Syntax Error") -> SyntaxError
        __init__(gum::SyntaxError self, std::string const & aMsg, gum::Size nol, gum::Size noc) -> SyntaxError
        """
        this = _pyAgrum.new_SyntaxError(*args)
        try: self.this.append(this)
        except: self.this = this
    def col(self):
        """col(SyntaxError self) -> gum::Size"""
        return _pyAgrum.SyntaxError_col(self)

    def line(self):
        """line(SyntaxError self) -> gum::Size"""
        return _pyAgrum.SyntaxError_line(self)

    __swig_destroy__ = _pyAgrum.delete_SyntaxError
    __del__ = lambda self : None;
SyntaxError_swigregister = _pyAgrum.SyntaxError_swigregister
SyntaxError_swigregister(SyntaxError)


def randomProba():
  """randomProba() -> double"""
  return _pyAgrum.randomProba()

def initRandom(init=0):
  """
    initRandom(unsigned int init=0)
    initRandom()
    """
  return _pyAgrum.initRandom(init)

def isOMP():
  """isOMP() -> bool"""
  return _pyAgrum.isOMP()

def setNumberOfThreads(*args):
  """setNumberOfThreads(unsigned int number)"""
  return _pyAgrum.setNumberOfThreads(*args)

def getMaxNumberOfThreads():
  """getMaxNumberOfThreads() -> unsigned int"""
  return _pyAgrum.getMaxNumberOfThreads()

def getThreadNumber():
  """getThreadNumber() -> unsigned int"""
  return _pyAgrum.getThreadNumber()

def getNumberOfRunningThreads():
  """getNumberOfRunningThreads() -> unsigned int"""
  return _pyAgrum.getNumberOfRunningThreads()

def getNumberOfLogicalProcessors():
  """getNumberOfLogicalProcessors() -> unsigned int"""
  return _pyAgrum.getNumberOfLogicalProcessors()

def setNestedParallelism(*args):
  """setNestedParallelism(bool value)"""
  return _pyAgrum.setNestedParallelism(*args)

def getNestedParallelism():
  """getNestedParallelism() -> bool"""
  return _pyAgrum.getNestedParallelism()

def setDynamicThreadsNumber(*args):
  """setDynamicThreadsNumber(bool value)"""
  return _pyAgrum.setDynamicThreadsNumber(*args)

def getDynamicThreadsNumber():
  """getDynamicThreadsNumber() -> bool"""
  return _pyAgrum.getDynamicThreadsNumber()
class Variable(_object):
    """Proxy of C++ gum::Variable class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_Variable
    __del__ = lambda self : None;
    def clone(self):
        """clone(Variable self) -> Variable"""
        return _pyAgrum.Variable_clone(self)

    def __eq__(self, *args):
        """__eq__(Variable self, Variable aRV) -> bool"""
        return _pyAgrum.Variable___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(Variable self, Variable aRV) -> bool"""
        return _pyAgrum.Variable___ne__(self, *args)

    def setName(self, *args):
        """setName(Variable self, std::string const & theValue)"""
        return _pyAgrum.Variable_setName(self, *args)

    def name(self):
        """name(Variable self) -> std::string const &"""
        return _pyAgrum.Variable_name(self)

    def setDescription(self, *args):
        """setDescription(Variable self, std::string const & theValue)"""
        return _pyAgrum.Variable_setDescription(self, *args)

    def description(self):
        """description(Variable self) -> std::string const &"""
        return _pyAgrum.Variable_description(self)

Variable_swigregister = _pyAgrum.Variable_swigregister
Variable_swigregister(Variable)

class DiscreteVar(Variable):
    """Proxy of C++ gum::DiscreteVariable class"""
    __swig_setmethods__ = {}
    for _s in [Variable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteVar, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteVar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Discretized = _pyAgrum.DiscreteVar_Discretized
    Labelized = _pyAgrum.DiscreteVar_Labelized
    Range = _pyAgrum.DiscreteVar_Range
    __swig_destroy__ = _pyAgrum.delete_DiscreteVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(DiscreteVar self) -> DiscreteVar"""
        return _pyAgrum.DiscreteVar_clone(self)

    def empty(self):
        """empty(DiscreteVar self) -> bool"""
        return _pyAgrum.DiscreteVar_empty(self)

    def __len__(self):
        """__len__(DiscreteVar self) -> gum::Size"""
        return _pyAgrum.DiscreteVar___len__(self)

    def label(self, *args):
        """label(DiscreteVar self, gum::Idx indice) -> std::string const"""
        return _pyAgrum.DiscreteVar_label(self, *args)

    def varType(self):
        """varType(DiscreteVar self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.DiscreteVar_varType(self)

    def __eq__(self, *args):
        """__eq__(DiscreteVar self, DiscreteVar aRV) -> bool"""
        return _pyAgrum.DiscreteVar___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(DiscreteVar self, DiscreteVar aRV) -> bool"""
        return _pyAgrum.DiscreteVar___ne__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(DiscreteVar self, std::string const & label) -> gum::Idx"""
        return _pyAgrum.DiscreteVar___getitem__(self, *args)

    def __str__(self):
        """__str__(DiscreteVar self) -> std::string const"""
        return _pyAgrum.DiscreteVar___str__(self)

    def toLabelizedVar(self):
        """toLabelizedVar(DiscreteVar self) -> LabelizedVar"""
        return _pyAgrum.DiscreteVar_toLabelizedVar(self)

    def toRangeVar(self):
        """toRangeVar(DiscreteVar self) -> RangeVar"""
        return _pyAgrum.DiscreteVar_toRangeVar(self)

    def toDiscretizedVar(self):
        """toDiscretizedVar(DiscreteVar self) -> DiscretizedVar"""
        return _pyAgrum.DiscreteVar_toDiscretizedVar(self)

DiscreteVar_swigregister = _pyAgrum.DiscreteVar_swigregister
DiscreteVar_swigregister(DiscreteVar)

class LabelizedVar(DiscreteVar):
    """Proxy of C++ gum::LabelizedVariable class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVar]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelizedVar, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVar]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelizedVar, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_LabelizedVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(LabelizedVar self) -> DiscreteVar"""
        return _pyAgrum.LabelizedVar_clone(self)

    def __getitem__(self, *args):
        """__getitem__(LabelizedVar self, std::string const & aLabel) -> gum::Idx"""
        return _pyAgrum.LabelizedVar___getitem__(self, *args)

    def isLabel(self, *args):
        """isLabel(LabelizedVar self, std::string const & aLabel) -> bool"""
        return _pyAgrum.LabelizedVar_isLabel(self, *args)

    def addLabel(self,*args):
      _pyAgrum.LabelizedVar_addLabel(self,*args)
      return self


    def eraseLabels(self):
        """eraseLabels(LabelizedVar self)"""
        return _pyAgrum.LabelizedVar_eraseLabels(self)

    def label(self, *args):
        """label(LabelizedVar self, gum::Idx i) -> std::string const"""
        return _pyAgrum.LabelizedVar_label(self, *args)

    def __len__(self):
        """__len__(LabelizedVar self) -> gum::Size"""
        return _pyAgrum.LabelizedVar___len__(self)

    def labels(self):
        """labels(LabelizedVar self) -> gum::Sequence< std::string > const &"""
        return _pyAgrum.LabelizedVar_labels(self)

    def varType(self):
        """varType(LabelizedVar self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.LabelizedVar_varType(self)

    def __init__(self, *args): 
        """
        LabelizedVariable(std::string const & aName, std::string const & aDesc="", int const nbrLabel=2) -> LabelizedVar
        LabelizedVariable(std::string const & aName, std::string const & aDesc="") -> LabelizedVar
        LabelizedVariable(std::string const & aName) -> LabelizedVar
        LabelizedVariable(LabelizedVar aLDRV) -> LabelizedVar
        __init__(gum::LabelizedVariable self) -> LabelizedVar
        """
        if self.__class__ == LabelizedVar:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_LabelizedVar(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_LabelizedVar(self)
        return weakref_proxy(self)
LabelizedVar_swigregister = _pyAgrum.LabelizedVar_swigregister
LabelizedVar_swigregister(LabelizedVar)

class RangeVar(DiscreteVar):
    """Proxy of C++ gum::RangeVariable class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVar]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RangeVar, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVar]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RangeVar, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        RangeVariable(std::string const & aName, std::string const & aDesc, gum::Idx minVal=0, gum::Idx maxVal=1) -> RangeVar
        RangeVariable(std::string const & aName, std::string const & aDesc, gum::Idx minVal=0) -> RangeVar
        RangeVariable(std::string const & aName, std::string const & aDesc) -> RangeVar
        __init__(gum::RangeVariable self, RangeVar aDRV) -> RangeVar
        """
        this = _pyAgrum.new_RangeVar(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_RangeVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(RangeVar self) -> DiscreteVar"""
        return _pyAgrum.RangeVar_clone(self)

    def __len__(self):
        """__len__(RangeVar self) -> gum::Size"""
        return _pyAgrum.RangeVar___len__(self)

    def varType(self):
        """varType(RangeVar self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.RangeVar_varType(self)

    def label(self, *args):
        """label(RangeVar self, gum::Idx indice) -> std::string const"""
        return _pyAgrum.RangeVar_label(self, *args)

    def minVal(self):
        """minVal(RangeVar self) -> gum::Idx"""
        return _pyAgrum.RangeVar_minVal(self)

    def setMinVal(self, *args):
        """setMinVal(RangeVar self, gum::Idx minVal)"""
        return _pyAgrum.RangeVar_setMinVal(self, *args)

    def maxVal(self):
        """maxVal(RangeVar self) -> gum::Idx"""
        return _pyAgrum.RangeVar_maxVal(self)

    def setMaxVal(self, *args):
        """setMaxVal(RangeVar self, gum::Idx maxVal)"""
        return _pyAgrum.RangeVar_setMaxVal(self, *args)

    def belongs(self, *args):
        """belongs(RangeVar self, gum::Idx indice) -> bool"""
        return _pyAgrum.RangeVar_belongs(self, *args)

    def __getitem__(self, *args):
        """__getitem__(RangeVar self, std::string const & arg2) -> gum::Idx"""
        return _pyAgrum.RangeVar___getitem__(self, *args)

    def __str__(self):
        """__str__(RangeVar self) -> std::string const"""
        return _pyAgrum.RangeVar___str__(self)

RangeVar_swigregister = _pyAgrum.RangeVar_swigregister
RangeVar_swigregister(RangeVar)

INC_MARKS_ARRAY = _pyAgrum.INC_MARKS_ARRAY
class Edge(_object):
    """Proxy of C++ gum::Edge class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Edge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Edge, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Edge self, gum::NodeId aN1, gum::NodeId aN2) -> Edge
        __init__(gum::Edge self, Edge src) -> Edge
        """
        this = _pyAgrum.new_Edge(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Edge
    __del__ = lambda self : None;
    def isDirected(self):
        """isDirected(Edge self) -> bool"""
        return _pyAgrum.Edge_isDirected(self)

    def other(self, *args):
        """other(Edge self, gum::NodeId id) -> gum::NodeId"""
        return _pyAgrum.Edge_other(self, *args)

    def first(self):
        """first(Edge self) -> gum::NodeId"""
        return _pyAgrum.Edge_first(self)

    def second(self):
        """second(Edge self) -> gum::NodeId"""
        return _pyAgrum.Edge_second(self)

    def __eq__(self, *args):
        """__eq__(Edge self, Edge src) -> bool"""
        return _pyAgrum.Edge___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(Edge self, Edge src) -> bool"""
        return _pyAgrum.Edge___ne__(self, *args)

Edge_swigregister = _pyAgrum.Edge_swigregister
Edge_swigregister(Edge)

class Arc(_object):
    """Proxy of C++ gum::Arc class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Arc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Arc, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Arc self, gum::NodeId tail, gum::NodeId head) -> Arc
        __init__(gum::Arc self, Arc src) -> Arc
        """
        this = _pyAgrum.new_Arc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Arc
    __del__ = lambda self : None;
    def tail(self):
        """tail(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_tail(self)

    def head(self):
        """head(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_head(self)

    def isDirected(self):
        """isDirected(Arc self) -> bool"""
        return _pyAgrum.Arc_isDirected(self)

    def other(self, *args):
        """other(Arc self, gum::NodeId id) -> gum::NodeId"""
        return _pyAgrum.Arc_other(self, *args)

    def first(self):
        """first(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_first(self)

    def second(self):
        """second(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_second(self)

    def __eq__(self, *args):
        """__eq__(Arc self, Arc src) -> bool"""
        return _pyAgrum.Arc___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(Arc self, Arc src) -> bool"""
        return _pyAgrum.Arc___ne__(self, *args)

Arc_swigregister = _pyAgrum.Arc_swigregister
Arc_swigregister(Arc)

class DiGraph(_object):
    """Proxy of C++ gum::DiGraph class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DiGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size, bool arcs_resize_policy=True) -> DiGraph
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size) -> DiGraph
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True) -> DiGraph
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size) -> DiGraph
        __init__(gum::DiGraph self) -> DiGraph
        __init__(gum::DiGraph self, DiGraph g) -> DiGraph
        """
        this = _pyAgrum.new_DiGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiGraph
    __del__ = lambda self : None;
    def __eq__(self, *args):
        """__eq__(DiGraph self, DiGraph g) -> bool"""
        return _pyAgrum.DiGraph___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(DiGraph self, DiGraph g) -> bool"""
        return _pyAgrum.DiGraph___ne__(self, *args)

    def insertArc(self, *args):
        """insertArc(DiGraph self, gum::NodeId const tail, gum::NodeId const head)"""
        return _pyAgrum.DiGraph_insertArc(self, *args)

    def eraseNode(self, *args):
        """eraseNode(DiGraph self, gum::NodeId const id)"""
        return _pyAgrum.DiGraph_eraseNode(self, *args)

    def clear(self):
        """clear(DiGraph self)"""
        return _pyAgrum.DiGraph_clear(self)

    def __str__(self):
        """__str__(DiGraph self) -> std::string const"""
        return _pyAgrum.DiGraph___str__(self)

    def toDot(self, name="G"):
        """
        toDot(DiGraph self, std::string const & name="G") -> std::string const
        toDot(DiGraph self) -> std::string const
        """
        return _pyAgrum.DiGraph_toDot(self, name)

DiGraph_swigregister = _pyAgrum.DiGraph_swigregister
DiGraph_swigregister(DiGraph)

class MultiDimInterface(_object):
    """Proxy of C++ gum::MultiDimInterface class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimInterface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimInterface
    __del__ = lambda self : None;
    def nbrDim(self):
        """nbrDim(MultiDimInterface self) -> gum::Idx"""
        return _pyAgrum.MultiDimInterface_nbrDim(self)

    def domainSize(self):
        """domainSize(MultiDimInterface self) -> gum::Size"""
        return _pyAgrum.MultiDimInterface_domainSize(self)

    def add(self, *args):
        """add(MultiDimInterface self, DiscreteVar v)"""
        return _pyAgrum.MultiDimInterface_add(self, *args)

    def erase(self, *args):
        """erase(MultiDimInterface self, DiscreteVar v)"""
        return _pyAgrum.MultiDimInterface_erase(self, *args)

    def variablesSequence(self):
        """variablesSequence(MultiDimInterface self) -> gum::Sequence< gum::DiscreteVariable const * > const &"""
        return _pyAgrum.MultiDimInterface_variablesSequence(self)

    def variable(self, *args):
        """variable(MultiDimInterface self, gum::Idx i) -> DiscreteVar"""
        return _pyAgrum.MultiDimInterface_variable(self, *args)

    def pos(self, *args):
        """pos(MultiDimInterface self, DiscreteVar v) -> gum::Idx"""
        return _pyAgrum.MultiDimInterface_pos(self, *args)

    def contains(self, *args):
        """contains(MultiDimInterface self, DiscreteVar v) -> bool"""
        return _pyAgrum.MultiDimInterface_contains(self, *args)

    def empty(self):
        """empty(MultiDimInterface self) -> bool"""
        return _pyAgrum.MultiDimInterface_empty(self)

    def swap(self, *args):
        """swap(MultiDimInterface self, DiscreteVar x, DiscreteVar y)"""
        return _pyAgrum.MultiDimInterface_swap(self, *args)

    def begin(self):
        """begin(MultiDimInterface self) -> gum::MultiDimInterface::iterator"""
        return _pyAgrum.MultiDimInterface_begin(self)

    def rbegin(self):
        """rbegin(MultiDimInterface self) -> gum::MultiDimInterface::iterator"""
        return _pyAgrum.MultiDimInterface_rbegin(self)

    def end(self):
        """end(MultiDimInterface self) -> gum::MultiDimInterface::iterator const &"""
        return _pyAgrum.MultiDimInterface_end(self)

    def rend(self):
        """rend(MultiDimInterface self) -> gum::MultiDimInterface::iterator const &"""
        return _pyAgrum.MultiDimInterface_rend(self)

MultiDimInterface_swigregister = _pyAgrum.MultiDimInterface_swigregister
MultiDimInterface_swigregister(MultiDimInterface)

class Instantiation(MultiDimInterface):
    """Proxy of C++ gum::Instantiation class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimInterface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Instantiation, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimInterface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Instantiation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Instantiation self) -> Instantiation
        __init__(gum::Instantiation self, Instantiation aI, bool const notifyMaster=True) -> Instantiation
        __init__(gum::Instantiation self, Instantiation aI) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        """
        this = _pyAgrum.new_Instantiation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Instantiation
    __del__ = lambda self : None;
    def __len__(self):
        """__len__(Instantiation self) -> gum::Idx"""
        return _pyAgrum.Instantiation___len__(self)

    def add(self, *args):
        """add(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_add(self, *args)

    def erase(self, *args):
        """erase(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_erase(self, *args)

    def clear(self):
        """clear(Instantiation self)"""
        return _pyAgrum.Instantiation_clear(self)

    def domainSize(self):
        """domainSize(Instantiation self) -> gum::Size"""
        return _pyAgrum.Instantiation_domainSize(self)

    def pos(self, *args):
        """pos(Instantiation self, DiscreteVar v) -> gum::Idx"""
        return _pyAgrum.Instantiation_pos(self, *args)

    def val(self, *args):
        """
        val(Instantiation self, gum::Idx i) -> gum::Idx
        val(Instantiation self, DiscreteVar var) -> gum::Idx
        """
        return _pyAgrum.Instantiation_val(self, *args)

    def valFromPtr(self, *args):
        """valFromPtr(Instantiation self, DiscreteVar pvar) -> gum::Idx"""
        return _pyAgrum.Instantiation_valFromPtr(self, *args)

    def variable(self, *args):
        """variable(Instantiation self, gum::Idx i) -> DiscreteVar"""
        return _pyAgrum.Instantiation_variable(self, *args)

    def chgVal(self, *args):
        """
        chgVal(Instantiation self, DiscreteVar v, gum::Idx newval) -> Instantiation
        chgVal(Instantiation self, DiscreteVar v, gum::Idx newval) -> Instantiation
        chgVal(Instantiation self, gum::Idx varPos, gum::Idx newval) -> Instantiation
        """
        return _pyAgrum.Instantiation_chgVal(self, *args)

    def setVals(self, *args):
        """setVals(Instantiation self, Instantiation i) -> Instantiation"""
        return _pyAgrum.Instantiation_setVals(self, *args)

    def contains(self, *args):
        """
        contains(Instantiation self, DiscreteVar v) -> bool
        contains(Instantiation self, DiscreteVar v) -> bool
        """
        return _pyAgrum.Instantiation_contains(self, *args)

    def variablesSequence(self):
        """variablesSequence(Instantiation self) -> gum::Sequence< gum::DiscreteVariable const * > const &"""
        return _pyAgrum.Instantiation_variablesSequence(self)

    def empty(self):
        """empty(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_empty(self)

    def inOverflow(self):
        """inOverflow(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_inOverflow(self)

    def unsetOverflow(self):
        """unsetOverflow(Instantiation self)"""
        return _pyAgrum.Instantiation_unsetOverflow(self)

    def unsetEnd(self):
        """unsetEnd(Instantiation self)"""
        return _pyAgrum.Instantiation_unsetEnd(self)

    def end(self):
        """end(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_end(self)

    def rend(self):
        """rend(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_rend(self)

    def inc(self):
        """inc(Instantiation self)"""
        return _pyAgrum.Instantiation_inc(self)

    def dec(self):
        """dec(Instantiation self)"""
        return _pyAgrum.Instantiation_dec(self)

    def incIn(self, *args):
        """incIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_incIn(self, *args)

    def decIn(self, *args):
        """decIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_decIn(self, *args)

    def incOut(self, *args):
        """incOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_incOut(self, *args)

    def decOut(self, *args):
        """decOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_decOut(self, *args)

    def incNotVar(self, *args):
        """incNotVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_incNotVar(self, *args)

    def decNotVar(self, *args):
        """decNotVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_decNotVar(self, *args)

    def incVar(self, *args):
        """incVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_incVar(self, *args)

    def decVar(self, *args):
        """decVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_decVar(self, *args)

    def setFirst(self):
        """setFirst(Instantiation self)"""
        return _pyAgrum.Instantiation_setFirst(self)

    def setLast(self):
        """setLast(Instantiation self)"""
        return _pyAgrum.Instantiation_setLast(self)

    def setFirstIn(self, *args):
        """setFirstIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setFirstIn(self, *args)

    def setLastIn(self, *args):
        """setLastIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setLastIn(self, *args)

    def setFirstOut(self, *args):
        """setFirstOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setFirstOut(self, *args)

    def setLastOut(self, *args):
        """setLastOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setLastOut(self, *args)

    def setFirstNotVar(self, *args):
        """setFirstNotVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setFirstNotVar(self, *args)

    def setLastNotVar(self, *args):
        """setLastNotVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setLastNotVar(self, *args)

    def setFirstVar(self, *args):
        """setFirstVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setFirstVar(self, *args)

    def setLastVar(self, *args):
        """setLastVar(Instantiation self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setLastVar(self, *args)

    def actAsSlave(self, *args):
        """actAsSlave(Instantiation self, MultiDimAdressable aMD) -> bool"""
        return _pyAgrum.Instantiation_actAsSlave(self, *args)

    def forgetMaster(self):
        """forgetMaster(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_forgetMaster(self)

    def isSlave(self):
        """isSlave(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_isSlave(self)

    def isMaster(self, *args):
        """
        isMaster(Instantiation self, MultiDimAdressable m) -> bool
        isMaster(Instantiation self, MultiDimAdressable m) -> bool
        """
        return _pyAgrum.Instantiation_isMaster(self, *args)

    def synchronizeWithMaster(self, *args):
        """synchronizeWithMaster(Instantiation self, MultiDimAdressable m)"""
        return _pyAgrum.Instantiation_synchronizeWithMaster(self, *args)

    def addWithMaster(self, *args):
        """addWithMaster(Instantiation self, MultiDimAdressable m, DiscreteVar v)"""
        return _pyAgrum.Instantiation_addWithMaster(self, *args)

    def eraseWithMaster(self, *args):
        """eraseWithMaster(Instantiation self, MultiDimAdressable m, DiscreteVar v)"""
        return _pyAgrum.Instantiation_eraseWithMaster(self, *args)

    def __iadd__(self, *args):
        """__iadd__(Instantiation self, gum::Id depl) -> Instantiation"""
        return _pyAgrum.Instantiation___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(Instantiation self, gum::Id depl) -> Instantiation"""
        return _pyAgrum.Instantiation___isub__(self, *args)

    def hamming(self):
        """hamming(Instantiation self) -> gum::Idx"""
        return _pyAgrum.Instantiation_hamming(self)

    def __str__(self):
        """__str__(Instantiation self) -> std::string"""
        return _pyAgrum.Instantiation___str__(self)

    def reorder(self, *args):
        """
        reorder(Instantiation self, gum::Sequence< gum::DiscreteVariable const * > const & v)
        reorder(Instantiation self, Instantiation i)
        """
        return _pyAgrum.Instantiation_reorder(self, *args)

Instantiation_swigregister = _pyAgrum.Instantiation_swigregister
Instantiation_swigregister(Instantiation)

GUM_DEFAULT_ITERATOR_NUMBER = _pyAgrum.GUM_DEFAULT_ITERATOR_NUMBER
class DAGmodel(_object):
    """Proxy of C++ gum::DAGmodel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DAGmodel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DAGmodel, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_DAGmodel
    __del__ = lambda self : None;
    def property(self, *args):
        """property(DAGmodel self, std::string const & name) -> std::string const &"""
        return _pyAgrum.DAGmodel_property(self, *args)

    def setProperty(self, *args):
        """setProperty(DAGmodel self, std::string const & name, std::string const & value)"""
        return _pyAgrum.DAGmodel_setProperty(self, *args)

    def dag(self):
        """dag(DAGmodel self) -> DAG"""
        return _pyAgrum.DAGmodel_dag(self)

    def variableNodeMap(self):
        """variableNodeMap(DAGmodel self) -> VariableNodeMap"""
        return _pyAgrum.DAGmodel_variableNodeMap(self)

    def __len__(self):
        """__len__(DAGmodel self) -> gum::Size"""
        return _pyAgrum.DAGmodel___len__(self)

    def sizeArcs(self):
        """sizeArcs(DAGmodel self) -> gum::Size"""
        return _pyAgrum.DAGmodel_sizeArcs(self)

    def nbrArcs(self):
        """nbrArcs(DAGmodel self) -> gum::Size"""
        print("WARNING : pyAgrum.DAGmodel.nbrArcs is deprecated. Please use pyAgrum.BayesNet.sizeArcs")


        return _pyAgrum.DAGmodel_nbrArcs(self)

    def empty(self):
        """empty(DAGmodel self) -> bool"""
        return _pyAgrum.DAGmodel_empty(self)

    def nodes(self):
        """nodes(DAGmodel self) -> NodeGraphPart"""
        return _pyAgrum.DAGmodel_nodes(self)

    def variable(self, *args):
        """variable(DAGmodel self, gum::NodeId id) -> DiscreteVar"""
        return _pyAgrum.DAGmodel_variable(self, *args)

    def nodeId(self, *args):
        """nodeId(DAGmodel self, DiscreteVar var) -> gum::NodeId"""
        return _pyAgrum.DAGmodel_nodeId(self, *args)

    def idFromName(self, *args):
        """idFromName(DAGmodel self, std::string const & name) -> gum::NodeId"""
        return _pyAgrum.DAGmodel_idFromName(self, *args)

    def variableFromName(self, *args):
        """variableFromName(DAGmodel self, std::string const & name) -> DiscreteVar"""
        return _pyAgrum.DAGmodel_variableFromName(self, *args)

    def completeInstantiation(self, *args):
        """completeInstantiation(DAGmodel self, Instantiation I)"""
        return _pyAgrum.DAGmodel_completeInstantiation(self, *args)

    def arcs(self):
        """arcs(DAGmodel self) -> gum::ArcSet const &"""
        return _pyAgrum.DAGmodel_arcs(self)

    def moralGraph(self, clear=True):
        """
        moralGraph(DAGmodel self, bool clear=True) -> UndiGraph
        moralGraph(DAGmodel self) -> UndiGraph
        """
        return _pyAgrum.DAGmodel_moralGraph(self, clear)

    def topologicalOrder(self, clear=True):
        """
        topologicalOrder(DAGmodel self, bool clear=True) -> gum::Sequence< gum::NodeId > const
        topologicalOrder(DAGmodel self) -> gum::Sequence< gum::NodeId > const &
        """
        return _pyAgrum.DAGmodel_topologicalOrder(self, clear)

    def log10DomainSize(self):
        """log10DomainSize(DAGmodel self) -> double"""
        return _pyAgrum.DAGmodel_log10DomainSize(self)

DAGmodel_swigregister = _pyAgrum.DAGmodel_swigregister
DAGmodel_swigregister(DAGmodel)
cvar = _pyAgrum.cvar
__list_end_safe = cvar.__list_end_safe
__list_end = cvar.__list_end


def randomDistribution_double(*args):
  """randomDistribution_double(gum::Size n) -> Vector_double"""
  return _pyAgrum.randomDistribution_double(*args)
class DiscretizedVar(DiscreteVar):
    """Proxy of C++ gum::DiscretizedVariable<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVar]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscretizedVar, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVar]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscretizedVar, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DiscretizedVariable<(float)> self, std::string const & aName, std::string const & aDesc) -> DiscretizedVar
        __init__(gum::DiscretizedVariable<(float)> self, DiscretizedVar aDRV) -> DiscretizedVar
        """
        if self.__class__ == DiscretizedVar:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_DiscretizedVar(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiscretizedVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(DiscretizedVar self) -> DiscreteVar"""
        return _pyAgrum.DiscretizedVar_clone(self)

    def varType(self):
        """varType(DiscretizedVar self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.DiscretizedVar_varType(self)

    def isTick(self, *args):
        """isTick(DiscretizedVar self, float const & aTick) -> bool"""
        return _pyAgrum.DiscretizedVar_isTick(self, *args)

    def addTick(self,*args):
      _pyAgrum.DiscretizedVar_addTick(self,*args)
      return self


    def eraseTicks(self):
        """eraseTicks(DiscretizedVar self)"""
        return _pyAgrum.DiscretizedVar_eraseTicks(self)

    def label(self, *args):
        """label(DiscretizedVar self, gum::Idx i) -> std::string const"""
        return _pyAgrum.DiscretizedVar_label(self, *args)

    def __len__(self):
        """__len__(DiscretizedVar self) -> gum::Size"""
        return _pyAgrum.DiscretizedVar___len__(self)

    def tick(self, *args):
        """tick(DiscretizedVar self, gum::Idx i) -> float const &"""
        return _pyAgrum.DiscretizedVar_tick(self, *args)

    def index(self, *args):
        """index(DiscretizedVar self, float const & aTarget) -> gum::Idx"""
        return _pyAgrum.DiscretizedVar_index(self, *args)

    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_DiscretizedVar(self)
        return weakref_proxy(self)
DiscretizedVar_swigregister = _pyAgrum.DiscretizedVar_swigregister
DiscretizedVar_swigregister(DiscretizedVar)

class MultiDimContainer_double(_object):
    """Proxy of C++ gum::MultiDimContainer<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimContainer_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimContainer_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimContainer_double
    __del__ = lambda self : None;
    def set(self, *args):
        """set(MultiDimContainer_double self, Instantiation i, double const & value)"""
        return _pyAgrum.MultiDimContainer_double_set(self, *args)

    def get(self, *args):
        """get(MultiDimContainer_double self, Instantiation i) -> double"""
        return _pyAgrum.MultiDimContainer_double_get(self, *args)

    def fill(self, *args):
        """fill(MultiDimContainer_double self, double const & d)"""
        return _pyAgrum.MultiDimContainer_double_fill(self, *args)

    def fillWith(self, *args):
        """fillWith(MultiDimContainer_double self, Vector_double v)"""
        return _pyAgrum.MultiDimContainer_double_fillWith(self, *args)

    def copyFrom(self, *args):
        """
        copyFrom(MultiDimContainer_double self, MultiDimContainer_double src, Instantiation p_i=(Instantiation *) 0)
        copyFrom(MultiDimContainer_double self, MultiDimContainer_double src)
        """
        return _pyAgrum.MultiDimContainer_double_copyFrom(self, *args)

    def copy(self, *args):
        """copy(MultiDimContainer_double self, MultiDimContainer_double src)"""
        return _pyAgrum.MultiDimContainer_double_copy(self, *args)

    def newFactory(self):
        """newFactory(MultiDimContainer_double self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimContainer_double_newFactory(self)

    def __str__(self):
        """__str__(MultiDimContainer_double self) -> std::string const"""
        return _pyAgrum.MultiDimContainer_double___str__(self)

    def toString(self, *args):
        """toString(MultiDimContainer_double self, Instantiation i) -> std::string const"""
        return _pyAgrum.MultiDimContainer_double_toString(self, *args)

    def __eq__(self, *args):
        """__eq__(MultiDimContainer_double self, MultiDimContainer_double p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(MultiDimContainer_double self, MultiDimContainer_double p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___ne__(self, *args)

    def beginMultipleChanges(self):
        """beginMultipleChanges(MultiDimContainer_double self)"""
        return _pyAgrum.MultiDimContainer_double_beginMultipleChanges(self)

    def endMultipleChanges(self, *args):
        """
        endMultipleChanges(MultiDimContainer_double self)
        endMultipleChanges(MultiDimContainer_double self, double const & arg2)
        """
        return _pyAgrum.MultiDimContainer_double_endMultipleChanges(self, *args)

MultiDimContainer_double_swigregister = _pyAgrum.MultiDimContainer_double_swigregister
MultiDimContainer_double_swigregister(MultiDimContainer_double)

class MultiDimImplementation_double(MultiDimContainer_double):
    """Proxy of C++ gum::MultiDimImplementation<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimImplementation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimImplementation_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimImplementation_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(MultiDimImplementation_double self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimImplementation_double_newFactory(self)

    def get(self, *args):
        """get(MultiDimImplementation_double self, Instantiation i) -> double"""
        return _pyAgrum.MultiDimImplementation_double_get(self, *args)

    def variablesSequence(self):
        """variablesSequence(MultiDimImplementation_double self) -> gum::Sequence< gum::DiscreteVariable const * > const &"""
        return _pyAgrum.MultiDimImplementation_double_variablesSequence(self)

    def name(self):
        """name(MultiDimImplementation_double self) -> std::string const &"""
        return _pyAgrum.MultiDimImplementation_double_name(self)

    def basename(self):
        """basename(MultiDimImplementation_double self) -> std::string const &"""
        return _pyAgrum.MultiDimImplementation_double_basename(self)

    def add(self, *args):
        """add(MultiDimImplementation_double self, DiscreteVar v)"""
        return _pyAgrum.MultiDimImplementation_double_add(self, *args)

    def erase(self, *args):
        """erase(MultiDimImplementation_double self, DiscreteVar v)"""
        return _pyAgrum.MultiDimImplementation_double_erase(self, *args)

    def nbrDim(self):
        """nbrDim(MultiDimImplementation_double self) -> gum::Idx"""
        return _pyAgrum.MultiDimImplementation_double_nbrDim(self)

    def domainSize(self):
        """domainSize(MultiDimImplementation_double self) -> gum::Size"""
        return _pyAgrum.MultiDimImplementation_double_domainSize(self)

    def realSize(self):
        """realSize(MultiDimImplementation_double self) -> gum::Size"""
        return _pyAgrum.MultiDimImplementation_double_realSize(self)

    def compressionRate(self):
        """compressionRate(MultiDimImplementation_double self) -> float"""
        return _pyAgrum.MultiDimImplementation_double_compressionRate(self)

    def variable(self, *args):
        """variable(MultiDimImplementation_double self, gum::Idx i) -> DiscreteVar"""
        return _pyAgrum.MultiDimImplementation_double_variable(self, *args)

    def pos(self, *args):
        """pos(MultiDimImplementation_double self, DiscreteVar v) -> gum::Idx"""
        return _pyAgrum.MultiDimImplementation_double_pos(self, *args)

    def contains(self, *args):
        """contains(MultiDimImplementation_double self, DiscreteVar v) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_contains(self, *args)

    def empty(self):
        """empty(MultiDimImplementation_double self) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_empty(self)

    def getMasterRef(self, *args):
        """
        getMasterRef(MultiDimImplementation_double self) -> MultiDimAdressable
        getMasterRef(MultiDimImplementation_double self) -> MultiDimAdressable
        """
        return _pyAgrum.MultiDimImplementation_double_getMasterRef(self, *args)

    def registerSlave(self, *args):
        """registerSlave(MultiDimImplementation_double self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_registerSlave(self, *args)

    def unregisterSlave(self, *args):
        """unregisterSlave(MultiDimImplementation_double self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_unregisterSlave(self, *args)

    def beginMultipleChanges(self):
        """beginMultipleChanges(MultiDimImplementation_double self)"""
        return _pyAgrum.MultiDimImplementation_double_beginMultipleChanges(self)

    def endMultipleChanges(self, *args):
        """
        endMultipleChanges(MultiDimImplementation_double self)
        endMultipleChanges(MultiDimImplementation_double self, double const & arg2)
        """
        return _pyAgrum.MultiDimImplementation_double_endMultipleChanges(self, *args)

MultiDimImplementation_double_swigregister = _pyAgrum.MultiDimImplementation_double_swigregister
MultiDimImplementation_double_swigregister(MultiDimImplementation_double)

class MultiDimDecorator_double(MultiDimContainer_double):
    """Proxy of C++ gum::MultiDimDecorator<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimDecorator_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimDecorator_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimDecorator_double
    __del__ = lambda self : None;
    def domainSize(self):
        """domainSize(MultiDimDecorator_double self) -> gum::Size"""
        return _pyAgrum.MultiDimDecorator_double_domainSize(self)

    def add(self, *args):
        """add(MultiDimDecorator_double self, DiscreteVar v)"""
        val = _pyAgrum.MultiDimDecorator_double_add(self, *args)
        self.__fill_distrib__()


        return val

    def variablesSequence(self):
        varlist = []
        for i in range(0, self.nbrDim()):
            varlist.append(self.variable(i))
        return varlist


    def nbrDim(self):
        """nbrDim(MultiDimDecorator_double self) -> gum::Idx"""
        return _pyAgrum.MultiDimDecorator_double_nbrDim(self)

    def remove(self, *args):
        """remove(MultiDimDecorator_double self, DiscreteVar var)"""
        return _pyAgrum.MultiDimDecorator_double_remove(self, *args)

    def variable(self, *args):
        """variable(MultiDimDecorator_double self, gum::Idx arg2) -> DiscreteVar"""
        return _pyAgrum.MultiDimDecorator_double_variable(self, *args)

    def pos(self, *args):
        """pos(MultiDimDecorator_double self, DiscreteVar arg2) -> gum::Idx"""
        return _pyAgrum.MultiDimDecorator_double_pos(self, *args)

    def contains(self, *args):
        """contains(MultiDimDecorator_double self, DiscreteVar arg2) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_contains(self, *args)

    def empty(self):
        """empty(MultiDimDecorator_double self) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_empty(self)

    def unregisterSlave(self, *args):
        """unregisterSlave(MultiDimDecorator_double self, Instantiation arg2) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_unregisterSlave(self, *args)

    def registerSlave(self, *args):
        """registerSlave(MultiDimDecorator_double self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_registerSlave(self, *args)

    def fill(self, *args):
        """fill(MultiDimDecorator_double self, double const & d)"""
        return _pyAgrum.MultiDimDecorator_double_fill(self, *args)

    def content(self, *args):
        """
        content(MultiDimDecorator_double self) -> MultiDimImplementation_double
        content(MultiDimDecorator_double self) -> MultiDimImplementation_double
        """
        return _pyAgrum.MultiDimDecorator_double_content(self, *args)

    def newFactory(self):
        """newFactory(MultiDimDecorator_double self) -> MultiDimDecorator_double"""
        return _pyAgrum.MultiDimDecorator_double_newFactory(self)

    def changeNotification(self, *args):
        """changeNotification(MultiDimDecorator_double self, Instantiation i, DiscreteVar var, gum::Idx const & oldval, gum::Idx const & newval)"""
        return _pyAgrum.MultiDimDecorator_double_changeNotification(self, *args)

    def setChangeNotification(self, *args):
        """setChangeNotification(MultiDimDecorator_double self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setChangeNotification(self, *args)

    def setFirstNotification(self, *args):
        """setFirstNotification(MultiDimDecorator_double self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setFirstNotification(self, *args)

    def setLastNotification(self, *args):
        """setLastNotification(MultiDimDecorator_double self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setLastNotification(self, *args)

    def setIncNotification(self, *args):
        """setIncNotification(MultiDimDecorator_double self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setIncNotification(self, *args)

    def setDecNotification(self, *args):
        """setDecNotification(MultiDimDecorator_double self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setDecNotification(self, *args)

    def notifyChange(self):
        """notifyChange(MultiDimDecorator_double self)"""
        return _pyAgrum.MultiDimDecorator_double_notifyChange(self)

    def getMasterRef(self, *args):
        """
        getMasterRef(MultiDimDecorator_double self) -> MultiDimImplementation_double
        getMasterRef(MultiDimDecorator_double self) -> MultiDimImplementation_double
        """
        return _pyAgrum.MultiDimDecorator_double_getMasterRef(self, *args)

    def beginMultipleChanges(self):
        """beginMultipleChanges(MultiDimDecorator_double self)"""
        return _pyAgrum.MultiDimDecorator_double_beginMultipleChanges(self)

    def endMultipleChanges(self, *args):
        """
        endMultipleChanges(MultiDimDecorator_double self)
        endMultipleChanges(MultiDimDecorator_double self, double const & arg2)
        """
        return _pyAgrum.MultiDimDecorator_double_endMultipleChanges(self, *args)

    def toString(self, *args):
        """toString(MultiDimDecorator_double self, Instantiation i) -> std::string const"""
        return _pyAgrum.MultiDimDecorator_double_toString(self, *args)

    def __str__(self):
        """__str__(MultiDimDecorator_double self) -> std::string const"""
        return _pyAgrum.MultiDimDecorator_double___str__(self)

    def homothetic(self, *args):
        """homothetic(MultiDimDecorator_double self, double alpha, double (*)(double const,double const) mul)"""
        return _pyAgrum.MultiDimDecorator_double_homothetic(self, *args)

    def fold(self, *args):
        """fold(MultiDimDecorator_double self, double (*)(double const,double const) add) -> double"""
        return _pyAgrum.MultiDimDecorator_double_fold(self, *args)

    def set(self, *args):
        """set(MultiDimDecorator_double self, Instantiation i, double const & value)"""
        return _pyAgrum.MultiDimDecorator_double_set(self, *args)

    def get(self, *args):
        """get(MultiDimDecorator_double self, Instantiation i) -> double"""
        return _pyAgrum.MultiDimDecorator_double_get(self, *args)

MultiDimDecorator_double_swigregister = _pyAgrum.MultiDimDecorator_double_swigregister
MultiDimDecorator_double_swigregister(MultiDimDecorator_double)

class MultiDimWithOffset_double(MultiDimImplementation_double):
    """Proxy of C++ gum::MultiDimWithOffset<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimImplementation_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimWithOffset_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimImplementation_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimWithOffset_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimWithOffset_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(MultiDimWithOffset_double self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimWithOffset_double_newFactory(self)

    def add(self, *args):
        """add(MultiDimWithOffset_double self, DiscreteVar v)"""
        return _pyAgrum.MultiDimWithOffset_double_add(self, *args)

    def erase(self, *args):
        """erase(MultiDimWithOffset_double self, DiscreteVar v)"""
        return _pyAgrum.MultiDimWithOffset_double_erase(self, *args)

    def fill(self, *args):
        """fill(MultiDimWithOffset_double self, double const & d)"""
        return _pyAgrum.MultiDimWithOffset_double_fill(self, *args)

    def toString(self, *args):
        """toString(MultiDimWithOffset_double self, Instantiation i) -> std::string const"""
        return _pyAgrum.MultiDimWithOffset_double_toString(self, *args)

    def changeNotification(self, *args):
        """changeNotification(MultiDimWithOffset_double self, Instantiation i, DiscreteVar var, gum::Idx const & oldval, gum::Idx const & newval)"""
        return _pyAgrum.MultiDimWithOffset_double_changeNotification(self, *args)

    def setChangeNotification(self, *args):
        """setChangeNotification(MultiDimWithOffset_double self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setChangeNotification(self, *args)

    def setFirstNotification(self, *args):
        """setFirstNotification(MultiDimWithOffset_double self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setFirstNotification(self, *args)

    def setLastNotification(self, *args):
        """setLastNotification(MultiDimWithOffset_double self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setLastNotification(self, *args)

    def setIncNotification(self, *args):
        """setIncNotification(MultiDimWithOffset_double self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setIncNotification(self, *args)

    def setDecNotification(self, *args):
        """setDecNotification(MultiDimWithOffset_double self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setDecNotification(self, *args)

    def registerSlave(self, *args):
        """registerSlave(MultiDimWithOffset_double self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimWithOffset_double_registerSlave(self, *args)

    def unregisterSlave(self, *args):
        """unregisterSlave(MultiDimWithOffset_double self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimWithOffset_double_unregisterSlave(self, *args)

    def toOffset(self, *args):
        """toOffset(MultiDimWithOffset_double self, Instantiation i) -> gum::Size"""
        return _pyAgrum.MultiDimWithOffset_double_toOffset(self, *args)

    def fromOffset(self, *args):
        """fromOffset(MultiDimWithOffset_double self, Instantiation i, gum::Size offset) -> Instantiation"""
        return _pyAgrum.MultiDimWithOffset_double_fromOffset(self, *args)

MultiDimWithOffset_double_swigregister = _pyAgrum.MultiDimWithOffset_double_swigregister
MultiDimWithOffset_double_swigregister(MultiDimWithOffset_double)

class MultiDimArray_double(MultiDimWithOffset_double):
    """Proxy of C++ gum::MultiDimArray<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimWithOffset_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimArray_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimWithOffset_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimArray_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::MultiDimArray<(double)> self) -> MultiDimArray_double
        __init__(gum::MultiDimArray<(double)> self, MultiDimArray_double src) -> MultiDimArray_double
        """
        this = _pyAgrum.new_MultiDimArray_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_MultiDimArray_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(MultiDimArray_double self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimArray_double_newFactory(self)

    def add(self, *args):
        """add(MultiDimArray_double self, DiscreteVar v)"""
        return _pyAgrum.MultiDimArray_double_add(self, *args)

    def erase(self, *args):
        """erase(MultiDimArray_double self, DiscreteVar v)"""
        return _pyAgrum.MultiDimArray_double_erase(self, *args)

    def realSize(self):
        """realSize(MultiDimArray_double self) -> gum::Size"""
        return _pyAgrum.MultiDimArray_double_realSize(self)

    def fill(self, *args):
        """fill(MultiDimArray_double self, double const & d)"""
        return _pyAgrum.MultiDimArray_double_fill(self, *args)

    def unsafeGet(self, *args):
        """unsafeGet(MultiDimArray_double self, gum::Idx offset) -> double const &"""
        return _pyAgrum.MultiDimArray_double_unsafeGet(self, *args)

    def getByOffset(self, *args):
        """getByOffset(MultiDimArray_double self, gum::Idx offset) -> double const &"""
        return _pyAgrum.MultiDimArray_double_getByOffset(self, *args)

    def unsafeSet(self, *args):
        """unsafeSet(MultiDimArray_double self, gum::Idx offset, double const & arg3)"""
        return _pyAgrum.MultiDimArray_double_unsafeSet(self, *args)

    def setByOffset(self, *args):
        """setByOffset(MultiDimArray_double self, gum::Idx offset, double const & arg3)"""
        return _pyAgrum.MultiDimArray_double_setByOffset(self, *args)

    def name(self):
        """name(MultiDimArray_double self) -> std::string const &"""
        return _pyAgrum.MultiDimArray_double_name(self)

MultiDimArray_double_swigregister = _pyAgrum.MultiDimArray_double_swigregister
MultiDimArray_double_swigregister(MultiDimArray_double)

class Potential_double(MultiDimDecorator_double):
    """Proxy of C++ gum::Potential<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimDecorator_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Potential_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimDecorator_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Potential_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Potential<(double)> self) -> Potential_double
        __init__(gum::Potential<(double)> self, MultiDimImplementation_double aContent) -> Potential_double
        __init__(gum::Potential<(double)> self, Potential_double src) -> Potential_double
        __init__(gum::Potential<(double)> self, MultiDimImplementation_double aContent, MultiDimContainer_double src) -> Potential_double
        """
        if self.__class__ == Potential_double:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_Potential_double(_self, *args)
        try: self.this.append(this)
        except: self.this = this
        self.__fill_distrib__()



    __swig_destroy__ = _pyAgrum.delete_Potential_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(Potential_double self) -> Potential_double"""
        return _pyAgrum.Potential_double_newFactory(self)

    def normalize(self):
        """normalize(Potential_double self) -> Potential_double"""
        return _pyAgrum.Potential_double_normalize(self)

    def marginalize(self, *args):
        """marginalize(Potential_double self, Potential_double p) -> Potential_double"""
        return _pyAgrum.Potential_double_marginalize(self, *args)

    def multiplicate(self, *args):
        """multiplicate(Potential_double self, Potential_double p1, Potential_double p2)"""
        return _pyAgrum.Potential_double_multiplicate(self, *args)

    def multiplicateBy(self, *args):
        """multiplicateBy(Potential_double self, Potential_double p1) -> Potential_double"""
        return _pyAgrum.Potential_double_multiplicateBy(self, *args)

    def sum(self):
        """sum(Potential_double self) -> double const"""
        return _pyAgrum.Potential_double_sum(self)

    def _swap(self, *args):
        """_swap(Potential_double self, DiscreteVar x, DiscreteVar y)"""
        return _pyAgrum.Potential_double__swap(self, *args)

    def __mul__(self,p2):
        """
        return self * p2
        """
        p=Potential()
        p.multiplicate(self,p2)
        return p

    def eliminates(self,var):
        """
        eliminates a variable in the Potential. Returns the new Potential or self if the variable is not in self.
        @warning : returns a list with only one scalar if eliminates remove the last variable
        """
        if var.name() in self.var_names:
            q=Potential()
            for i in range(self.nbrDim()):
                if self.variable(i)!=var:
                    q.add(self.variable(i))
            if q.nbrDim()>0:
                q.marginalize(self)
            else:
                q=[self.sum()]
            return q
        else:
            return self

    def __indexfromdict__(self, id_dict):
        index = []
        #for id in id_dict:
        #    if not id in self._var_names:
        #        raise IndexError("\"%s\" is not a variable of this table !"
        #                         %(id))
        for name, dim in zip(self._var_names, self._var_dims):
            if name in id_dict:
                id_value = id_dict[name]
                if isinstance(id_value, str):
                    # id_value is a label of a LabelizedVar
                    i = self._var_names.index(name)
                    var = self.variable(len(self._var_names) - 1 - i)
                    id_value = var[id_value]
                if id_value >= dim:
                    raise IndexError("\"%s\" size is %d !"%(name, dim))
                index.append(id_value)
            else:
                index.append(slice(None, None, None)) # equivalent to ':'
        return tuple(index)


    def __str__(self):
        self.__fill_distrib__()
        return self.__distrib__.__str__()


    def tolist(self):
        self.__fill_distrib__()
        return self.__distrib__.tolist()


    def toarray(self):
        return numpy.array(self.tolist())


    def __getitem__(self, id):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        return self.__distrib__[id_slice]


    def __setitem__(self, id, value):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        self.__distrib__[id_slice] = value
        self.fillWith(self.__distrib__.reshape(self.__distrib__.size).tolist())


    @property
    def var_names(self):
        self.__fill_distrib__()
        return self._var_names


    @property
    def var_dims(self):
        self.__fill_distrib__()
        return self._var_dims


    def __fill_distrib__(self):
        self._var_names = []
        self._var_dims = []
        content = []
        if self.empty():
            self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
            return
        i = Instantiation(self)
        i.setFirst
        while not i.end():
            content.append(self.get(i))
            i.inc()
        self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
        for var in self.variablesSequence():
            self._var_names.append(var.name())
            self._var_dims.append(len(var))
        self._var_names.reverse()
        self._var_dims.reverse()
        self.__distrib__.shape = tuple(self._var_dims)


    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_Potential_double(self)
        return weakref_proxy(self)
    def _get(self, *args):
        """_get(Potential_double self, Instantiation i) -> double &"""
        return _pyAgrum.Potential_double__get(self, *args)

Potential_double_swigregister = _pyAgrum.Potential_double_swigregister
Potential_double_swigregister(Potential_double)

class IBayesNet_double(DAGmodel):
    """Proxy of C++ gum::IBayesNet<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [DAGmodel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IBayesNet_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DAGmodel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IBayesNet_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_IBayesNet_double
    __del__ = lambda self : None;
    def cpt(self, *args):
        """cpt(IBayesNet_double self, gum::NodeId varId) -> Potential_double"""
        return _pyAgrum.IBayesNet_double_cpt(self, *args)

    def variableNodeMap(self):
        """variableNodeMap(IBayesNet_double self) -> VariableNodeMap"""
        return _pyAgrum.IBayesNet_double_variableNodeMap(self)

    def variable(self, *args):
        """variable(IBayesNet_double self, gum::NodeId id) -> DiscreteVar"""
        return _pyAgrum.IBayesNet_double_variable(self, *args)

    def nodeId(self, *args):
        """nodeId(IBayesNet_double self, DiscreteVar var) -> gum::NodeId"""
        return _pyAgrum.IBayesNet_double_nodeId(self, *args)

    def idFromName(self, *args):
        """idFromName(IBayesNet_double self, std::string const & name) -> gum::NodeId"""
        return _pyAgrum.IBayesNet_double_idFromName(self, *args)

    def variableFromName(self, *args):
        """variableFromName(IBayesNet_double self, std::string const & name) -> DiscreteVar"""
        return _pyAgrum.IBayesNet_double_variableFromName(self, *args)

    def jointProbability(self, *args):
        """jointProbability(IBayesNet_double self, Instantiation i) -> double"""
        return _pyAgrum.IBayesNet_double_jointProbability(self, *args)

    def log2JointProbability(self, *args):
        """log2JointProbability(IBayesNet_double self, Instantiation i) -> double"""
        return _pyAgrum.IBayesNet_double_log2JointProbability(self, *args)

    def __eq__(self, *args):
        """__eq__(IBayesNet_double self, IBayesNet_double src) -> bool"""
        return _pyAgrum.IBayesNet_double___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(IBayesNet_double self, IBayesNet_double src) -> bool"""
        return _pyAgrum.IBayesNet_double___ne__(self, *args)

    def dim(self):
        """dim(IBayesNet_double self) -> gum::Idx"""
        return _pyAgrum.IBayesNet_double_dim(self)

    def toDot(self):
        """toDot(IBayesNet_double self) -> std::string"""
        return _pyAgrum.IBayesNet_double_toDot(self)

    def __str__(self):
        """__str__(IBayesNet_double self) -> std::string"""
        return _pyAgrum.IBayesNet_double___str__(self)

IBayesNet_double_swigregister = _pyAgrum.IBayesNet_double_swigregister
IBayesNet_double_swigregister(IBayesNet_double)

class BayesNet_double(IBayesNet_double):
    """Proxy of C++ gum::BayesNet<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [IBayesNet_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNet_double, name, value)
    __swig_getmethods__ = {}
    for _s in [IBayesNet_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNet_double, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_BayesNet_double
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(gum::BayesNet<(double)> self) -> BayesNet_double
        __init__(gum::BayesNet<(double)> self, std::string name) -> BayesNet_double
        __init__(gum::BayesNet<(double)> self, BayesNet_double source) -> BayesNet_double
        """
        this = _pyAgrum.new_BayesNet_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def cpt(self, *args):
        """cpt(BayesNet_double self, gum::NodeId varId) -> Potential_double"""
        val = _pyAgrum.BayesNet_double_cpt(self, *args)
        val.__fill_distrib__()


        return val

    def variableNodeMap(self):
        """variableNodeMap(BayesNet_double self) -> VariableNodeMap"""
        return _pyAgrum.BayesNet_double_variableNodeMap(self)

    def toDot(self):
        """toDot(BayesNet_double self) -> std::string"""
        return _pyAgrum.BayesNet_double_toDot(self)

    def add(self, *args):
        """
        add(BayesNet_double self, DiscreteVar variable) -> gum::NodeId
        add(BayesNet_double self, DiscreteVar variable, MultiDimImplementation_double aContent) -> gum::NodeId
        add(BayesNet_double self, DiscreteVar variable, gum::NodeId id) -> gum::NodeId
        add(BayesNet_double self, DiscreteVar variable, MultiDimImplementation_double aContent, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_add(self, *args)

    def erase(self, *args):
        """
        erase(BayesNet_double self, gum::NodeId id)
        erase(BayesNet_double self, DiscreteVar var)
        """
        return _pyAgrum.BayesNet_double_erase(self, *args)

    def variable(self, *args):
        """variable(BayesNet_double self, gum::NodeId id) -> DiscreteVar"""
        return _pyAgrum.BayesNet_double_variable(self, *args)

    def changeVariableName(self, *args):
        """changeVariableName(BayesNet_double self, gum::NodeId id, std::string const & new_name)"""
        return _pyAgrum.BayesNet_double_changeVariableName(self, *args)

    def nodeId(self, *args):
        """nodeId(BayesNet_double self, DiscreteVar var) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_nodeId(self, *args)

    def idFromName(self, *args):
        """idFromName(BayesNet_double self, std::string const & name) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_idFromName(self, *args)

    def variableFromName(self, *args):
        """variableFromName(BayesNet_double self, std::string const & name) -> DiscreteVar"""
        return _pyAgrum.BayesNet_double_variableFromName(self, *args)

    def insertArc(self, *args):
        """insertArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head)"""
        print("WARNING : pyAgrum.BayesNet.insertArc is deprecated. Please use pyAgrum.BayesNet.addArc")


        return _pyAgrum.BayesNet_double_insertArc(self, *args)

    def addArc(self, *args):
        """addArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head)"""
        return _pyAgrum.BayesNet_double_addArc(self, *args)

    def eraseArc(self, *args):
        """
        eraseArc(BayesNet_double self, Arc arc)
        eraseArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head)
        """
        return _pyAgrum.BayesNet_double_eraseArc(self, *args)

    def beginTopologyTransformation(self):
        """beginTopologyTransformation(BayesNet_double self)"""
        return _pyAgrum.BayesNet_double_beginTopologyTransformation(self)

    def endTopologyTransformation(self):
        """endTopologyTransformation(BayesNet_double self)"""
        return _pyAgrum.BayesNet_double_endTopologyTransformation(self)

    def reverseArc(self, *args):
        """
        reverseArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head)
        reverseArc(BayesNet_double self, Arc arc)
        """
        return _pyAgrum.BayesNet_double_reverseArc(self, *args)

    def addNoisyOR(self, *args):
        """
        addNoisyOR(BayesNet_double self, DiscreteVar variable, double externalWeight) -> gum::NodeId
        addNoisyOR(BayesNet_double self, DiscreteVar variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyOR(self, *args)

    def addNoisyORNet(self, *args):
        """
        addNoisyORNet(BayesNet_double self, DiscreteVar variable, double externalWeight) -> gum::NodeId
        addNoisyORNet(BayesNet_double self, DiscreteVar variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORNet(self, *args)

    def addNoisyORCompound(self, *args):
        """
        addNoisyORCompound(BayesNet_double self, DiscreteVar variable, double externalWeight) -> gum::NodeId
        addNoisyORCompound(BayesNet_double self, DiscreteVar variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORCompound(self, *args)

    def addNoisyAND(self, *args):
        """
        addNoisyAND(BayesNet_double self, DiscreteVar variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        addNoisyAND(BayesNet_double self, DiscreteVar variable, double externalWeight) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyAND(self, *args)

    def addOR(self, *args):
        """addOR(BayesNet_double self, DiscreteVar variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addOR(self, *args)

    def addAND(self, *args):
        """addAND(BayesNet_double self, DiscreteVar variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addAND(self, *args)

    def insertWeightedArc(self, *args):
        """insertWeightedArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head, double causalWeight)"""
        print("WARNING : pyAgrum.BayesNet.insertWeightedArc is deprecated. Please use pyAgrum.BayesNet.addWeightedArc")


        return _pyAgrum.BayesNet_double_insertWeightedArc(self, *args)

    def addWeightedArc(self, *args):
        """addWeightedArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head, double causalWeight)"""
        return _pyAgrum.BayesNet_double_addWeightedArc(self, *args)

    def generateCPTs(self):
        """generateCPTs(BayesNet_double self)"""
        return _pyAgrum.BayesNet_double_generateCPTs(self)

    def changePotential(self, *args):
        """changePotential(BayesNet_double self, gum::NodeId id, Potential_double newPot)"""
        return _pyAgrum.BayesNet_double_changePotential(self, *args)

    def dag(self):
        """dag(BayesNet_double self) -> DAG"""
        return _pyAgrum.BayesNet_double_dag(self)

    def nodes(self):
        """nodes(BayesNet_double self) -> NodeGraphPart"""
        return _pyAgrum.BayesNet_double_nodes(self)

    def log10DomainSize(self):
        """log10DomainSize(BayesNet_double self) -> double"""
        return _pyAgrum.BayesNet_double_log10DomainSize(self)

    def names(self):
        """names(BayesNet_double self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_names(self)

    def ids(self):
        """ids(BayesNet_double self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_ids(self)

    def arcs(self):
        """arcs(BayesNet_double self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_arcs(self)

    def parents(self, *args):
        """parents(BayesNet_double self, gum::NodeId const id) -> PyObject *"""
        return _pyAgrum.BayesNet_double_parents(self, *args)

    def children(self, *args):
        """children(BayesNet_double self, gum::NodeId const id) -> PyObject *"""
        return _pyAgrum.BayesNet_double_children(self, *args)

    def loadBIF(self, *args):
        """
        loadBIF(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadBIF(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadBIF(self, *args)

    def saveBIF(self, *args):
        """saveBIF(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveBIF(self, *args)

    def loadDSL(self, *args):
        """
        loadDSL(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadDSL(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadDSL(self, *args)

    def saveDSL(self, *args):
        """saveDSL(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveDSL(self, *args)

    def loadNET(self, *args):
        """
        loadNET(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadNET(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadNET(self, *args)

    def saveNET(self, *args):
        """saveNET(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveNET(self, *args)

    def loadBIFXML(self, *args):
        """
        loadBIFXML(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadBIFXML(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadBIFXML(self, *args)

    def saveBIFXML(self, *args):
        """saveBIFXML(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveBIFXML(self, *args)

BayesNet_double_swigregister = _pyAgrum.BayesNet_double_swigregister
BayesNet_double_swigregister(BayesNet_double)

class BayesNetInference_double(_object):
    """Proxy of C++ gum::BayesNetInference<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNetInference_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNetInference_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_BayesNetInference_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(BayesNetInference_double self)"""
        return _pyAgrum.BayesNetInference_double_makeInference(self)

    def marginal(self, *args):
        """marginal(BayesNetInference_double self, gum::NodeId id) -> Potential_double"""
        val = _pyAgrum.BayesNetInference_double_marginal(self, *args)
        val.__fill_distrib__()


        return val

    def insertEvidence(self, *args):
        """insertEvidence(BayesNetInference_double self, gum::List< gum::Potential< double > const * > const & pot_list)"""
        return _pyAgrum.BayesNetInference_double_insertEvidence(self, *args)

    def eraseEvidence(self, *args):
        """eraseEvidence(BayesNetInference_double self, Potential_double e)"""
        return _pyAgrum.BayesNetInference_double_eraseEvidence(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(BayesNetInference_double self)"""
        return _pyAgrum.BayesNetInference_double_eraseAllEvidence(self)

    def bn(self):
        """bn(BayesNetInference_double self) -> IBayesNet_double"""
        return _pyAgrum.BayesNetInference_double_bn(self)

    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be dict, not %s"
                            %(type(evidces)))
        bn = self.bn()
        

        # set evidences
        self.list_pot = []
        for var_name, evidce in evidces.iteritems():
            pot = Potential_double()

            if isinstance(var_name, int):
                var = bn.variable(var_name)
            elif isinstance(var_name, str):
                var = bn.variableFromName(var_name)
            else:
                raise TypeError('values of the dict must be int or string')

            pot.add(var)
            if isinstance(evidce, (int, float, str)):
                pot[:] = 0
                # determine the var type
                try:
                    cast_var = var.toLabelizedVar()
                    if isinstance(evidce, int):
                        index = evidce
                    elif isinstance(evidce, str):
                        index = cast_var[evidce]
                    else:
                        raise TypeError('values of the dict must be int or string')
                except RuntimeError:
                    try:
                        cast_var = var.toRangeVar()
                        if isinstance(evidce, int):
                            index = cast_var[str(evidce)]
                        elif isinstance(evidce, str):
                            index = cast_var[evidce]
                        else:
                            raise TypeError('values of the dict must be int or string')
                    except RuntimeError:
                        cast_var = var.toDiscretizedVar()
                        if isinstance(evidce, float):
                            index = cast_var.index(evidce)
                        elif isinstance(evidce, str):
                            index = cast_var.index(float(evidce))
                        else:
                            raise TypeError('values of the dict must be float or string')
                pot[index] = 1
            elif isinstance(evidce, (list, tuple)):
                pot[:] = evidce
            else:
                raise TypeError('dict values must be number, string or sequence')
            self.list_pot.append(pot)
            
        self.eraseAllEvidence()
        self._setEvidence(self.list_pot)


    def _setEvidence(self, *args):
        """_setEvidence(BayesNetInference_double self, PyObject * evidences)"""
        return _pyAgrum.BayesNetInference_double__setEvidence(self, *args)

BayesNetInference_double_swigregister = _pyAgrum.BayesNetInference_double_swigregister
BayesNetInference_double_swigregister(BayesNetInference_double)

class LazyPropagation_double(BayesNetInference_double):
    """Proxy of C++ gum::LazyPropagation<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LazyPropagation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LazyPropagation_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::LazyPropagation<(double)> self, IBayesNet_double BN) -> LazyPropagation_double
        __init__(gum::LazyPropagation<(double)> self, IBayesNet_double BN, std::vector< gum::NodeId,std::allocator< gum::NodeId > > const & elim_order) -> LazyPropagation_double
        """
        if self.__class__ == LazyPropagation_double:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_LazyPropagation_double(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_LazyPropagation_double
    __del__ = lambda self : None;
    def insertEvidence(self, *args):
        """insertEvidence(LazyPropagation_double self, gum::List< gum::Potential< double > const * > const & arg0)"""
        return _pyAgrum.LazyPropagation_double_insertEvidence(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(LazyPropagation_double self)"""
        return _pyAgrum.LazyPropagation_double_eraseAllEvidence(self)

    def eraseEvidence(self, *args):
        """eraseEvidence(LazyPropagation_double self, Potential_double arg0)"""
        return _pyAgrum.LazyPropagation_double_eraseEvidence(self, *args)

    def collect(self, *args):
        """
        collect(LazyPropagation_double self, gum::NodeId id, bool force_collect=False)
        collect(LazyPropagation_double self, gum::NodeId id)
        """
        return _pyAgrum.LazyPropagation_double_collect(self, *args)

    def diffusion(self, *args):
        """
        diffusion(LazyPropagation_double self, gum::NodeId id, bool force_diffusion=False)
        diffusion(LazyPropagation_double self, gum::NodeId id)
        """
        return _pyAgrum.LazyPropagation_double_diffusion(self, *args)

    def makeInference(self, *args):
        """
        makeInference(LazyPropagation_double self)
        makeInference(LazyPropagation_double self, bool force_inference)
        """
        return _pyAgrum.LazyPropagation_double_makeInference(self, *args)

    def evidenceMarginal(self):
        """evidenceMarginal(LazyPropagation_double self) -> double"""
        return _pyAgrum.LazyPropagation_double_evidenceMarginal(self)

    def junctionTree(self):
        """junctionTree(LazyPropagation_double self) -> CliqueGraph"""
        return _pyAgrum.LazyPropagation_double_junctionTree(self)

    def H(self, *args):
        """H(LazyPropagation_double self, gum::NodeId X) -> double"""
        return _pyAgrum.LazyPropagation_double_H(self, *args)

    def I(self, *args):
        """I(LazyPropagation_double self, gum::NodeId X, gum::NodeId Y) -> double"""
        return _pyAgrum.LazyPropagation_double_I(self, *args)

    def VI(self, *args):
        """VI(LazyPropagation_double self, gum::NodeId X, gum::NodeId Y) -> double"""
        return _pyAgrum.LazyPropagation_double_VI(self, *args)

    def _fillMarginal(self, *args):
        """_fillMarginal(LazyPropagation_double self, gum::Id id, Potential_double marginal)"""
        return _pyAgrum.LazyPropagation_double__fillMarginal(self, *args)

    def joint(self, *args):
        """
        joint(LazyPropagation_double self, gum::NodeSet const & nodes) -> Potential_double
        joint(LazyPropagation_double self, PyObject * seq_of_ids) -> Potential_double
        """
        return _pyAgrum.LazyPropagation_double_joint(self, *args)

    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_LazyPropagation_double(self)
        return weakref_proxy(self)
LazyPropagation_double_swigregister = _pyAgrum.LazyPropagation_double_swigregister
LazyPropagation_double_swigregister(LazyPropagation_double)

class GibbsInference_double(BayesNetInference_double):
    """Proxy of C++ gum::GibbsInference<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsInference_double, name, value)
    __swig_getmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsInference_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gum::GibbsInference<(double)> self, IBayesNet_double BN) -> GibbsInference_double"""
        if self.__class__ == GibbsInference_double:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_GibbsInference_double(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsInference_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(GibbsInference_double self)"""
        return _pyAgrum.GibbsInference_double_makeInference(self)

    def insertEvidence(self, *args):
        """insertEvidence(GibbsInference_double self, gum::List< gum::Potential< double > const * > const & pot_list)"""
        return _pyAgrum.GibbsInference_double_insertEvidence(self, *args)

    def eraseEvidence(self, *args):
        """eraseEvidence(GibbsInference_double self, Potential_double e)"""
        return _pyAgrum.GibbsInference_double_eraseEvidence(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(GibbsInference_double self)"""
        return _pyAgrum.GibbsInference_double_eraseAllEvidence(self)

    def setRequiredInference(self):
        """setRequiredInference(GibbsInference_double self)"""
        return _pyAgrum.GibbsInference_double_setRequiredInference(self)

    def isInferenceRequired(self):
        """isInferenceRequired(GibbsInference_double self) -> bool"""
        return _pyAgrum.GibbsInference_double_isInferenceRequired(self)

    def _fillMarginal(self, *args):
        """_fillMarginal(GibbsInference_double self, gum::NodeId id, Potential_double marginal)"""
        return _pyAgrum.GibbsInference_double__fillMarginal(self, *args)

    def setVerbosity(self, *args):
        """setVerbosity(GibbsInference_double self, bool v)"""
        return _pyAgrum.GibbsInference_double_setVerbosity(self, *args)

    def setEpsilon(self, *args):
        """setEpsilon(GibbsInference_double self, double eps)"""
        return _pyAgrum.GibbsInference_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args):
        """setMinEpsilonRate(GibbsInference_double self, double rate)"""
        return _pyAgrum.GibbsInference_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args):
        """setMaxIter(GibbsInference_double self, gum::Size max)"""
        return _pyAgrum.GibbsInference_double_setMaxIter(self, *args)

    def setMaxTime(self, *args):
        """setMaxTime(GibbsInference_double self, double timeout)"""
        return _pyAgrum.GibbsInference_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args):
        """setPeriodSize(GibbsInference_double self, gum::Size p)"""
        return _pyAgrum.GibbsInference_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args):
        """setBurnIn(GibbsInference_double self, gum::Size b)"""
        return _pyAgrum.GibbsInference_double_setBurnIn(self, *args)

    def verbosity(self):
        """verbosity(GibbsInference_double self) -> bool"""
        return _pyAgrum.GibbsInference_double_verbosity(self)

    def epsilon(self):
        """epsilon(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_epsilon(self)

    def minEpsilonRate(self):
        """minEpsilonRate(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_minEpsilonRate(self)

    def maxIter(self):
        """maxIter(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_maxIter(self)

    def maxTime(self):
        """maxTime(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_maxTime(self)

    def periodSize(self):
        """periodSize(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_periodSize(self)

    def burnIn(self):
        """burnIn(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_burnIn(self)

    def nbrIterations(self):
        """nbrIterations(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_nbrIterations(self)

    def currentTime(self):
        """currentTime(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_currentTime(self)

    def messageApproximationScheme(self):
        """messageApproximationScheme(GibbsInference_double self) -> std::string"""
        return _pyAgrum.GibbsInference_double_messageApproximationScheme(self)

    def history(self):
        """history(GibbsInference_double self) -> Vector_double"""
        return _pyAgrum.GibbsInference_double_history(self)

    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_GibbsInference_double(self)
        return weakref_proxy(self)
GibbsInference_double_swigregister = _pyAgrum.GibbsInference_double_swigregister
GibbsInference_double_swigregister(GibbsInference_double)

class BruteForceKL_double(_object):
    """Proxy of C++ gum::BruteForceKL<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BruteForceKL_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BruteForceKL_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::BruteForceKL<(double)> self, IBayesNet_double P, IBayesNet_double Q) -> BruteForceKL_double
        __init__(gum::BruteForceKL<(double)> self, gum::KL< double > const & kl) -> BruteForceKL_double
        """
        this = _pyAgrum.new_BruteForceKL_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_BruteForceKL_double
    __del__ = lambda self : None;
    def compute(self):
        """compute(BruteForceKL_double self) -> PyObject *"""
        return _pyAgrum.BruteForceKL_double_compute(self)

BruteForceKL_double_swigregister = _pyAgrum.BruteForceKL_double_swigregister
BruteForceKL_double_swigregister(BruteForceKL_double)

class GibbsKL_double(_object):
    """Proxy of C++ gum::GibbsKL<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsKL_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsKL_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::GibbsKL<(double)> self, IBayesNet_double P, IBayesNet_double Q) -> GibbsKL_double
        __init__(gum::GibbsKL<(double)> self, gum::KL< double > const & kl) -> GibbsKL_double
        """
        this = _pyAgrum.new_GibbsKL_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsKL_double
    __del__ = lambda self : None;
    def compute(self):
        """compute(GibbsKL_double self) -> PyObject *"""
        return _pyAgrum.GibbsKL_double_compute(self)

    def setVerbosity(self, *args):
        """setVerbosity(GibbsKL_double self, bool v)"""
        return _pyAgrum.GibbsKL_double_setVerbosity(self, *args)

    def setEpsilon(self, *args):
        """setEpsilon(GibbsKL_double self, double eps)"""
        return _pyAgrum.GibbsKL_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args):
        """setMinEpsilonRate(GibbsKL_double self, double rate)"""
        return _pyAgrum.GibbsKL_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args):
        """setMaxIter(GibbsKL_double self, gum::Size max)"""
        return _pyAgrum.GibbsKL_double_setMaxIter(self, *args)

    def setMaxTime(self, *args):
        """setMaxTime(GibbsKL_double self, double timeout)"""
        return _pyAgrum.GibbsKL_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args):
        """setPeriodSize(GibbsKL_double self, gum::Size p)"""
        return _pyAgrum.GibbsKL_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args):
        """setBurnIn(GibbsKL_double self, gum::Size b)"""
        return _pyAgrum.GibbsKL_double_setBurnIn(self, *args)

    def verbosity(self):
        """verbosity(GibbsKL_double self) -> bool"""
        return _pyAgrum.GibbsKL_double_verbosity(self)

    def epsilon(self):
        """epsilon(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_epsilon(self)

    def minEpsilonRate(self):
        """minEpsilonRate(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_minEpsilonRate(self)

    def maxIter(self):
        """maxIter(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_maxIter(self)

    def maxTime(self):
        """maxTime(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_maxTime(self)

    def periodSize(self):
        """periodSize(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_periodSize(self)

    def burnIn(self):
        """burnIn(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_burnIn(self)

    def nbrIterations(self):
        """nbrIterations(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_nbrIterations(self)

    def currentTime(self):
        """currentTime(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_currentTime(self)

    def messageApproximationScheme(self):
        """messageApproximationScheme(GibbsKL_double self) -> std::string"""
        return _pyAgrum.GibbsKL_double_messageApproximationScheme(self)

    def history(self):
        """history(GibbsKL_double self) -> Vector_double"""
        return _pyAgrum.GibbsKL_double_history(self)

GibbsKL_double_swigregister = _pyAgrum.GibbsKL_double_swigregister
GibbsKL_double_swigregister(GibbsKL_double)

class CredalNet_double(_object):
    """Proxy of C++ gum::credal::CredalNet<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CredalNet_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CredalNet_double, name)
    __repr__ = _swig_repr
    Precise = _pyAgrum.CredalNet_double_Precise
    Credal = _pyAgrum.CredalNet_double_Credal
    Vacuous = _pyAgrum.CredalNet_double_Vacuous
    Indic = _pyAgrum.CredalNet_double_Indic
    def __init__(self, *args): 
        """
        __init__(gum::credal::CredalNet<(double)> self) -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, std::string const & src_min_num, std::string const & src_max_den="") -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, std::string const & src_min_num) -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, BayesNet_double src_min_num, BayesNet_double src_max_den=gum::BayesNet()) -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, BayesNet_double src_min_num) -> CredalNet_double
        """
        this = _pyAgrum.new_CredalNet_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CredalNet_double
    __del__ = lambda self : None;
    def addNode(self, *args):
        """addNode(CredalNet_double self, std::string const & name, unsigned long const & card) -> gum::NodeId"""
        return _pyAgrum.CredalNet_double_addNode(self, *args)

    def addArc(self, *args):
        """addArc(CredalNet_double self, gum::NodeId const & tail, gum::NodeId const & head)"""
        return _pyAgrum.CredalNet_double_addArc(self, *args)

    def setCPTs(self, *args):
        """setCPTs(CredalNet_double self, gum::NodeId const & id, std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > const & cpt)"""
        return _pyAgrum.CredalNet_double_setCPTs(self, *args)

    def setCPT(self, *args):
        """
        setCPT(CredalNet_double self, gum::NodeId const & id, unsigned long & entry, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & cpt)
        setCPT(CredalNet_double self, gum::NodeId const & id, Instantiation ins, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & cpt)
        """
        return _pyAgrum.CredalNet_double_setCPT(self, *args)

    def fillConstraints(self, *args):
        """fillConstraints(CredalNet_double self, gum::NodeId const & id, Vector_double lower, Vector_double upper)"""
        return _pyAgrum.CredalNet_double_fillConstraints(self, *args)

    def fillConstraint(self, *args):
        """
        fillConstraint(CredalNet_double self, gum::NodeId const & id, unsigned long & entry, Vector_double lower, Vector_double upper)
        fillConstraint(CredalNet_double self, gum::NodeId const & id, Instantiation ins, Vector_double lower, Vector_double upper)
        """
        return _pyAgrum.CredalNet_double_fillConstraint(self, *args)

    def instantiation(self, *args):
        """instantiation(CredalNet_double self, gum::NodeId const & id) -> Instantiation"""
        return _pyAgrum.CredalNet_double_instantiation(self, *args)

    def domainSize(self, *args):
        """domainSize(CredalNet_double self, gum::NodeId const & id) -> gum::Size"""
        return _pyAgrum.CredalNet_double_domainSize(self, *args)

    def bnToCredal(self, *args):
        """
        bnToCredal(CredalNet_double self, double const beta, bool const oneNet, bool const keepZeroes=False)
        bnToCredal(CredalNet_double self, double const beta, bool const oneNet)
        """
        return _pyAgrum.CredalNet_double_bnToCredal(self, *args)

    def intervalToCredalWithFiles(self):
        """intervalToCredalWithFiles(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_intervalToCredalWithFiles(self)

    def intervalToCredal(self):
        """intervalToCredal(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_intervalToCredal(self)

    def lagrangeNormalization(self):
        """lagrangeNormalization(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_lagrangeNormalization(self)

    def idmLearning(self, s=0, keepZeroes=False):
        """
        idmLearning(CredalNet_double self, unsigned int const s=0, bool const keepZeroes=False)
        idmLearning(CredalNet_double self, unsigned int const s=0)
        idmLearning(CredalNet_double self)
        """
        return _pyAgrum.CredalNet_double_idmLearning(self, s, keepZeroes)

    def approximatedBinarization(self):
        """approximatedBinarization(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_approximatedBinarization(self)

    def saveBNsMinMax(self, *args):
        """saveBNsMinMax(CredalNet_double self, std::string const & min_path, std::string const & max_path)"""
        return _pyAgrum.CredalNet_double_saveBNsMinMax(self, *args)

    def __str__(self):
        """__str__(CredalNet_double self) -> std::string"""
        return _pyAgrum.CredalNet_double___str__(self)

    def computeCPTMinMax(self):
        """computeCPTMinMax(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_computeCPTMinMax(self)

    def src_bn(self):
        """src_bn(CredalNet_double self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_src_bn(self)

    def current_bn(self):
        """current_bn(CredalNet_double self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_current_bn(self)

    def credalNet_currentCpt(self):
        """credalNet_currentCpt(CredalNet_double self) -> NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &"""
        return _pyAgrum.CredalNet_double_credalNet_currentCpt(self)

    def credalNet_srcCpt(self):
        """credalNet_srcCpt(CredalNet_double self) -> NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &"""
        return _pyAgrum.CredalNet_double_credalNet_srcCpt(self)

    def currentNodeType(self, *args):
        """currentNodeType(CredalNet_double self, gum::NodeId const & id) -> gum::credal::CredalNet< double >::NodeType"""
        return _pyAgrum.CredalNet_double_currentNodeType(self, *args)

    def nodeType(self, *args):
        """nodeType(CredalNet_double self, gum::NodeId const & id) -> gum::credal::CredalNet< double >::NodeType"""
        return _pyAgrum.CredalNet_double_nodeType(self, *args)

    def epsilonMin(self):
        """epsilonMin(CredalNet_double self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMin(self)

    def epsilonMax(self):
        """epsilonMax(CredalNet_double self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMax(self)

    def epsilonMean(self):
        """epsilonMean(CredalNet_double self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMean(self)

    def isSeparatelySpecified(self):
        """isSeparatelySpecified(CredalNet_double self) -> bool const"""
        return _pyAgrum.CredalNet_double_isSeparatelySpecified(self)

    def get_CPT_min(self):
        """get_CPT_min(CredalNet_double self) -> std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &"""
        return _pyAgrum.CredalNet_double_get_CPT_min(self)

    def get_CPT_max(self):
        """get_CPT_max(CredalNet_double self) -> std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &"""
        return _pyAgrum.CredalNet_double_get_CPT_max(self)

CredalNet_double_swigregister = _pyAgrum.CredalNet_double_swigregister
CredalNet_double_swigregister(CredalNet_double)

class CNInferenceEngine_double(_object):
    """Proxy of C++ gum::credal::InferenceEngine<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNInferenceEngine_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNInferenceEngine_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_CNInferenceEngine_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(CNInferenceEngine_double self)"""
        return _pyAgrum.CNInferenceEngine_double_makeInference(self)

    def getVarMod2BNsMap(self):
        """getVarMod2BNsMap(CNInferenceEngine_double self) -> gum::credal::VarMod2BNsMap< double > *"""
        return _pyAgrum.CNInferenceEngine_double_getVarMod2BNsMap(self)

    def credalNet(self):
        """credalNet(CNInferenceEngine_double self) -> CredalNet_double"""
        return _pyAgrum.CNInferenceEngine_double_credalNet(self)

    def getT0Cluster(self):
        """getT0Cluster(CNInferenceEngine_double self) -> NodeProperty< std::vector< gum::NodeId,std::allocator< gum::NodeId > > > const &"""
        return _pyAgrum.CNInferenceEngine_double_getT0Cluster(self)

    def getT1Cluster(self):
        """getT1Cluster(CNInferenceEngine_double self) -> NodeProperty< std::vector< gum::NodeId,std::allocator< gum::NodeId > > > const &"""
        return _pyAgrum.CNInferenceEngine_double_getT1Cluster(self)

    def setRepetitiveInd(self, *args):
        """setRepetitiveInd(CNInferenceEngine_double self, bool const repetitive)"""
        return _pyAgrum.CNInferenceEngine_double_setRepetitiveInd(self, *args)

    def repetitiveInd(self):
        """repetitiveInd(CNInferenceEngine_double self) -> bool"""
        return _pyAgrum.CNInferenceEngine_double_repetitiveInd(self)

    def storeVertices(self, *args):
        """
        storeVertices(CNInferenceEngine_double self, bool const value)
        storeVertices(CNInferenceEngine_double self) -> bool
        """
        return _pyAgrum.CNInferenceEngine_double_storeVertices(self, *args)

    def storeBNOpt(self, *args):
        """
        storeBNOpt(CNInferenceEngine_double self, bool const value)
        storeBNOpt(CNInferenceEngine_double self) -> bool
        """
        return _pyAgrum.CNInferenceEngine_double_storeBNOpt(self, *args)

    def insertModalsFile(self, *args):
        """insertModalsFile(CNInferenceEngine_double self, std::string const & path)"""
        return _pyAgrum.CNInferenceEngine_double_insertModalsFile(self, *args)

    def insertModals(self, *args):
        """insertModals(CNInferenceEngine_double self, std::map< std::string,std::vector< double,std::allocator< double > > > const & modals)"""
        return _pyAgrum.CNInferenceEngine_double_insertModals(self, *args)

    def insertEvidenceFile(self, *args):
        """insertEvidenceFile(CNInferenceEngine_double self, std::string const & path)"""
        return _pyAgrum.CNInferenceEngine_double_insertEvidenceFile(self, *args)

    def insertEvidence(self, *args):
        """
        insertEvidence(CNInferenceEngine_double self, std::map< std::string,std::vector< double,std::allocator< double > > > const & eviMap)
        insertEvidence(CNInferenceEngine_double self, NodeProperty< std::vector< double,std::allocator< double > > > const & evidence)
        """
        return _pyAgrum.CNInferenceEngine_double_insertEvidence(self, *args)

    def insertQueryFile(self, *args):
        """insertQueryFile(CNInferenceEngine_double self, std::string const & path)"""
        return _pyAgrum.CNInferenceEngine_double_insertQueryFile(self, *args)

    def insertQuery(self, *args):
        """insertQuery(CNInferenceEngine_double self, NodeProperty< std::vector< bool,std::allocator< bool > > > const & query)"""
        return _pyAgrum.CNInferenceEngine_double_insertQuery(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(CNInferenceEngine_double self)"""
        return _pyAgrum.CNInferenceEngine_double_eraseAllEvidence(self)

    def marginalMin(self, *args):
        """
        marginalMin(CNInferenceEngine_double self, gum::NodeId const id) -> Vector_double
        marginalMin(CNInferenceEngine_double self, std::string const & varName) -> Vector_double
        """
        return _pyAgrum.CNInferenceEngine_double_marginalMin(self, *args)

    def marginalMax(self, *args):
        """
        marginalMax(CNInferenceEngine_double self, gum::NodeId const id) -> Vector_double
        marginalMax(CNInferenceEngine_double self, std::string const & varName) -> Vector_double
        """
        return _pyAgrum.CNInferenceEngine_double_marginalMax(self, *args)

    def expectationMin(self, *args):
        """
        expectationMin(CNInferenceEngine_double self, gum::NodeId const id) -> double const
        expectationMin(CNInferenceEngine_double self, std::string const & varName) -> double const &
        """
        return _pyAgrum.CNInferenceEngine_double_expectationMin(self, *args)

    def expectationMax(self, *args):
        """
        expectationMax(CNInferenceEngine_double self, gum::NodeId const id) -> double const
        expectationMax(CNInferenceEngine_double self, std::string const & varName) -> double const &
        """
        return _pyAgrum.CNInferenceEngine_double_expectationMax(self, *args)

    def dynamicExpMin(self, *args):
        """dynamicExpMin(CNInferenceEngine_double self, std::string const & varName) -> Vector_double"""
        return _pyAgrum.CNInferenceEngine_double_dynamicExpMin(self, *args)

    def dynamicExpMax(self, *args):
        """dynamicExpMax(CNInferenceEngine_double self, std::string const & varName) -> Vector_double"""
        return _pyAgrum.CNInferenceEngine_double_dynamicExpMax(self, *args)

    def vertices(self, *args):
        """vertices(CNInferenceEngine_double self, gum::NodeId const id) -> std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &"""
        return _pyAgrum.CNInferenceEngine_double_vertices(self, *args)

    def saveMarginals(self, *args):
        """saveMarginals(CNInferenceEngine_double self, std::string const & path)"""
        return _pyAgrum.CNInferenceEngine_double_saveMarginals(self, *args)

    def saveExpectations(self, *args):
        """saveExpectations(CNInferenceEngine_double self, std::string const & path)"""
        return _pyAgrum.CNInferenceEngine_double_saveExpectations(self, *args)

    def saveVertices(self, *args):
        """saveVertices(CNInferenceEngine_double self, std::string const & path)"""
        return _pyAgrum.CNInferenceEngine_double_saveVertices(self, *args)

    def dynamicExpectations(self):
        """dynamicExpectations(CNInferenceEngine_double self)"""
        return _pyAgrum.CNInferenceEngine_double_dynamicExpectations(self)

    def __str__(self):
        """__str__(CNInferenceEngine_double self) -> std::string"""
        return _pyAgrum.CNInferenceEngine_double___str__(self)

    def getApproximationSchemeMsg(self):
        """getApproximationSchemeMsg(CNInferenceEngine_double self) -> std::string const"""
        return _pyAgrum.CNInferenceEngine_double_getApproximationSchemeMsg(self)

    def setVerbosity(self, *args):
        """setVerbosity(CNInferenceEngine_double self, bool v)"""
        return _pyAgrum.CNInferenceEngine_double_setVerbosity(self, *args)

    def setEpsilon(self, *args):
        """setEpsilon(CNInferenceEngine_double self, double eps)"""
        return _pyAgrum.CNInferenceEngine_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args):
        """setMinEpsilonRate(CNInferenceEngine_double self, double rate)"""
        return _pyAgrum.CNInferenceEngine_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args):
        """setMaxIter(CNInferenceEngine_double self, gum::Size max)"""
        return _pyAgrum.CNInferenceEngine_double_setMaxIter(self, *args)

    def setMaxTime(self, *args):
        """setMaxTime(CNInferenceEngine_double self, double timeout)"""
        return _pyAgrum.CNInferenceEngine_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args):
        """setPeriodSize(CNInferenceEngine_double self, gum::Size p)"""
        return _pyAgrum.CNInferenceEngine_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args):
        """setBurnIn(CNInferenceEngine_double self, gum::Size b)"""
        return _pyAgrum.CNInferenceEngine_double_setBurnIn(self, *args)

    def verbosity(self):
        """verbosity(CNInferenceEngine_double self) -> bool"""
        return _pyAgrum.CNInferenceEngine_double_verbosity(self)

    def epsilon(self):
        """epsilon(CNInferenceEngine_double self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_epsilon(self)

    def minEpsilonRate(self):
        """minEpsilonRate(CNInferenceEngine_double self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_minEpsilonRate(self)

    def maxIter(self):
        """maxIter(CNInferenceEngine_double self) -> gum::Size"""
        return _pyAgrum.CNInferenceEngine_double_maxIter(self)

    def maxTime(self):
        """maxTime(CNInferenceEngine_double self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_maxTime(self)

    def periodSize(self):
        """periodSize(CNInferenceEngine_double self) -> gum::Size"""
        return _pyAgrum.CNInferenceEngine_double_periodSize(self)

    def burnIn(self):
        """burnIn(CNInferenceEngine_double self) -> gum::Size"""
        return _pyAgrum.CNInferenceEngine_double_burnIn(self)

    def nbrIterations(self):
        """nbrIterations(CNInferenceEngine_double self) -> gum::Size"""
        return _pyAgrum.CNInferenceEngine_double_nbrIterations(self)

    def currentTime(self):
        """currentTime(CNInferenceEngine_double self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_currentTime(self)

    def messageApproximationScheme(self):
        """messageApproximationScheme(CNInferenceEngine_double self) -> std::string"""
        return _pyAgrum.CNInferenceEngine_double_messageApproximationScheme(self)

    def history(self):
        """history(CNInferenceEngine_double self) -> Vector_double"""
        return _pyAgrum.CNInferenceEngine_double_history(self)

CNInferenceEngine_double_swigregister = _pyAgrum.CNInferenceEngine_double_swigregister
CNInferenceEngine_double_swigregister(CNInferenceEngine_double)

class CNMultipleInferenceEngine_double(CNInferenceEngine_double):
    """Proxy of C++ gum::credal::MultipleInferenceEngine<(double,gum::LazyPropagation<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNMultipleInferenceEngine_double, name, value)
    __swig_getmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CNMultipleInferenceEngine_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_CNMultipleInferenceEngine_double
    __del__ = lambda self : None;
    def eraseAllEvidence(self):
        """eraseAllEvidence(CNMultipleInferenceEngine_double self)"""
        return _pyAgrum.CNMultipleInferenceEngine_double_eraseAllEvidence(self)

    def makeInference(self):
        """makeInference(CNMultipleInferenceEngine_double self)"""
        return _pyAgrum.CNMultipleInferenceEngine_double_makeInference(self)

CNMultipleInferenceEngine_double_swigregister = _pyAgrum.CNMultipleInferenceEngine_double_swigregister
CNMultipleInferenceEngine_double_swigregister(CNMultipleInferenceEngine_double)

class CNMonteCarloSampling_double(CNMultipleInferenceEngine_double):
    """Proxy of C++ gum::credal::CNMonteCarloSampling<(double,gum::LazyPropagation<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [CNMultipleInferenceEngine_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNMonteCarloSampling_double, name, value)
    __swig_getmethods__ = {}
    for _s in [CNMultipleInferenceEngine_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CNMonteCarloSampling_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gum::credal::CNMonteCarloSampling<(double,gum::LazyPropagation<(double)>)> self, CredalNet_double credalNet) -> CNMonteCarloSampling_double"""
        this = _pyAgrum.new_CNMonteCarloSampling_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNMonteCarloSampling_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(CNMonteCarloSampling_double self)"""
        return _pyAgrum.CNMonteCarloSampling_double_makeInference(self)

CNMonteCarloSampling_double_swigregister = _pyAgrum.CNMonteCarloSampling_double_swigregister
CNMonteCarloSampling_double_swigregister(CNMonteCarloSampling_double)

class CNLoopyPropagation_double(CNInferenceEngine_double):
    """Proxy of C++ gum::credal::CNLoopyPropagation<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNLoopyPropagation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CNLoopyPropagation_double, name)
    __repr__ = _swig_repr
    nodeToNeighbours = _pyAgrum.CNLoopyPropagation_double_nodeToNeighbours
    ordered = _pyAgrum.CNLoopyPropagation_double_ordered
    randomOrder = _pyAgrum.CNLoopyPropagation_double_randomOrder
    def makeInference(self):
        """makeInference(CNLoopyPropagation_double self)"""
        return _pyAgrum.CNLoopyPropagation_double_makeInference(self)

    def inferenceType(self, *args):
        """
        inferenceType(CNLoopyPropagation_double self, gum::credal::CNLoopyPropagation< double >::InferenceType inft)
        inferenceType(CNLoopyPropagation_double self) -> gum::credal::CNLoopyPropagation< double >::InferenceType
        """
        return _pyAgrum.CNLoopyPropagation_double_inferenceType(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(CNLoopyPropagation_double self)"""
        return _pyAgrum.CNLoopyPropagation_double_eraseAllEvidence(self)

    def saveInference(self, *args):
        """saveInference(CNLoopyPropagation_double self, std::string const & path)"""
        return _pyAgrum.CNLoopyPropagation_double_saveInference(self, *args)

    def __init__(self, *args): 
        """__init__(gum::credal::CNLoopyPropagation<(double)> self, CredalNet_double cnet) -> CNLoopyPropagation_double"""
        this = _pyAgrum.new_CNLoopyPropagation_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNLoopyPropagation_double
    __del__ = lambda self : None;
CNLoopyPropagation_double_swigregister = _pyAgrum.CNLoopyPropagation_double_swigregister
CNLoopyPropagation_double_swigregister(CNLoopyPropagation_double)

Potential = Potential_double
randomDistribution = randomDistribution_double

SimpleBayesNet = IBayesNet_double
BayesNet = BayesNet_double
LazyPropagation = LazyPropagation_double
GibbsInference = GibbsInference_double

BruteForceKL = BruteForceKL_double
GibbsKL = GibbsKL_double

CredalNet = CredalNet_double
CNMonteCarloSampling = CNMonteCarloSampling_double
CNLoopyPropagation = CNLoopyPropagation_double

# This file is compatible with both classic and new-style classes.


