# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

"""
pyAgrum is a Python wrapper for the C++ aGrUM library. It provides a high-level
interface to the part of agrum allowing to create, handle and make computations
into Bayesian Networks. The module is a straightforward application of the SWIG
interface generator. Custom-written code was added to make the interface similar
to OpenBayes, a free Bayesian Network library for Python.
"""

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyAgrum', [dirname(__file__)])
        except ImportError:
            import _pyAgrum
            return _pyAgrum
        if fp is not None:
            try:
                _mod = imp.load_module('_pyAgrum', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyAgrum = swig_import_helper()
    del swig_import_helper
else:
    import _pyAgrum
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import numpy

class PythonBNListener(_object):
    """Proxy of C++ PythonBNListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonBNListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonBNListener, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, DiGraph g, VariableNodeMap vnm) -> PythonBNListener"""
        this = _pyAgrum.new_PythonBNListener(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonBNListener
    __del__ = lambda self : None;
    def whenNodeAdded(self, *args):
        """whenNodeAdded(self, void source, NodeId id)"""
        return _pyAgrum.PythonBNListener_whenNodeAdded(self, *args)

    def whenNodeDeleted(self, *args):
        """whenNodeDeleted(self, void arg0, NodeId id)"""
        return _pyAgrum.PythonBNListener_whenNodeDeleted(self, *args)

    def whenArcAdded(self, *args):
        """whenArcAdded(self, void arg0, NodeId src, NodeId dst)"""
        return _pyAgrum.PythonBNListener_whenArcAdded(self, *args)

    def whenArcDeleted(self, *args):
        """whenArcDeleted(self, void arg0, NodeId src, NodeId dst)"""
        return _pyAgrum.PythonBNListener_whenArcDeleted(self, *args)

    def setWhenArcAdded(self, *args):
        """setWhenArcAdded(self, PyObject pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcAdded(self, *args)

    def setWhenArcDeleted(self, *args):
        """setWhenArcDeleted(self, PyObject pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcDeleted(self, *args)

    def setWhenNodeAdded(self, *args):
        """setWhenNodeAdded(self, PyObject pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeAdded(self, *args)

    def setWhenNodeDeleted(self, *args):
        """setWhenNodeDeleted(self, PyObject pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeDeleted(self, *args)

PythonBNListener_swigregister = _pyAgrum.PythonBNListener_swigregister
PythonBNListener_swigregister(PythonBNListener)

class PythonLoadListener(_object):
    """Proxy of C++ PythonLoadListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonLoadListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonLoadListener, name)
    __repr__ = _swig_repr
    def whenLoading(self, *args):
        """whenLoading(self, void buffer, int percent)"""
        return _pyAgrum.PythonLoadListener_whenLoading(self, *args)

    def setPythonListener(self, *args):
        """setPythonListener(self, PyObject l) -> bool"""
        return _pyAgrum.PythonLoadListener_setPythonListener(self, *args)

    def __init__(self): 
        """__init__(self) -> PythonLoadListener"""
        this = _pyAgrum.new_PythonLoadListener()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonLoadListener
    __del__ = lambda self : None;
PythonLoadListener_swigregister = _pyAgrum.PythonLoadListener_swigregister
PythonLoadListener_swigregister(PythonLoadListener)


def __fillLoadListeners(*args):
  """
    __fillLoadListeners(std::vector<(PythonLoadListener,std::allocator<(PythonLoadListener)>)> py_listener, 
        PyObject l) -> int
    """
  return _pyAgrum.__fillLoadListeners(*args)
class PythonApproximationListener(_object):
    """Proxy of C++ PythonApproximationListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonApproximationListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonApproximationListener, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, ApproximationScheme algo) -> PythonApproximationListener"""
        this = _pyAgrum.new_PythonApproximationListener(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonApproximationListener
    __del__ = lambda self : None;
    def whenProgress(self, *args):
        """whenProgress(self, void src, Size step, double error, double duration)"""
        return _pyAgrum.PythonApproximationListener_whenProgress(self, *args)

    def whenStop(self, *args):
        """whenStop(self, void src, string message)"""
        return _pyAgrum.PythonApproximationListener_whenStop(self, *args)

    def setWhenProgress(self, *args):
        """setWhenProgress(self, PyObject pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenProgress(self, *args)

    def setWhenStop(self, *args):
        """setWhenStop(self, PyObject pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenStop(self, *args)

PythonApproximationListener_swigregister = _pyAgrum.PythonApproximationListener_swigregister
PythonApproximationListener_swigregister(PythonApproximationListener)

class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _pyAgrum.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _pyAgrum.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _pyAgrum.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _pyAgrum.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _pyAgrum.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _pyAgrum.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _pyAgrum.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

def generateBN(n_nodes = 10, n_arcs = 15, n_modmax = 4):
  """
    generateBN(Size n_nodes = 10, Size n_arcs = 15, Size n_modmax = 4) -> BayesNet_double
    generateBN(Size n_nodes = 10, Size n_arcs = 15) -> BayesNet_double
    generateBN(Size n_nodes = 10) -> BayesNet_double
    generateBN() -> BayesNet_double
    """
  return _pyAgrum.generateBN(n_nodes, n_arcs, n_modmax)

class Vector_double(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector_double, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _pyAgrum.Vector_double_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _pyAgrum.Vector_double___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _pyAgrum.Vector_double___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _pyAgrum.Vector_double___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _pyAgrum.Vector_double_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> Vector_double"""
        return _pyAgrum.Vector_double___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, Vector_double v)"""
        return _pyAgrum.Vector_double___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _pyAgrum.Vector_double___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _pyAgrum.Vector_double___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> Vector_double
        __getitem__(self, difference_type i) -> value_type
        """
        return _pyAgrum.Vector_double___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, Vector_double v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _pyAgrum.Vector_double___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _pyAgrum.Vector_double_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.Vector_double_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _pyAgrum.Vector_double_size(self)

    def clear(self):
        """clear(self)"""
        return _pyAgrum.Vector_double_clear(self)

    def swap(self, *args):
        """swap(self, Vector_double v)"""
        return _pyAgrum.Vector_double_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _pyAgrum.Vector_double_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _pyAgrum.Vector_double_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _pyAgrum.Vector_double_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _pyAgrum.Vector_double_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _pyAgrum.Vector_double_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _pyAgrum.Vector_double_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _pyAgrum.Vector_double_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> Vector_double
        __init__(self, Vector_double arg0) -> Vector_double
        __init__(self, size_type size) -> Vector_double
        __init__(self, size_type size, value_type value) -> Vector_double
        """
        this = _pyAgrum.new_Vector_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _pyAgrum.Vector_double_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _pyAgrum.Vector_double_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _pyAgrum.Vector_double_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _pyAgrum.Vector_double_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _pyAgrum.Vector_double_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _pyAgrum.Vector_double_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _pyAgrum.Vector_double_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _pyAgrum.Vector_double_capacity(self)

    __swig_destroy__ = _pyAgrum.delete_Vector_double
    __del__ = lambda self : None;
Vector_double_swigregister = _pyAgrum.Vector_double_swigregister
Vector_double_swigregister(Vector_double)

GUM_MAJOR_VERSION = _pyAgrum.GUM_MAJOR_VERSION
GUM_MINOR_VERSION = _pyAgrum.GUM_MINOR_VERSION
GUM_PATCH_VERSION = _pyAgrum.GUM_PATCH_VERSION
GUM_VERSION = _pyAgrum.GUM_VERSION
GUM_CHAR_SIZE = _pyAgrum.GUM_CHAR_SIZE
GUM_INT_SIZE = _pyAgrum.GUM_INT_SIZE
GUM_LONG_SIZE = _pyAgrum.GUM_LONG_SIZE
GUM_FLOAT_SIZE = _pyAgrum.GUM_FLOAT_SIZE
GUM_DOUBLE_SIZE = _pyAgrum.GUM_DOUBLE_SIZE

def __createMsg(*args):
  """__createMsg(string filename, string function, int line, string msg) -> string"""
  return _pyAgrum.__createMsg(*args)
class Exception(Exception):
    """Proxy of C++ gum::Exception class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Exception, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Exception, name)
    __repr__ = _swig_repr
    def __init__(self, aMsg = "", aType = "Generic error"): 
        """
        __init__(self, string aMsg = "", string aType = "Generic error") -> Exception
        __init__(self, string aMsg = "") -> Exception
        __init__(self) -> Exception
        """
        this = _pyAgrum.new_Exception(aMsg, aType)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Exception
    __del__ = lambda self : None;
    def content(self):
        """content(self) -> string"""
        return _pyAgrum.Exception_content(self)

    def type(self):
        """type(self) -> string"""
        return _pyAgrum.Exception_type(self)

    def callStack(self):
        """callStack(self) -> string"""
        return _pyAgrum.Exception_callStack(self)

    def __str__(self):
        """__str__(self) -> char"""
        return _pyAgrum.Exception___str__(self)

Exception_swigregister = _pyAgrum.Exception_swigregister
Exception_swigregister(Exception)

class IdError(Exception):
    """Proxy of C++ gum::IdError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IdError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "potential problem with an ID") -> IdError
        __init__(self, string aMsg) -> IdError
        """
        this = _pyAgrum.new_IdError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IdError
    __del__ = lambda self : None;
IdError_swigregister = _pyAgrum.IdError_swigregister
IdError_swigregister(IdError)

class FatalError(Exception):
    """Proxy of C++ gum::FatalError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FatalError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FatalError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Fatal error") -> FatalError
        __init__(self, string aMsg) -> FatalError
        """
        this = _pyAgrum.new_FatalError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FatalError
    __del__ = lambda self : None;
FatalError_swigregister = _pyAgrum.FatalError_swigregister
FatalError_swigregister(FatalError)

class UndefinedIteratorValue(Exception):
    """Proxy of C++ gum::UndefinedIteratorValue class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorValue, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorValue, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Iterator\'s value is undefined") -> UndefinedIteratorValue
        __init__(self, string aMsg) -> UndefinedIteratorValue
        """
        this = _pyAgrum.new_UndefinedIteratorValue(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorValue
    __del__ = lambda self : None;
UndefinedIteratorValue_swigregister = _pyAgrum.UndefinedIteratorValue_swigregister
UndefinedIteratorValue_swigregister(UndefinedIteratorValue)

class UndefinedIteratorKey(Exception):
    """Proxy of C++ gum::UndefinedIteratorKey class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorKey, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorKey, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Iterator\'s key is undefined") -> UndefinedIteratorKey
        __init__(self, string aMsg) -> UndefinedIteratorKey
        """
        this = _pyAgrum.new_UndefinedIteratorKey(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorKey
    __del__ = lambda self : None;
UndefinedIteratorKey_swigregister = _pyAgrum.UndefinedIteratorKey_swigregister
UndefinedIteratorKey_swigregister(UndefinedIteratorKey)

class NullElement(Exception):
    """Proxy of C++ gum::NullElement class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NullElement, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NullElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Null Element") -> NullElement
        __init__(self, string aMsg) -> NullElement
        """
        this = _pyAgrum.new_NullElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NullElement
    __del__ = lambda self : None;
NullElement_swigregister = _pyAgrum.NullElement_swigregister
NullElement_swigregister(NullElement)

class UndefinedElement(Exception):
    """Proxy of C++ gum::UndefinedElement class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedElement, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "could not find the so-called element") -> UndefinedElement
        __init__(self, string aMsg) -> UndefinedElement
        """
        this = _pyAgrum.new_UndefinedElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedElement
    __del__ = lambda self : None;
UndefinedElement_swigregister = _pyAgrum.UndefinedElement_swigregister
UndefinedElement_swigregister(UndefinedElement)

class HashSize(Exception):
    """Proxy of C++ gum::HashSize class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HashSize, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HashSize, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "size not admissible in a HashTable") -> HashSize
        __init__(self, string aMsg) -> HashSize
        """
        this = _pyAgrum.new_HashSize(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_HashSize
    __del__ = lambda self : None;
HashSize_swigregister = _pyAgrum.HashSize_swigregister
HashSize_swigregister(HashSize)

class SizeError(Exception):
    """Proxy of C++ gum::SizeError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SizeError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SizeError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "size not admissible in a HashTable") -> SizeError
        __init__(self, string aMsg) -> SizeError
        """
        this = _pyAgrum.new_SizeError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_SizeError
    __del__ = lambda self : None;
SizeError_swigregister = _pyAgrum.SizeError_swigregister
SizeError_swigregister(SizeError)

class EmptySet(Exception):
    """Proxy of C++ gum::EmptySet class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptySet, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptySet, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "an empty set has been found where it should not be") -> EmptySet
        __init__(self, string aMsg) -> EmptySet
        """
        this = _pyAgrum.new_EmptySet(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptySet
    __del__ = lambda self : None;
EmptySet_swigregister = _pyAgrum.EmptySet_swigregister
EmptySet_swigregister(EmptySet)

class InvalidArgumentsNumber(Exception):
    """Proxy of C++ gum::InvalidArgumentsNumber class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgumentsNumber, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgumentsNumber, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "the number of arguments passed differs from what was expected") -> InvalidArgumentsNumber
        __init__(self, string aMsg) -> InvalidArgumentsNumber
        """
        this = _pyAgrum.new_InvalidArgumentsNumber(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgumentsNumber
    __del__ = lambda self : None;
InvalidArgumentsNumber_swigregister = _pyAgrum.InvalidArgumentsNumber_swigregister
InvalidArgumentsNumber_swigregister(InvalidArgumentsNumber)

class InvalidArgument(Exception):
    """Proxy of C++ gum::InvalidArgument class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgument, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgument, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "at least one argument passed differs from what was expected") -> InvalidArgument
        __init__(self, string aMsg) -> InvalidArgument
        """
        this = _pyAgrum.new_InvalidArgument(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgument
    __del__ = lambda self : None;
InvalidArgument_swigregister = _pyAgrum.InvalidArgument_swigregister
InvalidArgument_swigregister(InvalidArgument)

class IOError(Exception):
    """Proxy of C++ gum::IOError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "an input/output error occurred") -> IOError
        __init__(self, string aMsg) -> IOError
        """
        this = _pyAgrum.new_IOError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IOError
    __del__ = lambda self : None;
IOError_swigregister = _pyAgrum.IOError_swigregister
IOError_swigregister(IOError)

class FormatNotFound(IOError):
    """Proxy of C++ gum::FormatNotFound class"""
    __swig_setmethods__ = {}
    for _s in [IOError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormatNotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormatNotFound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "could not find the specified format") -> FormatNotFound
        __init__(self, string aMsg) -> FormatNotFound
        """
        this = _pyAgrum.new_FormatNotFound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FormatNotFound
    __del__ = lambda self : None;
FormatNotFound_swigregister = _pyAgrum.FormatNotFound_swigregister
FormatNotFound_swigregister(FormatNotFound)

class OperationNotAllowed(Exception):
    """Proxy of C++ gum::OperationNotAllowed class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OperationNotAllowed, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OperationNotAllowed, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "this operation is not allowed") -> OperationNotAllowed
        __init__(self, string aMsg) -> OperationNotAllowed
        """
        this = _pyAgrum.new_OperationNotAllowed(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OperationNotAllowed
    __del__ = lambda self : None;
OperationNotAllowed_swigregister = _pyAgrum.OperationNotAllowed_swigregister
OperationNotAllowed_swigregister(OperationNotAllowed)

class NotFound(Exception):
    """Proxy of C++ gum::NotFound class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotFound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "could not find this object") -> NotFound
        __init__(self, string aMsg) -> NotFound
        """
        this = _pyAgrum.new_NotFound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NotFound
    __del__ = lambda self : None;
NotFound_swigregister = _pyAgrum.NotFound_swigregister
NotFound_swigregister(NotFound)

class ReferenceError(Exception):
    """Proxy of C++ gum::ReferenceError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReferenceError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReferenceError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Reference error") -> ReferenceError
        __init__(self, string aMsg) -> ReferenceError
        """
        this = _pyAgrum.new_ReferenceError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_ReferenceError
    __del__ = lambda self : None;
ReferenceError_swigregister = _pyAgrum.ReferenceError_swigregister
ReferenceError_swigregister(ReferenceError)

class OutOfBounds(ReferenceError):
    """Proxy of C++ gum::OutOfBounds class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfBounds, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfBounds, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Out of bound") -> OutOfBounds
        __init__(self, string aMsg) -> OutOfBounds
        """
        this = _pyAgrum.new_OutOfBounds(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfBounds
    __del__ = lambda self : None;
OutOfBounds_swigregister = _pyAgrum.OutOfBounds_swigregister
OutOfBounds_swigregister(OutOfBounds)

class OutOfLowerBound(OutOfBounds):
    """Proxy of C++ gum::OutOfLowerBound class"""
    __swig_setmethods__ = {}
    for _s in [OutOfBounds]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfLowerBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfLowerBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Out of bound") -> OutOfLowerBound
        __init__(self, string aMsg) -> OutOfLowerBound
        """
        this = _pyAgrum.new_OutOfLowerBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfLowerBound
    __del__ = lambda self : None;
OutOfLowerBound_swigregister = _pyAgrum.OutOfLowerBound_swigregister
OutOfLowerBound_swigregister(OutOfLowerBound)

class OutOfUpperBound(OutOfBounds):
    """Proxy of C++ gum::OutOfUpperBound class"""
    __swig_setmethods__ = {}
    for _s in [OutOfBounds]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfUpperBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfUpperBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Out of bound") -> OutOfUpperBound
        __init__(self, string aMsg) -> OutOfUpperBound
        """
        this = _pyAgrum.new_OutOfUpperBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfUpperBound
    __del__ = lambda self : None;
OutOfUpperBound_swigregister = _pyAgrum.OutOfUpperBound_swigregister
OutOfUpperBound_swigregister(OutOfUpperBound)

class DuplicateElement(ReferenceError):
    """Proxy of C++ gum::DuplicateElement class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateElement, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "A similar element already exists") -> DuplicateElement
        __init__(self, string aMsg) -> DuplicateElement
        """
        this = _pyAgrum.new_DuplicateElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateElement
    __del__ = lambda self : None;
DuplicateElement_swigregister = _pyAgrum.DuplicateElement_swigregister
DuplicateElement_swigregister(DuplicateElement)

class DuplicateLabel(ReferenceError):
    """Proxy of C++ gum::DuplicateLabel class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateLabel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "A similar label already exists") -> DuplicateLabel
        __init__(self, string aMsg) -> DuplicateLabel
        """
        this = _pyAgrum.new_DuplicateLabel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateLabel
    __del__ = lambda self : None;
DuplicateLabel_swigregister = _pyAgrum.DuplicateLabel_swigregister
DuplicateLabel_swigregister(DuplicateLabel)

class GraphError(Exception):
    """Proxy of C++ gum::GraphError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GraphError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GraphError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Graph error") -> GraphError
        __init__(self, string aMsg) -> GraphError
        """
        this = _pyAgrum.new_GraphError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GraphError
    __del__ = lambda self : None;
GraphError_swigregister = _pyAgrum.GraphError_swigregister
GraphError_swigregister(GraphError)

class NoNeighbour(GraphError):
    """Proxy of C++ gum::NoNeighbour class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoNeighbour, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoNeighbour, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "No neighbour can be found to the given node") -> NoNeighbour
        __init__(self, string aMsg) -> NoNeighbour
        """
        this = _pyAgrum.new_NoNeighbour(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoNeighbour
    __del__ = lambda self : None;
NoNeighbour_swigregister = _pyAgrum.NoNeighbour_swigregister
NoNeighbour_swigregister(NoNeighbour)

class NoParent(GraphError):
    """Proxy of C++ gum::NoParent class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoParent, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoParent, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "No parent can be found w.r.t the given node") -> NoParent
        __init__(self, string aMsg) -> NoParent
        """
        this = _pyAgrum.new_NoParent(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoParent
    __del__ = lambda self : None;
NoParent_swigregister = _pyAgrum.NoParent_swigregister
NoParent_swigregister(NoParent)

class NoChild(GraphError):
    """Proxy of C++ gum::NoChild class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoChild, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoChild, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "No child can be found w.r.t the given node") -> NoChild
        __init__(self, string aMsg) -> NoChild
        """
        this = _pyAgrum.new_NoChild(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoChild
    __del__ = lambda self : None;
NoChild_swigregister = _pyAgrum.NoChild_swigregister
NoChild_swigregister(NoChild)

class InvalidEdge(GraphError):
    """Proxy of C++ gum::InvalidEdge class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidEdge, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "the edge is not correct") -> InvalidEdge
        __init__(self, string aMsg) -> InvalidEdge
        """
        this = _pyAgrum.new_InvalidEdge(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidEdge
    __del__ = lambda self : None;
InvalidEdge_swigregister = _pyAgrum.InvalidEdge_swigregister
InvalidEdge_swigregister(InvalidEdge)

class InvalidArc(GraphError):
    """Proxy of C++ gum::InvalidArc class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArc, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArc, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "the arc is not correct") -> InvalidArc
        __init__(self, string aMsg) -> InvalidArc
        """
        this = _pyAgrum.new_InvalidArc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArc
    __del__ = lambda self : None;
InvalidArc_swigregister = _pyAgrum.InvalidArc_swigregister
InvalidArc_swigregister(InvalidArc)

class InvalidNode(GraphError):
    """Proxy of C++ gum::InvalidNode class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "the node does not exist") -> InvalidNode
        __init__(self, string aMsg) -> InvalidNode
        """
        this = _pyAgrum.new_InvalidNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidNode
    __del__ = lambda self : None;
InvalidNode_swigregister = _pyAgrum.InvalidNode_swigregister
InvalidNode_swigregister(InvalidNode)

class EmptyBSTree(GraphError):
    """Proxy of C++ gum::EmptyBSTree class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptyBSTree, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptyBSTree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "the binary search tree is empty") -> EmptyBSTree
        __init__(self, string aMsg) -> EmptyBSTree
        """
        this = _pyAgrum.new_EmptyBSTree(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptyBSTree
    __del__ = lambda self : None;
EmptyBSTree_swigregister = _pyAgrum.EmptyBSTree_swigregister
EmptyBSTree_swigregister(EmptyBSTree)

class DefaultInLabel(GraphError):
    """Proxy of C++ gum::DefaultInLabel class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultInLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultInLabel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "Error on label") -> DefaultInLabel
        __init__(self, string aMsg) -> DefaultInLabel
        """
        this = _pyAgrum.new_DefaultInLabel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DefaultInLabel
    __del__ = lambda self : None;
DefaultInLabel_swigregister = _pyAgrum.DefaultInLabel_swigregister
DefaultInLabel_swigregister(DefaultInLabel)

class InvalidDirectedCycle(GraphError):
    """Proxy of C++ gum::InvalidDirectedCycle class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidDirectedCycle, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidDirectedCycle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "the graph contains a directed cycle") -> InvalidDirectedCycle
        __init__(self, string aMsg) -> InvalidDirectedCycle
        """
        this = _pyAgrum.new_InvalidDirectedCycle(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidDirectedCycle
    __del__ = lambda self : None;
InvalidDirectedCycle_swigregister = _pyAgrum.InvalidDirectedCycle_swigregister
InvalidDirectedCycle_swigregister(InvalidDirectedCycle)

class CPTError(Exception):
    """Proxy of C++ gum::CPTError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "CPT error") -> CPTError
        __init__(self, string aMsg) -> CPTError
        """
        this = _pyAgrum.new_CPTError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTError
    __del__ = lambda self : None;
CPTError_swigregister = _pyAgrum.CPTError_swigregister
CPTError_swigregister(CPTError)

class CPTNoSumTo1(CPTError):
    """Proxy of C++ gum::CPTNoSumTo1 class"""
    __swig_setmethods__ = {}
    for _s in [CPTError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTNoSumTo1, name, value)
    __swig_getmethods__ = {}
    for _s in [CPTError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTNoSumTo1, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "CPT does not sum to 1") -> CPTNoSumTo1
        __init__(self, string aMsg) -> CPTNoSumTo1
        """
        this = _pyAgrum.new_CPTNoSumTo1(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTNoSumTo1
    __del__ = lambda self : None;
CPTNoSumTo1_swigregister = _pyAgrum.CPTNoSumTo1_swigregister
CPTNoSumTo1_swigregister(CPTNoSumTo1)

class FactoryError(Exception):
    """Proxy of C++ gum::FactoryError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "factory error") -> FactoryError
        __init__(self, string aMsg) -> FactoryError
        """
        this = _pyAgrum.new_FactoryError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryError
    __del__ = lambda self : None;
FactoryError_swigregister = _pyAgrum.FactoryError_swigregister
FactoryError_swigregister(FactoryError)

class FactoryInvalidState(FactoryError):
    """Proxy of C++ gum::FactoryInvalidState class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryInvalidState, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryInvalidState, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "invalid state error") -> FactoryInvalidState
        __init__(self, string aMsg) -> FactoryInvalidState
        """
        this = _pyAgrum.new_FactoryInvalidState(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryInvalidState
    __del__ = lambda self : None;
FactoryInvalidState_swigregister = _pyAgrum.FactoryInvalidState_swigregister
FactoryInvalidState_swigregister(FactoryInvalidState)

class WrongType(FactoryError):
    """Proxy of C++ gum::WrongType class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongType, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongType, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "wrong type for this operation") -> WrongType
        __init__(self, string aMsg) -> WrongType
        """
        this = _pyAgrum.new_WrongType(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongType
    __del__ = lambda self : None;
WrongType_swigregister = _pyAgrum.WrongType_swigregister
WrongType_swigregister(WrongType)

class WrongClassElement(FactoryError):
    """Proxy of C++ gum::WrongClassElement class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongClassElement, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongClassElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "wrong ClassElement for this operation") -> WrongClassElement
        __init__(self, string aMsg) -> WrongClassElement
        """
        this = _pyAgrum.new_WrongClassElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongClassElement
    __del__ = lambda self : None;
WrongClassElement_swigregister = _pyAgrum.WrongClassElement_swigregister
WrongClassElement_swigregister(WrongClassElement)

class TypeError(FactoryError):
    """Proxy of C++ gum::TypeError class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeError, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TypeError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, string aType = "wrong subtype or subclass") -> TypeError
        __init__(self, string aMsg) -> TypeError
        """
        this = _pyAgrum.new_TypeError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_TypeError
    __del__ = lambda self : None;
TypeError_swigregister = _pyAgrum.TypeError_swigregister
TypeError_swigregister(TypeError)

class SyntaxError(IOError):
    """Proxy of C++ gum::SyntaxError class"""
    __swig_setmethods__ = {}
    for _s in [IOError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SyntaxError, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SyntaxError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aMsg, Size nol, Size noc, string aType = "Syntax Error") -> SyntaxError
        __init__(self, string aMsg, Size nol, Size noc) -> SyntaxError
        """
        this = _pyAgrum.new_SyntaxError(*args)
        try: self.this.append(this)
        except: self.this = this
    def col(self):
        """col(self) -> Size"""
        return _pyAgrum.SyntaxError_col(self)

    def line(self):
        """line(self) -> Size"""
        return _pyAgrum.SyntaxError_line(self)

    __swig_destroy__ = _pyAgrum.delete_SyntaxError
    __del__ = lambda self : None;
SyntaxError_swigregister = _pyAgrum.SyntaxError_swigregister
SyntaxError_swigregister(SyntaxError)

class SetIteratorStaticEnd(_object):
    """Proxy of C++ gum::SetIteratorStaticEnd class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SetIteratorStaticEnd, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SetIteratorStaticEnd, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> SetIteratorStaticEnd"""
        this = _pyAgrum.new_SetIteratorStaticEnd()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_SetIteratorStaticEnd
    __del__ = lambda self : None;
SetIteratorStaticEnd_swigregister = _pyAgrum.SetIteratorStaticEnd_swigregister
SetIteratorStaticEnd_swigregister(SetIteratorStaticEnd)


def randomProba():
  """randomProba() -> double"""
  return _pyAgrum.randomProba()

def isOMP():
  """isOMP() -> bool"""
  return _pyAgrum.isOMP()

def setNumberOfThreads(*args):
  """setNumberOfThreads(unsigned int number)"""
  return _pyAgrum.setNumberOfThreads(*args)

def getMaxNumberOfThreads():
  """getMaxNumberOfThreads() -> unsigned int"""
  return _pyAgrum.getMaxNumberOfThreads()

def getThreadNumber():
  """getThreadNumber() -> unsigned int"""
  return _pyAgrum.getThreadNumber()

def getNumberOfRunningThreads():
  """getNumberOfRunningThreads() -> unsigned int"""
  return _pyAgrum.getNumberOfRunningThreads()

def getNumberOfLogicalProcessors():
  """getNumberOfLogicalProcessors() -> unsigned int"""
  return _pyAgrum.getNumberOfLogicalProcessors()

def setNestedParallelism(*args):
  """setNestedParallelism(bool value)"""
  return _pyAgrum.setNestedParallelism(*args)

def getNestedParallelism():
  """getNestedParallelism() -> bool"""
  return _pyAgrum.getNestedParallelism()

def setDynamicThreadsNumber(*args):
  """setDynamicThreadsNumber(bool value)"""
  return _pyAgrum.setDynamicThreadsNumber(*args)

def getDynamicThreadsNumber():
  """getDynamicThreadsNumber() -> bool"""
  return _pyAgrum.getDynamicThreadsNumber()
class Variable(_object):
    """Proxy of C++ gum::Variable class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_Variable
    __del__ = lambda self : None;
    def clone(self):
        """clone(self) -> Variable"""
        return _pyAgrum.Variable_clone(self)

    def __eq__(self, *args):
        """__eq__(self, Variable aRV) -> bool"""
        return _pyAgrum.Variable___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Variable aRV) -> bool"""
        return _pyAgrum.Variable___ne__(self, *args)

    def setName(self, *args):
        """setName(self, string theValue)"""
        return _pyAgrum.Variable_setName(self, *args)

    def name(self):
        """name(self) -> string"""
        return _pyAgrum.Variable_name(self)

    def setDescription(self, *args):
        """setDescription(self, string theValue)"""
        return _pyAgrum.Variable_setDescription(self, *args)

    def description(self):
        """description(self) -> string"""
        return _pyAgrum.Variable_description(self)

Variable_swigregister = _pyAgrum.Variable_swigregister
Variable_swigregister(Variable)

def initRandom(init = 0):
  """
    initRandom(unsigned int init = 0)
    initRandom()
    """
  return _pyAgrum.initRandom(init)

class DiscreteVar(Variable):
    """Proxy of C++ gum::DiscreteVariable class"""
    __swig_setmethods__ = {}
    for _s in [Variable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteVar, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteVar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Discretized = _pyAgrum.DiscreteVar_Discretized
    Labelized = _pyAgrum.DiscreteVar_Labelized
    Range = _pyAgrum.DiscreteVar_Range
    __swig_destroy__ = _pyAgrum.delete_DiscreteVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(self) -> DiscreteVar"""
        return _pyAgrum.DiscreteVar_clone(self)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.DiscreteVar_empty(self)

    def __len__(self):
        """__len__(self) -> Size"""
        return _pyAgrum.DiscreteVar___len__(self)

    def label(self, *args):
        """label(self, Idx indice) -> string"""
        return _pyAgrum.DiscreteVar_label(self, *args)

    def type(self):
        """type(self) -> Type"""
        return _pyAgrum.DiscreteVar_type(self)

    def __eq__(self, *args):
        """__eq__(self, DiscreteVar aRV) -> bool"""
        return _pyAgrum.DiscreteVar___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, DiscreteVar aRV) -> bool"""
        return _pyAgrum.DiscreteVar___ne__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, string label) -> Idx"""
        return _pyAgrum.DiscreteVar___getitem__(self, *args)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.DiscreteVar___str__(self)

    def toLabelizedVar(self):
        """toLabelizedVar(self) -> LabelizedVar"""
        return _pyAgrum.DiscreteVar_toLabelizedVar(self)

    def toRangeVar(self):
        """toRangeVar(self) -> RangeVar"""
        return _pyAgrum.DiscreteVar_toRangeVar(self)

    def toDiscretizedVar(self):
        """toDiscretizedVar(self) -> DiscretizedVar"""
        return _pyAgrum.DiscreteVar_toDiscretizedVar(self)

DiscreteVar_swigregister = _pyAgrum.DiscreteVar_swigregister
DiscreteVar_swigregister(DiscreteVar)

class LabelizedVar(DiscreteVar):
    """Proxy of C++ gum::LabelizedVariable class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVar]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelizedVar, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVar]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelizedVar, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_LabelizedVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(self) -> DiscreteVar"""
        return _pyAgrum.LabelizedVar_clone(self)

    def __getitem__(self, *args):
        """__getitem__(self, string aLabel) -> Idx"""
        return _pyAgrum.LabelizedVar___getitem__(self, *args)

    def isLabel(self, *args):
        """isLabel(self, string aLabel) -> bool"""
        return _pyAgrum.LabelizedVar_isLabel(self, *args)

    def addLabel(self,*args):
      _pyAgrum.LabelizedVar_addLabel(self,*args)
      return self


    def eraseLabels(self):
        """eraseLabels(self)"""
        return _pyAgrum.LabelizedVar_eraseLabels(self)

    def label(self, *args):
        """label(self, Idx i) -> string"""
        return _pyAgrum.LabelizedVar_label(self, *args)

    def __len__(self):
        """__len__(self) -> Size"""
        return _pyAgrum.LabelizedVar___len__(self)

    def labels(self):
        """labels(self) -> Sequence_string"""
        return _pyAgrum.LabelizedVar_labels(self)

    def type(self):
        """type(self) -> Type"""
        return _pyAgrum.LabelizedVar_type(self)

    def __init__(self, *args): 
        """
        LabelizedVariable(string aName, string aDesc = "", int nbrLabel = 2) -> LabelizedVar
        LabelizedVariable(string aName, string aDesc = "") -> LabelizedVar
        LabelizedVariable(string aName) -> LabelizedVar
        LabelizedVariable(LabelizedVar aLDRV) -> LabelizedVar
        __init__(self) -> LabelizedVar
        """
        if self.__class__ == LabelizedVar:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_LabelizedVar(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_LabelizedVar(self)
        return weakref_proxy(self)
LabelizedVar_swigregister = _pyAgrum.LabelizedVar_swigregister
LabelizedVar_swigregister(LabelizedVar)

class RangeVar(DiscreteVar):
    """Proxy of C++ gum::RangeVariable class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVar]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RangeVar, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVar]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RangeVar, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        RangeVariable(string aName, string aDesc, Idx minVal = 0, Idx maxVal = 1) -> RangeVar
        RangeVariable(string aName, string aDesc, Idx minVal = 0) -> RangeVar
        RangeVariable(string aName, string aDesc) -> RangeVar
        __init__(self, RangeVar aDRV) -> RangeVar
        """
        this = _pyAgrum.new_RangeVar(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_RangeVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(self) -> DiscreteVar"""
        return _pyAgrum.RangeVar_clone(self)

    def __len__(self):
        """__len__(self) -> Size"""
        return _pyAgrum.RangeVar___len__(self)

    def type(self):
        """type(self) -> Type"""
        return _pyAgrum.RangeVar_type(self)

    def label(self, *args):
        """label(self, Idx indice) -> string"""
        return _pyAgrum.RangeVar_label(self, *args)

    def min(self):
        """min(self) -> Idx"""
        return _pyAgrum.RangeVar_min(self)

    def setMin(self, *args):
        """setMin(self, Idx minVal)"""
        return _pyAgrum.RangeVar_setMin(self, *args)

    def max(self):
        """max(self) -> Idx"""
        return _pyAgrum.RangeVar_max(self)

    def setMax(self, *args):
        """setMax(self, Idx maxVal)"""
        return _pyAgrum.RangeVar_setMax(self, *args)

    def belongs(self, *args):
        """belongs(self, Idx indice) -> bool"""
        return _pyAgrum.RangeVar_belongs(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, string arg0) -> Idx"""
        return _pyAgrum.RangeVar___getitem__(self, *args)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.RangeVar___str__(self)

RangeVar_swigregister = _pyAgrum.RangeVar_swigregister
RangeVar_swigregister(RangeVar)

INC_MARKS_ARRAY = _pyAgrum.INC_MARKS_ARRAY
class Edge(_object):
    """Proxy of C++ gum::Edge class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Edge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Edge, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, NodeId aN1, NodeId aN2) -> Edge
        __init__(self, Edge src) -> Edge
        """
        this = _pyAgrum.new_Edge(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Edge
    __del__ = lambda self : None;
    def isDirected(self):
        """isDirected(self) -> bool"""
        return _pyAgrum.Edge_isDirected(self)

    def other(self, *args):
        """other(self, NodeId id) -> NodeId"""
        return _pyAgrum.Edge_other(self, *args)

    def first(self):
        """first(self) -> NodeId"""
        return _pyAgrum.Edge_first(self)

    def second(self):
        """second(self) -> NodeId"""
        return _pyAgrum.Edge_second(self)

    def __eq__(self, *args):
        """__eq__(self, Edge src) -> bool"""
        return _pyAgrum.Edge___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Edge src) -> bool"""
        return _pyAgrum.Edge___ne__(self, *args)

Edge_swigregister = _pyAgrum.Edge_swigregister
Edge_swigregister(Edge)

class Arc(_object):
    """Proxy of C++ gum::Arc class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Arc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Arc, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, NodeId tail, NodeId head) -> Arc
        __init__(self, Arc src) -> Arc
        """
        this = _pyAgrum.new_Arc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Arc
    __del__ = lambda self : None;
    def tail(self):
        """tail(self) -> NodeId"""
        return _pyAgrum.Arc_tail(self)

    def head(self):
        """head(self) -> NodeId"""
        return _pyAgrum.Arc_head(self)

    def isDirected(self):
        """isDirected(self) -> bool"""
        return _pyAgrum.Arc_isDirected(self)

    def other(self, *args):
        """other(self, NodeId id) -> NodeId"""
        return _pyAgrum.Arc_other(self, *args)

    def first(self):
        """first(self) -> NodeId"""
        return _pyAgrum.Arc_first(self)

    def second(self):
        """second(self) -> NodeId"""
        return _pyAgrum.Arc_second(self)

    def __eq__(self, *args):
        """__eq__(self, Arc src) -> bool"""
        return _pyAgrum.Arc___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Arc src) -> bool"""
        return _pyAgrum.Arc___ne__(self, *args)

Arc_swigregister = _pyAgrum.Arc_swigregister
Arc_swigregister(Arc)

class DiGraph(_object):
    """Proxy of C++ gum::DiGraph class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DiGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, Size nodes_size = GUM_HASHTABLE_DEFAULT_SIZE, bool nodes_resize_policy = True, 
            Size arcs_size = GUM_HASHTABLE_DEFAULT_SIZE, 
            bool arcs_resize_policy = True) -> DiGraph
        __init__(self, Size nodes_size = GUM_HASHTABLE_DEFAULT_SIZE, bool nodes_resize_policy = True, 
            Size arcs_size = GUM_HASHTABLE_DEFAULT_SIZE) -> DiGraph
        __init__(self, Size nodes_size = GUM_HASHTABLE_DEFAULT_SIZE, bool nodes_resize_policy = True) -> DiGraph
        __init__(self, Size nodes_size = GUM_HASHTABLE_DEFAULT_SIZE) -> DiGraph
        __init__(self) -> DiGraph
        __init__(self, DiGraph g) -> DiGraph
        """
        this = _pyAgrum.new_DiGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiGraph
    __del__ = lambda self : None;
    def __eq__(self, *args):
        """__eq__(self, DiGraph g) -> bool"""
        return _pyAgrum.DiGraph___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, DiGraph g) -> bool"""
        return _pyAgrum.DiGraph___ne__(self, *args)

    def insertArc(self, *args):
        """insertArc(self, NodeId tail, NodeId head)"""
        return _pyAgrum.DiGraph_insertArc(self, *args)

    def eraseNode(self, *args):
        """eraseNode(self, NodeId id)"""
        return _pyAgrum.DiGraph_eraseNode(self, *args)

    def clear(self):
        """clear(self)"""
        return _pyAgrum.DiGraph_clear(self)

    def toString(self):
        """toString(self) -> string"""
        return _pyAgrum.DiGraph_toString(self)

    def toDot(self, name = "G"):
        """
        toDot(self, string name = "G") -> string
        toDot(self) -> string
        """
        return _pyAgrum.DiGraph_toDot(self, name)

DiGraph_swigregister = _pyAgrum.DiGraph_swigregister
DiGraph_swigregister(DiGraph)

class MultiDimInterface(_object):
    """Proxy of C++ gum::MultiDimInterface class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimInterface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimInterface
    __del__ = lambda self : None;
    def nbrDim(self):
        """nbrDim(self) -> Idx"""
        return _pyAgrum.MultiDimInterface_nbrDim(self)

    def domainSize(self):
        """domainSize(self) -> Size"""
        return _pyAgrum.MultiDimInterface_domainSize(self)

    def add(self, *args):
        """add(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimInterface_add(self, *args)

    def erase(self, *args):
        """erase(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimInterface_erase(self, *args)

    def variablesSequence(self):
        """variablesSequence(self) -> gum::Sequence<(p.q(const).gum::DiscreteVariable)>"""
        return _pyAgrum.MultiDimInterface_variablesSequence(self)

    def variable(self, *args):
        """variable(self, Idx i) -> DiscreteVar"""
        return _pyAgrum.MultiDimInterface_variable(self, *args)

    def pos(self, *args):
        """pos(self, DiscreteVar v) -> Idx"""
        return _pyAgrum.MultiDimInterface_pos(self, *args)

    def contains(self, *args):
        """contains(self, DiscreteVar v) -> bool"""
        return _pyAgrum.MultiDimInterface_contains(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.MultiDimInterface_empty(self)

    def swap(self, *args):
        """swap(self, DiscreteVar x, DiscreteVar y)"""
        return _pyAgrum.MultiDimInterface_swap(self, *args)

    def begin(self):
        """begin(self) -> iterator"""
        return _pyAgrum.MultiDimInterface_begin(self)

    def rbegin(self):
        """rbegin(self) -> iterator"""
        return _pyAgrum.MultiDimInterface_rbegin(self)

    def end(self):
        """end(self) -> iterator"""
        return _pyAgrum.MultiDimInterface_end(self)

    def rend(self):
        """rend(self) -> iterator"""
        return _pyAgrum.MultiDimInterface_rend(self)

MultiDimInterface_swigregister = _pyAgrum.MultiDimInterface_swigregister
MultiDimInterface_swigregister(MultiDimInterface)

class Instantiation(MultiDimInterface):
    """Proxy of C++ gum::Instantiation class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimInterface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Instantiation, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimInterface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Instantiation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Instantiation
        __init__(self, Instantiation aI, bool notifyMaster = True) -> Instantiation
        __init__(self, Instantiation aI) -> Instantiation
        __init__(self, MultiDimAdressable aMD) -> Instantiation
        __init__(self, MultiDimAdressable aMD) -> Instantiation
        __init__(self, MultiDimAdressable aMD) -> Instantiation
        __init__(self, MultiDimAdressable aMD) -> Instantiation
        """
        this = _pyAgrum.new_Instantiation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Instantiation
    __del__ = lambda self : None;
    def __len__(self):
        """__len__(self) -> Idx"""
        return _pyAgrum.Instantiation___len__(self)

    def add(self, *args):
        """add(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_add(self, *args)

    def erase(self, *args):
        """erase(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_erase(self, *args)

    def clear(self):
        """clear(self)"""
        return _pyAgrum.Instantiation_clear(self)

    def domainSize(self):
        """domainSize(self) -> Size"""
        return _pyAgrum.Instantiation_domainSize(self)

    def pos(self, *args):
        """pos(self, DiscreteVar v) -> Idx"""
        return _pyAgrum.Instantiation_pos(self, *args)

    def val(self, *args):
        """
        val(self, Idx i) -> Idx
        val(self, DiscreteVar var) -> Idx
        """
        return _pyAgrum.Instantiation_val(self, *args)

    def valFromPtr(self, *args):
        """valFromPtr(self, DiscreteVar pvar) -> Idx"""
        return _pyAgrum.Instantiation_valFromPtr(self, *args)

    def variable(self, *args):
        """variable(self, Idx i) -> DiscreteVar"""
        return _pyAgrum.Instantiation_variable(self, *args)

    def chgVal(self, *args):
        """
        chgVal(self, DiscreteVar v, Idx newval) -> Instantiation
        chgVal(self, DiscreteVar v, Idx newval) -> Instantiation
        chgVal(self, Idx varPos, Idx newval) -> Instantiation
        """
        return _pyAgrum.Instantiation_chgVal(self, *args)

    def setVals(self, *args):
        """setVals(self, Instantiation i) -> Instantiation"""
        return _pyAgrum.Instantiation_setVals(self, *args)

    def contains(self, *args):
        """
        contains(self, DiscreteVar v) -> bool
        contains(self, DiscreteVar v) -> bool
        """
        return _pyAgrum.Instantiation_contains(self, *args)

    def variablesSequence(self):
        """variablesSequence(self) -> gum::Sequence<(p.q(const).gum::DiscreteVariable)>"""
        return _pyAgrum.Instantiation_variablesSequence(self)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.Instantiation_empty(self)

    def inOverflow(self):
        """inOverflow(self) -> bool"""
        return _pyAgrum.Instantiation_inOverflow(self)

    def unsetOverflow(self):
        """unsetOverflow(self)"""
        return _pyAgrum.Instantiation_unsetOverflow(self)

    def unsetEnd(self):
        """unsetEnd(self)"""
        return _pyAgrum.Instantiation_unsetEnd(self)

    def end(self):
        """end(self) -> bool"""
        return _pyAgrum.Instantiation_end(self)

    def rend(self):
        """rend(self) -> bool"""
        return _pyAgrum.Instantiation_rend(self)

    def inc(self):
        """inc(self)"""
        return _pyAgrum.Instantiation_inc(self)

    def dec(self):
        """dec(self)"""
        return _pyAgrum.Instantiation_dec(self)

    def incIn(self, *args):
        """incIn(self, Instantiation i)"""
        return _pyAgrum.Instantiation_incIn(self, *args)

    def decIn(self, *args):
        """decIn(self, Instantiation i)"""
        return _pyAgrum.Instantiation_decIn(self, *args)

    def incOut(self, *args):
        """incOut(self, Instantiation i)"""
        return _pyAgrum.Instantiation_incOut(self, *args)

    def decOut(self, *args):
        """decOut(self, Instantiation i)"""
        return _pyAgrum.Instantiation_decOut(self, *args)

    def incNotVar(self, *args):
        """incNotVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_incNotVar(self, *args)

    def decNotVar(self, *args):
        """decNotVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_decNotVar(self, *args)

    def incVar(self, *args):
        """incVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_incVar(self, *args)

    def decVar(self, *args):
        """decVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_decVar(self, *args)

    def setFirst(self):
        """setFirst(self)"""
        return _pyAgrum.Instantiation_setFirst(self)

    def setLast(self):
        """setLast(self)"""
        return _pyAgrum.Instantiation_setLast(self)

    def setFirstIn(self, *args):
        """setFirstIn(self, Instantiation i)"""
        return _pyAgrum.Instantiation_setFirstIn(self, *args)

    def setLastIn(self, *args):
        """setLastIn(self, Instantiation i)"""
        return _pyAgrum.Instantiation_setLastIn(self, *args)

    def setFirstOut(self, *args):
        """setFirstOut(self, Instantiation i)"""
        return _pyAgrum.Instantiation_setFirstOut(self, *args)

    def setLastOut(self, *args):
        """setLastOut(self, Instantiation i)"""
        return _pyAgrum.Instantiation_setLastOut(self, *args)

    def setFirstNotVar(self, *args):
        """setFirstNotVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setFirstNotVar(self, *args)

    def setLastNotVar(self, *args):
        """setLastNotVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setLastNotVar(self, *args)

    def setFirstVar(self, *args):
        """setFirstVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setFirstVar(self, *args)

    def setLastVar(self, *args):
        """setLastVar(self, DiscreteVar v)"""
        return _pyAgrum.Instantiation_setLastVar(self, *args)

    def actAsSlave(self, *args):
        """actAsSlave(self, MultiDimAdressable aMD) -> bool"""
        return _pyAgrum.Instantiation_actAsSlave(self, *args)

    def forgetMaster(self):
        """forgetMaster(self) -> bool"""
        return _pyAgrum.Instantiation_forgetMaster(self)

    def isSlave(self):
        """isSlave(self) -> bool"""
        return _pyAgrum.Instantiation_isSlave(self)

    def isMaster(self, *args):
        """
        isMaster(self, MultiDimAdressable m) -> bool
        isMaster(self, MultiDimAdressable m) -> bool
        """
        return _pyAgrum.Instantiation_isMaster(self, *args)

    def synchronizeWithMaster(self, *args):
        """synchronizeWithMaster(self, MultiDimAdressable m)"""
        return _pyAgrum.Instantiation_synchronizeWithMaster(self, *args)

    def addWithMaster(self, *args):
        """addWithMaster(self, MultiDimAdressable m, DiscreteVar v)"""
        return _pyAgrum.Instantiation_addWithMaster(self, *args)

    def eraseWithMaster(self, *args):
        """eraseWithMaster(self, MultiDimAdressable m, DiscreteVar v)"""
        return _pyAgrum.Instantiation_eraseWithMaster(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, Id depl) -> Instantiation"""
        return _pyAgrum.Instantiation___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Id depl) -> Instantiation"""
        return _pyAgrum.Instantiation___isub__(self, *args)

    def hamming(self):
        """hamming(self) -> Idx"""
        return _pyAgrum.Instantiation_hamming(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.Instantiation___str__(self)

    def reorder(self, *args):
        """
        reorder(self, gum::Sequence<(p.q(const).gum::DiscreteVariable)> v)
        reorder(self, Instantiation i)
        """
        return _pyAgrum.Instantiation_reorder(self, *args)

Instantiation_swigregister = _pyAgrum.Instantiation_swigregister
Instantiation_swigregister(Instantiation)


def ___get__list_end():
  """___get__list_end() -> void"""
  return _pyAgrum.___get__list_end()
GUM_LIST_ITERATOR_BEGIN = _pyAgrum.GUM_LIST_ITERATOR_BEGIN
GUM_LIST_ITERATOR_RBEGIN = _pyAgrum.GUM_LIST_ITERATOR_RBEGIN
GUM_LIST_ITERATOR_END = _pyAgrum.GUM_LIST_ITERATOR_END
GUM_LIST_ITERATOR_REND = _pyAgrum.GUM_LIST_ITERATOR_REND
class DAGmodel(_object):
    """Proxy of C++ gum::DAGmodel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DAGmodel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DAGmodel, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_DAGmodel
    __del__ = lambda self : None;
    def property(self, *args):
        """property(self, string name) -> string"""
        return _pyAgrum.DAGmodel_property(self, *args)

    def setProperty(self, *args):
        """setProperty(self, string name, string value)"""
        return _pyAgrum.DAGmodel_setProperty(self, *args)

    def dag(self):
        """dag(self) -> DAG"""
        return _pyAgrum.DAGmodel_dag(self)

    def variableNodeMap(self):
        """variableNodeMap(self) -> VariableNodeMap"""
        return _pyAgrum.DAGmodel_variableNodeMap(self)

    def __len__(self):
        """__len__(self) -> Idx"""
        return _pyAgrum.DAGmodel___len__(self)

    def nbrArcs(self):
        """nbrArcs(self) -> Idx"""
        return _pyAgrum.DAGmodel_nbrArcs(self)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.DAGmodel_empty(self)

    def beginNodes(self):
        """beginNodes(self) -> NodeIterator"""
        return _pyAgrum.DAGmodel_beginNodes(self)

    def endNodes(self):
        """endNodes(self) -> NodeIterator"""
        return _pyAgrum.DAGmodel_endNodes(self)

    def variable(self, *args):
        """variable(self, NodeId id) -> DiscreteVar"""
        return _pyAgrum.DAGmodel_variable(self, *args)

    def nodeId(self, *args):
        """nodeId(self, DiscreteVar var) -> NodeId"""
        return _pyAgrum.DAGmodel_nodeId(self, *args)

    def idFromName(self, *args):
        """idFromName(self, string name) -> NodeId"""
        return _pyAgrum.DAGmodel_idFromName(self, *args)

    def variableFromName(self, *args):
        """variableFromName(self, string name) -> DiscreteVar"""
        return _pyAgrum.DAGmodel_variableFromName(self, *args)

    def completeInstantiation(self, *args):
        """completeInstantiation(self, Instantiation I)"""
        return _pyAgrum.DAGmodel_completeInstantiation(self, *args)

    def beginArcs(self):
        """beginArcs(self) -> ArcIterator"""
        return _pyAgrum.DAGmodel_beginArcs(self)

    def endArcs(self):
        """endArcs(self) -> ArcIterator"""
        return _pyAgrum.DAGmodel_endArcs(self)

    def moralGraph(self, clear = True):
        """
        moralGraph(self, bool clear = True) -> UndiGraph
        moralGraph(self) -> UndiGraph
        """
        return _pyAgrum.DAGmodel_moralGraph(self, clear)

    def topologicalOrder(self, clear = True):
        """
        topologicalOrder(self, bool clear = True) -> Sequence_node
        topologicalOrder(self) -> Sequence_node
        """
        return _pyAgrum.DAGmodel_topologicalOrder(self, clear)

    def log10DomainSize(self):
        """log10DomainSize(self) -> double"""
        return _pyAgrum.DAGmodel_log10DomainSize(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.DAGmodel___str__(self)

    def toDot(self):
        """toDot(self) -> string"""
        return _pyAgrum.DAGmodel_toDot(self)

DAGmodel_swigregister = _pyAgrum.DAGmodel_swigregister
DAGmodel_swigregister(DAGmodel)
cvar = _pyAgrum.cvar
__list_end = cvar.__list_end


def randomDistribution(*args):
  """randomDistribution(Size n) -> Vector_double"""
  return _pyAgrum.randomDistribution(*args)
class Sequence_node(_object):
    """Proxy of C++ gum::Sequence<(gum::NodeId)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sequence_node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Sequence_node, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Sequence_node
        __init__(self, Sequence_node aSeq) -> Sequence_node
        """
        this = _pyAgrum.new_Sequence_node(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Sequence_node
    __del__ = lambda self : None;
    def begin(self):
        """begin(self) -> gum::Sequence<(unsigned int)>::iterator"""
        return _pyAgrum.Sequence_node_begin(self)

    def rbegin(self):
        """rbegin(self) -> gum::Sequence<(unsigned int)>::iterator"""
        return _pyAgrum.Sequence_node_rbegin(self)

    def end(self):
        """end(self) -> gum::Sequence<(unsigned int)>::iterator"""
        return _pyAgrum.Sequence_node_end(self)

    def rend(self):
        """rend(self) -> gum::Sequence<(unsigned int)>::iterator"""
        return _pyAgrum.Sequence_node_rend(self)

    def __eq__(self, *args):
        """__eq__(self, Sequence_node k) -> bool"""
        return _pyAgrum.Sequence_node___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Sequence_node k) -> bool"""
        return _pyAgrum.Sequence_node___ne__(self, *args)

    def clear(self):
        """clear(self)"""
        return _pyAgrum.Sequence_node_clear(self)

    def size(self):
        """size(self) -> Size"""
        return _pyAgrum.Sequence_node_size(self)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.Sequence_node_empty(self)

    def exists(self, *args):
        """exists(self, unsigned int k) -> bool"""
        return _pyAgrum.Sequence_node_exists(self, *args)

    def append(self, *args):
        """append(self, unsigned int k)"""
        return _pyAgrum.Sequence_node_append(self, *args)

    def remove(self, *args):
        """remove(self, unsigned int k)"""
        return _pyAgrum.Sequence_node_remove(self, *args)

    def erase(self, *args):
        """erase(self, gum::Sequence<(unsigned int)>::iterator k)"""
        return _pyAgrum.Sequence_node_erase(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, Idx i) -> unsigned int"""
        return _pyAgrum.Sequence_node___getitem__(self, *args)

    def index(self, *args):
        """index(self, unsigned int key) -> Idx"""
        return _pyAgrum.Sequence_node_index(self, *args)

    def setAtPos(self, *args):
        """setAtPos(self, Idx i, unsigned int newKey)"""
        return _pyAgrum.Sequence_node_setAtPos(self, *args)

    def swap(self, *args):
        """swap(self, Idx i, Idx j)"""
        return _pyAgrum.Sequence_node_swap(self, *args)

    def front(self):
        """front(self) -> unsigned int"""
        return _pyAgrum.Sequence_node_front(self)

    def back(self):
        """back(self) -> unsigned int"""
        return _pyAgrum.Sequence_node_back(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.Sequence_node___str__(self)

    def resize(self, *args):
        """resize(self, unsigned int new_size)"""
        return _pyAgrum.Sequence_node_resize(self, *args)

    def diffSet(self, *args):
        """diffSet(self, Sequence_node seq) -> gum::Set<(unsigned int)>"""
        return _pyAgrum.Sequence_node_diffSet(self, *args)

Sequence_node_swigregister = _pyAgrum.Sequence_node_swigregister
Sequence_node_swigregister(Sequence_node)

class Sequence_string(_object):
    """Proxy of C++ gum::Sequence<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sequence_string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Sequence_string, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Sequence_string
        __init__(self, Sequence_string aSeq) -> Sequence_string
        """
        this = _pyAgrum.new_Sequence_string(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Sequence_string
    __del__ = lambda self : None;
    def begin(self):
        """begin(self) -> iterator"""
        return _pyAgrum.Sequence_string_begin(self)

    def rbegin(self):
        """rbegin(self) -> iterator"""
        return _pyAgrum.Sequence_string_rbegin(self)

    def end(self):
        """end(self) -> iterator"""
        return _pyAgrum.Sequence_string_end(self)

    def rend(self):
        """rend(self) -> iterator"""
        return _pyAgrum.Sequence_string_rend(self)

    def __eq__(self, *args):
        """__eq__(self, Sequence_string k) -> bool"""
        return _pyAgrum.Sequence_string___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Sequence_string k) -> bool"""
        return _pyAgrum.Sequence_string___ne__(self, *args)

    def clear(self):
        """clear(self)"""
        return _pyAgrum.Sequence_string_clear(self)

    def size(self):
        """size(self) -> Size"""
        return _pyAgrum.Sequence_string_size(self)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.Sequence_string_empty(self)

    def exists(self, *args):
        """exists(self, string k) -> bool"""
        return _pyAgrum.Sequence_string_exists(self, *args)

    def append(self, *args):
        """append(self, string k)"""
        return _pyAgrum.Sequence_string_append(self, *args)

    def remove(self, *args):
        """remove(self, string k)"""
        return _pyAgrum.Sequence_string_remove(self, *args)

    def erase(self, *args):
        """erase(self, iterator k)"""
        return _pyAgrum.Sequence_string_erase(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, Idx i) -> string"""
        return _pyAgrum.Sequence_string___getitem__(self, *args)

    def index(self, *args):
        """index(self, string key) -> Idx"""
        return _pyAgrum.Sequence_string_index(self, *args)

    def setAtPos(self, *args):
        """setAtPos(self, Idx i, string newKey)"""
        return _pyAgrum.Sequence_string_setAtPos(self, *args)

    def swap(self, *args):
        """swap(self, Idx i, Idx j)"""
        return _pyAgrum.Sequence_string_swap(self, *args)

    def front(self):
        """front(self) -> string"""
        return _pyAgrum.Sequence_string_front(self)

    def back(self):
        """back(self) -> string"""
        return _pyAgrum.Sequence_string_back(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.Sequence_string___str__(self)

    def resize(self, *args):
        """resize(self, unsigned int new_size)"""
        return _pyAgrum.Sequence_string_resize(self, *args)

    def diffSet(self, *args):
        """diffSet(self, Sequence_string seq) -> gum::Set<(std::string)>"""
        return _pyAgrum.Sequence_string_diffSet(self, *args)

Sequence_string_swigregister = _pyAgrum.Sequence_string_swigregister
Sequence_string_swigregister(Sequence_string)

class DiscretizedVar(DiscreteVar):
    """Proxy of C++ gum::DiscretizedVariable<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVar]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscretizedVar, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVar]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscretizedVar, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string aName, string aDesc) -> DiscretizedVar
        __init__(self, DiscretizedVar aDRV) -> DiscretizedVar
        """
        if self.__class__ == DiscretizedVar:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_DiscretizedVar(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiscretizedVar
    __del__ = lambda self : None;
    def clone(self):
        """clone(self) -> DiscreteVar"""
        return _pyAgrum.DiscretizedVar_clone(self)

    def type(self):
        """type(self) -> Type"""
        return _pyAgrum.DiscretizedVar_type(self)

    def isTick(self, *args):
        """isTick(self, float aTick) -> bool"""
        return _pyAgrum.DiscretizedVar_isTick(self, *args)

    def addTick(self,*args):
      _pyAgrum.DiscretizedVar_addTick(self,*args)
      return self


    def eraseTicks(self):
        """eraseTicks(self)"""
        return _pyAgrum.DiscretizedVar_eraseTicks(self)

    def label(self, *args):
        """label(self, Idx i) -> string"""
        return _pyAgrum.DiscretizedVar_label(self, *args)

    def __len__(self):
        """__len__(self) -> Size"""
        return _pyAgrum.DiscretizedVar___len__(self)

    def tick(self, *args):
        """tick(self, Idx i) -> float"""
        return _pyAgrum.DiscretizedVar_tick(self, *args)

    def index(self, *args):
        """index(self, float aTarget) -> Idx"""
        return _pyAgrum.DiscretizedVar_index(self, *args)

    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_DiscretizedVar(self)
        return weakref_proxy(self)
DiscretizedVar_swigregister = _pyAgrum.DiscretizedVar_swigregister
DiscretizedVar_swigregister(DiscretizedVar)

class MultiDimContainer_double(_object):
    """Proxy of C++ gum::MultiDimContainer<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimContainer_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimContainer_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimContainer_double
    __del__ = lambda self : None;
    def set(self, *args):
        """set(self, Instantiation i, double value)"""
        return _pyAgrum.MultiDimContainer_double_set(self, *args)

    def get(self, *args):
        """get(self, Instantiation i) -> double"""
        return _pyAgrum.MultiDimContainer_double_get(self, *args)

    def fill(self, *args):
        """fill(self, double d)"""
        return _pyAgrum.MultiDimContainer_double_fill(self, *args)

    def fillWith(self, *args):
        """fillWith(self, Vector_double v)"""
        return _pyAgrum.MultiDimContainer_double_fillWith(self, *args)

    def copyFrom(self, *args):
        """
        copyFrom(self, MultiDimContainer_double src, Instantiation p_i = (Instantiation *) 0)
        copyFrom(self, MultiDimContainer_double src)
        """
        return _pyAgrum.MultiDimContainer_double_copyFrom(self, *args)

    def copy(self, *args):
        """copy(self, MultiDimContainer_double src)"""
        return _pyAgrum.MultiDimContainer_double_copy(self, *args)

    def newFactory(self):
        """newFactory(self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimContainer_double_newFactory(self)

    def toString(self, *args):
        """
        toString(self) -> string
        toString(self, Instantiation i) -> string
        """
        return _pyAgrum.MultiDimContainer_double_toString(self, *args)

    def __eq__(self, *args):
        """__eq__(self, MultiDimContainer_double p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, MultiDimContainer_double p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___ne__(self, *args)

    def beginMultipleChanges(self):
        """beginMultipleChanges(self)"""
        return _pyAgrum.MultiDimContainer_double_beginMultipleChanges(self)

    def endMultipleChanges(self, *args):
        """
        endMultipleChanges(self)
        endMultipleChanges(self, double arg0)
        """
        return _pyAgrum.MultiDimContainer_double_endMultipleChanges(self, *args)

MultiDimContainer_double_swigregister = _pyAgrum.MultiDimContainer_double_swigregister
MultiDimContainer_double_swigregister(MultiDimContainer_double)

class MultiDimImplementation_double(MultiDimContainer_double):
    """Proxy of C++ gum::MultiDimImplementation<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimImplementation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimImplementation_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimImplementation_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimImplementation_double_newFactory(self)

    def get(self, *args):
        """get(self, Instantiation i) -> double"""
        return _pyAgrum.MultiDimImplementation_double_get(self, *args)

    def variablesSequence(self):
        """variablesSequence(self) -> gum::Sequence<(p.q(const).gum::DiscreteVariable)>"""
        return _pyAgrum.MultiDimImplementation_double_variablesSequence(self)

    def name(self):
        """name(self) -> string"""
        return _pyAgrum.MultiDimImplementation_double_name(self)

    def basename(self):
        """basename(self) -> string"""
        return _pyAgrum.MultiDimImplementation_double_basename(self)

    def add(self, *args):
        """add(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimImplementation_double_add(self, *args)

    def erase(self, *args):
        """erase(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimImplementation_double_erase(self, *args)

    def nbrDim(self):
        """nbrDim(self) -> Idx"""
        return _pyAgrum.MultiDimImplementation_double_nbrDim(self)

    def domainSize(self):
        """domainSize(self) -> Size"""
        return _pyAgrum.MultiDimImplementation_double_domainSize(self)

    def realSize(self):
        """realSize(self) -> Size"""
        return _pyAgrum.MultiDimImplementation_double_realSize(self)

    def compressionRate(self):
        """compressionRate(self) -> float"""
        return _pyAgrum.MultiDimImplementation_double_compressionRate(self)

    def variable(self, *args):
        """variable(self, Idx i) -> DiscreteVar"""
        return _pyAgrum.MultiDimImplementation_double_variable(self, *args)

    def pos(self, *args):
        """pos(self, DiscreteVar v) -> Idx"""
        return _pyAgrum.MultiDimImplementation_double_pos(self, *args)

    def contains(self, *args):
        """contains(self, DiscreteVar v) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_contains(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_empty(self)

    def getMasterRef(self, *args):
        """
        getMasterRef(self) -> MultiDimAdressable
        getMasterRef(self) -> MultiDimAdressable
        """
        return _pyAgrum.MultiDimImplementation_double_getMasterRef(self, *args)

    def registerSlave(self, *args):
        """registerSlave(self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_registerSlave(self, *args)

    def unregisterSlave(self, *args):
        """unregisterSlave(self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimImplementation_double_unregisterSlave(self, *args)

    def beginMultipleChanges(self):
        """beginMultipleChanges(self)"""
        return _pyAgrum.MultiDimImplementation_double_beginMultipleChanges(self)

    def endMultipleChanges(self, *args):
        """
        endMultipleChanges(self)
        endMultipleChanges(self, double arg0)
        """
        return _pyAgrum.MultiDimImplementation_double_endMultipleChanges(self, *args)

MultiDimImplementation_double_swigregister = _pyAgrum.MultiDimImplementation_double_swigregister
MultiDimImplementation_double_swigregister(MultiDimImplementation_double)

class MultiDimDecorator_double(MultiDimContainer_double):
    """Proxy of C++ gum::MultiDimDecorator<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimDecorator_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimContainer_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimDecorator_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimDecorator_double
    __del__ = lambda self : None;
    def domainSize(self):
        """domainSize(self) -> Size"""
        return _pyAgrum.MultiDimDecorator_double_domainSize(self)

    def add(self, *args):
        """add(self, DiscreteVar v)"""
        val = _pyAgrum.MultiDimDecorator_double_add(self, *args)
        self.__fill_distrib__()


        return val

    def variablesSequence(self):
        varlist = []
        for i in range(0, self.nbrDim()):
            varlist.append(self.variable(i))
        return varlist


    def nbrDim(self):
        """nbrDim(self) -> Idx"""
        return _pyAgrum.MultiDimDecorator_double_nbrDim(self)

    def remove(self, *args):
        """remove(self, DiscreteVar var)"""
        return _pyAgrum.MultiDimDecorator_double_remove(self, *args)

    def variable(self, *args):
        """variable(self, Idx arg0) -> DiscreteVar"""
        return _pyAgrum.MultiDimDecorator_double_variable(self, *args)

    def pos(self, *args):
        """pos(self, DiscreteVar arg0) -> Idx"""
        return _pyAgrum.MultiDimDecorator_double_pos(self, *args)

    def contains(self, *args):
        """contains(self, DiscreteVar arg0) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_contains(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_empty(self)

    def unregisterSlave(self, *args):
        """unregisterSlave(self, Instantiation arg0) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_unregisterSlave(self, *args)

    def registerSlave(self, *args):
        """registerSlave(self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimDecorator_double_registerSlave(self, *args)

    def fill(self, *args):
        """fill(self, double d)"""
        return _pyAgrum.MultiDimDecorator_double_fill(self, *args)

    def content(self, *args):
        """
        content(self) -> MultiDimImplementation_double
        content(self) -> MultiDimImplementation_double
        """
        return _pyAgrum.MultiDimDecorator_double_content(self, *args)

    def newFactory(self):
        """newFactory(self) -> MultiDimDecorator_double"""
        return _pyAgrum.MultiDimDecorator_double_newFactory(self)

    def changeNotification(self, *args):
        """changeNotification(self, Instantiation i, DiscreteVar var, Idx oldval, Idx newval)"""
        return _pyAgrum.MultiDimDecorator_double_changeNotification(self, *args)

    def setChangeNotification(self, *args):
        """setChangeNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setChangeNotification(self, *args)

    def setFirstNotification(self, *args):
        """setFirstNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setFirstNotification(self, *args)

    def setLastNotification(self, *args):
        """setLastNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setLastNotification(self, *args)

    def setIncNotification(self, *args):
        """setIncNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setIncNotification(self, *args)

    def setDecNotification(self, *args):
        """setDecNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimDecorator_double_setDecNotification(self, *args)

    def notifyChange(self):
        """notifyChange(self)"""
        return _pyAgrum.MultiDimDecorator_double_notifyChange(self)

    def getMasterRef(self, *args):
        """
        getMasterRef(self) -> MultiDimImplementation_double
        getMasterRef(self) -> MultiDimImplementation_double
        """
        return _pyAgrum.MultiDimDecorator_double_getMasterRef(self, *args)

    def beginMultipleChanges(self):
        """beginMultipleChanges(self)"""
        return _pyAgrum.MultiDimDecorator_double_beginMultipleChanges(self)

    def endMultipleChanges(self, *args):
        """
        endMultipleChanges(self)
        endMultipleChanges(self, double arg0)
        """
        return _pyAgrum.MultiDimDecorator_double_endMultipleChanges(self, *args)

    def toString(self, *args):
        """
        toString(self, Instantiation i) -> string
        toString(self) -> string
        """
        return _pyAgrum.MultiDimDecorator_double_toString(self, *args)

    def homothetic(self, *args):
        """homothetic(self, double alpha, double mul)"""
        return _pyAgrum.MultiDimDecorator_double_homothetic(self, *args)

    def fold(self, *args):
        """fold(self, double add) -> double"""
        return _pyAgrum.MultiDimDecorator_double_fold(self, *args)

    def set(self, *args):
        """set(self, Instantiation i, double value)"""
        return _pyAgrum.MultiDimDecorator_double_set(self, *args)

    def get(self, *args):
        """get(self, Instantiation i) -> double"""
        return _pyAgrum.MultiDimDecorator_double_get(self, *args)

MultiDimDecorator_double_swigregister = _pyAgrum.MultiDimDecorator_double_swigregister
MultiDimDecorator_double_swigregister(MultiDimDecorator_double)

class MultiDimWithOffset_double(MultiDimImplementation_double):
    """Proxy of C++ gum::MultiDimWithOffset<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimImplementation_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimWithOffset_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimImplementation_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimWithOffset_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimWithOffset_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimWithOffset_double_newFactory(self)

    def add(self, *args):
        """add(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimWithOffset_double_add(self, *args)

    def erase(self, *args):
        """erase(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimWithOffset_double_erase(self, *args)

    def fill(self, *args):
        """fill(self, double d)"""
        return _pyAgrum.MultiDimWithOffset_double_fill(self, *args)

    def toString(self, *args):
        """toString(self, Instantiation i) -> string"""
        return _pyAgrum.MultiDimWithOffset_double_toString(self, *args)

    def changeNotification(self, *args):
        """changeNotification(self, Instantiation i, DiscreteVar var, Idx oldval, Idx newval)"""
        return _pyAgrum.MultiDimWithOffset_double_changeNotification(self, *args)

    def setChangeNotification(self, *args):
        """setChangeNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setChangeNotification(self, *args)

    def setFirstNotification(self, *args):
        """setFirstNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setFirstNotification(self, *args)

    def setLastNotification(self, *args):
        """setLastNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setLastNotification(self, *args)

    def setIncNotification(self, *args):
        """setIncNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setIncNotification(self, *args)

    def setDecNotification(self, *args):
        """setDecNotification(self, Instantiation i)"""
        return _pyAgrum.MultiDimWithOffset_double_setDecNotification(self, *args)

    def registerSlave(self, *args):
        """registerSlave(self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimWithOffset_double_registerSlave(self, *args)

    def unregisterSlave(self, *args):
        """unregisterSlave(self, Instantiation i) -> bool"""
        return _pyAgrum.MultiDimWithOffset_double_unregisterSlave(self, *args)

    def toOffset(self, *args):
        """toOffset(self, Instantiation i) -> Size"""
        return _pyAgrum.MultiDimWithOffset_double_toOffset(self, *args)

    def fromOffset(self, *args):
        """fromOffset(self, Instantiation i, Size offset) -> Instantiation"""
        return _pyAgrum.MultiDimWithOffset_double_fromOffset(self, *args)

MultiDimWithOffset_double_swigregister = _pyAgrum.MultiDimWithOffset_double_swigregister
MultiDimWithOffset_double_swigregister(MultiDimWithOffset_double)

class MultiDimArray_double(MultiDimWithOffset_double):
    """Proxy of C++ gum::MultiDimArray<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimWithOffset_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimArray_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimWithOffset_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimArray_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> MultiDimArray_double
        __init__(self, MultiDimArray_double src) -> MultiDimArray_double
        """
        this = _pyAgrum.new_MultiDimArray_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_MultiDimArray_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimArray_double_newFactory(self)

    def add(self, *args):
        """add(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimArray_double_add(self, *args)

    def erase(self, *args):
        """erase(self, DiscreteVar v)"""
        return _pyAgrum.MultiDimArray_double_erase(self, *args)

    def realSize(self):
        """realSize(self) -> Size"""
        return _pyAgrum.MultiDimArray_double_realSize(self)

    def fill(self, *args):
        """fill(self, double d)"""
        return _pyAgrum.MultiDimArray_double_fill(self, *args)

    def unsafeGet(self, *args):
        """unsafeGet(self, Idx offset) -> double"""
        return _pyAgrum.MultiDimArray_double_unsafeGet(self, *args)

    def getByOffset(self, *args):
        """getByOffset(self, Idx offset) -> double"""
        return _pyAgrum.MultiDimArray_double_getByOffset(self, *args)

    def unsafeSet(self, *args):
        """unsafeSet(self, Idx offset, double arg1)"""
        return _pyAgrum.MultiDimArray_double_unsafeSet(self, *args)

    def setByOffset(self, *args):
        """setByOffset(self, Idx offset, double arg1)"""
        return _pyAgrum.MultiDimArray_double_setByOffset(self, *args)

    def name(self):
        """name(self) -> string"""
        return _pyAgrum.MultiDimArray_double_name(self)

MultiDimArray_double_swigregister = _pyAgrum.MultiDimArray_double_swigregister
MultiDimArray_double_swigregister(MultiDimArray_double)

class Potential_double(MultiDimDecorator_double):
    """Proxy of C++ gum::Potential<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [MultiDimDecorator_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Potential_double, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiDimDecorator_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Potential_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Potential_double
        __init__(self, MultiDimImplementation_double aContent) -> Potential_double
        __init__(self, Potential_double src) -> Potential_double
        __init__(self, MultiDimImplementation_double aContent, MultiDimContainer_double src) -> Potential_double
        """
        if self.__class__ == Potential_double:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_Potential_double(_self, *args)
        try: self.this.append(this)
        except: self.this = this
        self.__fill_distrib__()



    __swig_destroy__ = _pyAgrum.delete_Potential_double
    __del__ = lambda self : None;
    def newFactory(self):
        """newFactory(self) -> Potential_double"""
        return _pyAgrum.Potential_double_newFactory(self)

    def normalize(self):
        """normalize(self) -> Potential_double"""
        return _pyAgrum.Potential_double_normalize(self)

    def marginalize(self, *args):
        """marginalize(self, Potential_double p) -> Potential_double"""
        return _pyAgrum.Potential_double_marginalize(self, *args)

    def multiplicate(self, *args):
        """multiplicate(self, Potential_double p1, Potential_double p2)"""
        return _pyAgrum.Potential_double_multiplicate(self, *args)

    def multiplicateBy(self, *args):
        """multiplicateBy(self, Potential_double p1) -> Potential_double"""
        return _pyAgrum.Potential_double_multiplicateBy(self, *args)

    def sum(self):
        """sum(self) -> double"""
        return _pyAgrum.Potential_double_sum(self)

    def _swap(self, *args):
        """_swap(self, DiscreteVar x, DiscreteVar y)"""
        return _pyAgrum.Potential_double__swap(self, *args)

    def __mul__(self,p2):
        """
        return self * p2
        """
        p=Potential()
        p.multiplicate(self,p2)
        return p

    def eliminates(self,var):
        """
        eliminates a variable in the Potential. Returns the new Potential or self if the variable is not in self.
        @warning : returns a list with only one scalar if eliminates remove the last variable
        """
        if var.name() in self.var_names:
            q=Potential()
            for i in range(self.nbrDim()):
                if self.variable(i)!=var:
                    q.add(self.variable(i))
            if q.nbrDim()>0:
                q.marginalize(self)
            else:
                q=[self.sum()]
            return q
        else:
            return self

    def __indexfromdict__(self, id_dict):
        index = []
        #for id in id_dict:
        #    if not id in self._var_names:
        #        raise IndexError("\"%s\" is not a variable of this table !"
        #                         %(id))
        for name, dim in zip(self._var_names, self._var_dims):
            if name in id_dict:
                id_value = id_dict[name]
                if isinstance(id_value, str):
                    # id_value is a label of a LabelizedVar
                    i = self._var_names.index(name)
                    var = self.variable(len(self._var_names) - 1 - i)
                    id_value = var[id_value]
                if id_value >= dim:
                    raise IndexError("\"%s\" size is %d !"%(name, dim))
                index.append(id_value)
            else:
                index.append(slice(None, None, None)) # equivalent to ':'
        return tuple(index)


    def __str__(self):
        self.__fill_distrib__()
        return self.__distrib__.__str__()


    def tolist(self):
        self.__fill_distrib__()
        return self.__distrib__.tolist()


    def toarray(self):
        return numpy.array(self.tolist())


    def __getitem__(self, id):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        return self.__distrib__[id_slice]


    def __setitem__(self, id, value):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        self.__distrib__[id_slice] = value
        self.fillWith(self.__distrib__.reshape(self.__distrib__.size).tolist())


    @property
    def var_names(self):
        self.__fill_distrib__()
        return self._var_names


    @property
    def var_dims(self):
        self.__fill_distrib__()
        return self._var_dims


    def __fill_distrib__(self):
        self._var_names = []
        self._var_dims = []
        content = []
        if self.empty():
            self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
            return
        i = Instantiation(self)
        i.setFirst
        while not i.end():
            content.append(self.get(i))
            i.inc()
        self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
        for var in self.variablesSequence():
            self._var_names.append(var.name())
            self._var_dims.append(len(var))
        self._var_names.reverse()
        self._var_dims.reverse()
        self.__distrib__.shape = tuple(self._var_dims)


    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_Potential_double(self)
        return weakref_proxy(self)
    def _get(self, *args):
        """_get(self, Instantiation i) -> double"""
        return _pyAgrum.Potential_double__get(self, *args)

Potential_double_swigregister = _pyAgrum.Potential_double_swigregister
Potential_double_swigregister(Potential_double)

class BaseListPotentials_double(_object):
    """Proxy of C++ gum::ListBase<(p.q(const).gum::Potential<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseListPotentials_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BaseListPotentials_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> BaseListPotentials_double
        __init__(self, BaseListPotentials_double src) -> BaseListPotentials_double
        __init__(self, ListPotentials_double src) -> BaseListPotentials_double
        """
        this = _pyAgrum.new_BaseListPotentials_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_BaseListPotentials_double
    __del__ = lambda self : None;
    def push_front(self, *args):
        """push_front(self, Potential_double val) -> Potential_double"""
        return _pyAgrum.BaseListPotentials_double_push_front(self, *args)

    def push_back(self, *args):
        """push_back(self, Potential_double val) -> Potential_double"""
        return _pyAgrum.BaseListPotentials_double_push_back(self, *args)

    def front(self):
        """front(self) -> Potential_double"""
        return _pyAgrum.BaseListPotentials_double_front(self)

    def back(self):
        """back(self) -> Potential_double"""
        return _pyAgrum.BaseListPotentials_double_back(self)

    def size(self):
        """size(self) -> Size"""
        return _pyAgrum.BaseListPotentials_double_size(self)

    def exists(self, *args):
        """exists(self, Potential_double val) -> bool"""
        return _pyAgrum.BaseListPotentials_double_exists(self, *args)

    def erase(self, *args):
        """
        erase(self, unsigned int i)
        erase(self, gum::ListBucket<(p.q(const).gum::Potential<(double)>)> bucket)
        """
        return _pyAgrum.BaseListPotentials_double_erase(self, *args)

    def eraseByVal(self, *args):
        """eraseByVal(self, Potential_double val)"""
        return _pyAgrum.BaseListPotentials_double_eraseByVal(self, *args)

    def eraseAllVal(self, *args):
        """eraseAllVal(self, Potential_double val)"""
        return _pyAgrum.BaseListPotentials_double_eraseAllVal(self, *args)

    def popBack(self):
        """popBack(self)"""
        return _pyAgrum.BaseListPotentials_double_popBack(self)

    def popFront(self):
        """popFront(self)"""
        return _pyAgrum.BaseListPotentials_double_popFront(self)

    def clear(self):
        """clear(self)"""
        return _pyAgrum.BaseListPotentials_double_clear(self)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.BaseListPotentials_double_empty(self)

    def frontBucket(self):
        """frontBucket(self) -> gum::ListBucket<(p.q(const).gum::Potential<(double)>)>"""
        return _pyAgrum.BaseListPotentials_double_frontBucket(self)

    def backBucket(self):
        """backBucket(self) -> gum::ListBucket<(p.q(const).gum::Potential<(double)>)>"""
        return _pyAgrum.BaseListPotentials_double_backBucket(self)

    def __iadd__(self, *args):
        """__iadd__(self, Potential_double val) -> Potential_double"""
        return _pyAgrum.BaseListPotentials_double___iadd__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, BaseListPotentials_double src) -> bool"""
        return _pyAgrum.BaseListPotentials_double___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, BaseListPotentials_double src) -> bool"""
        return _pyAgrum.BaseListPotentials_double___ne__(self, *args)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.BaseListPotentials_double___str__(self)

BaseListPotentials_double_swigregister = _pyAgrum.BaseListPotentials_double_swigregister
BaseListPotentials_double_swigregister(BaseListPotentials_double)

class ListPotentials_double(_object):
    """Proxy of C++ gum::List<(p.q(const).gum::Potential<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListPotentials_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListPotentials_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ListPotentials_double
        __init__(self, gum::RefPtr<(gum::ListBase<(p.gum::ListConstIterator<(p.q(const).gum::Potential<(double)>)>)>)> iter_list) -> ListPotentials_double
        __init__(self, ListPotentials_double src) -> ListPotentials_double
        __init__(self, ListPotentials_double src, gum::RefPtr<(gum::ListBase<(p.gum::ListConstIterator<(p.q(const).gum::Potential<(double)>)>)>)> iter_list) -> ListPotentials_double
        """
        this = _pyAgrum.new_ListPotentials_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_ListPotentials_double
    __del__ = lambda self : None;
    def end(self, *args):
        """
        end(self) -> const_iterator
        end(self) -> iterator
        """
        return _pyAgrum.ListPotentials_double_end(self, *args)

    def rend(self, *args):
        """
        rend(self) -> const_iterator
        rend(self) -> iterator
        """
        return _pyAgrum.ListPotentials_double_rend(self, *args)

    def begin(self, *args):
        """
        begin(self) -> const_iterator
        begin(self) -> iterator
        """
        return _pyAgrum.ListPotentials_double_begin(self, *args)

    def rbegin(self, *args):
        """
        rbegin(self) -> const_iterator
        rbegin(self) -> iterator
        """
        return _pyAgrum.ListPotentials_double_rbegin(self, *args)

    def front(self):
        """front(self) -> Potential_double"""
        return _pyAgrum.ListPotentials_double_front(self)

    def back(self):
        """back(self) -> Potential_double"""
        return _pyAgrum.ListPotentials_double_back(self)

    def size(self):
        """size(self) -> Size"""
        return _pyAgrum.ListPotentials_double_size(self)

    def erase(self, *args):
        """erase(self, unsigned int i)"""
        return _pyAgrum.ListPotentials_double_erase(self, *args)

    def pop_back(self):
        """pop_back(self)"""
        return _pyAgrum.ListPotentials_double_pop_back(self)

    def pop_front(self):
        """pop_front(self)"""
        return _pyAgrum.ListPotentials_double_pop_front(self)

    def clear(self):
        """clear(self)"""
        return _pyAgrum.ListPotentials_double_clear(self)

    def setIteratorList(self, *args):
        """setIteratorList(self, gum::RefPtr<(gum::ListBase<(p.gum::ListConstIterator<(p.q(const).gum::Potential<(double)>)>)>)> list)"""
        return _pyAgrum.ListPotentials_double_setIteratorList(self, *args)

    def getIteratorList(self):
        """getIteratorList(self) -> gum::RefPtr<(gum::ListBase<(p.gum::ListConstIterator<(p.q(const).gum::Potential<(double)>)>)>)>"""
        return _pyAgrum.ListPotentials_double_getIteratorList(self)

    def empty(self):
        """empty(self) -> bool"""
        return _pyAgrum.ListPotentials_double_empty(self)

    def __iadd__(self, *args):
        """__iadd__(self, Potential_double val) -> Potential_double"""
        return _pyAgrum.ListPotentials_double___iadd__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, ListPotentials_double src) -> bool"""
        return _pyAgrum.ListPotentials_double___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, ListPotentials_double src) -> bool"""
        return _pyAgrum.ListPotentials_double___ne__(self, *args)

    def append(self, *args):
        """append(self, Potential_double val)"""
        args[0].__disown__() #lets c++ take care of deleting it


        return _pyAgrum.ListPotentials_double_append(self, *args)

    def push_front(self, *args):
        """
        push_front(self, Potential_double val) -> Potential_double
        push_front(self, Potential_double val)
        """
        return _pyAgrum.ListPotentials_double_push_front(self, *args)

    def push_back(self, *args):
        """
        push_back(self, Potential_double val) -> Potential_double
        push_back(self, Potential_double val)
        """
        return _pyAgrum.ListPotentials_double_push_back(self, *args)

    def remove(self, *args):
        """remove(self, Potential_double val)"""
        return _pyAgrum.ListPotentials_double_remove(self, *args)

    def eradicate(self, *args):
        """eradicate(self, Potential_double val)"""
        return _pyAgrum.ListPotentials_double_eradicate(self, *args)

    def __getitem__(self, *args):
        """__getitem__(self, unsigned int i) -> Potential_double"""
        val = _pyAgrum.ListPotentials_double___getitem__(self, *args)
        val.__fill_distrib__()


        return val

    def exists(self, *args):
        """
        exists(self, Potential_double val) -> bool
        exists(self, Potential_double val) -> bool
        """
        return _pyAgrum.ListPotentials_double_exists(self, *args)

ListPotentials_double_swigregister = _pyAgrum.ListPotentials_double_swigregister
ListPotentials_double_swigregister(ListPotentials_double)

class BayesNet_double(DAGmodel):
    """Proxy of C++ gum::BayesNet<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [DAGmodel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNet_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DAGmodel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNet_double, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_BayesNet_double
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(self) -> BayesNet_double
        __init__(self, string name) -> BayesNet_double
        __init__(self, BayesNet_double source) -> BayesNet_double
        """
        this = _pyAgrum.new_BayesNet_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def cpt(self, *args):
        """cpt(self, NodeId varId) -> Potential_double"""
        val = _pyAgrum.BayesNet_double_cpt(self, *args)
        val.__fill_distrib__()


        return val

    def variableNodeMap(self):
        """variableNodeMap(self) -> VariableNodeMap"""
        return _pyAgrum.BayesNet_double_variableNodeMap(self)

    def dim(self):
        """dim(self) -> Idx"""
        return _pyAgrum.BayesNet_double_dim(self)

    def toDot(self):
        """toDot(self) -> string"""
        return _pyAgrum.BayesNet_double_toDot(self)

    def __str__(self):
        """__str__(self) -> string"""
        return _pyAgrum.BayesNet_double___str__(self)

    def add(self, *args):
        """
        add(self, DiscreteVar variable) -> NodeId
        add(self, DiscreteVar variable, MultiDimImplementation_double aContent) -> NodeId
        add(self, DiscreteVar variable, NodeId id) -> NodeId
        add(self, DiscreteVar variable, MultiDimImplementation_double aContent, 
            NodeId id) -> NodeId
        """
        return _pyAgrum.BayesNet_double_add(self, *args)

    def erase(self, *args):
        """
        erase(self, NodeId id)
        erase(self, DiscreteVar var)
        """
        return _pyAgrum.BayesNet_double_erase(self, *args)

    def variable(self, *args):
        """variable(self, NodeId id) -> DiscreteVar"""
        return _pyAgrum.BayesNet_double_variable(self, *args)

    def changeVariableName(self, *args):
        """changeVariableName(self, NodeId id, string new_name)"""
        return _pyAgrum.BayesNet_double_changeVariableName(self, *args)

    def nodeId(self, *args):
        """nodeId(self, DiscreteVar var) -> NodeId"""
        return _pyAgrum.BayesNet_double_nodeId(self, *args)

    def idFromName(self, *args):
        """idFromName(self, string name) -> NodeId"""
        return _pyAgrum.BayesNet_double_idFromName(self, *args)

    def variableFromName(self, *args):
        """variableFromName(self, string name) -> DiscreteVar"""
        return _pyAgrum.BayesNet_double_variableFromName(self, *args)

    def jointProbability(self, *args):
        """jointProbability(self, Instantiation i) -> double"""
        return _pyAgrum.BayesNet_double_jointProbability(self, *args)

    def logJointProbability(self, *args):
        """logJointProbability(self, Instantiation i) -> double"""
        return _pyAgrum.BayesNet_double_logJointProbability(self, *args)

    def insertArc(self, *args):
        """insertArc(self, NodeId tail, NodeId head)"""
        print("WARNING : pyAgrum.BayesNet.insertArc is deprecated. Please use pyAgrum.BayesNet.addArc")


        return _pyAgrum.BayesNet_double_insertArc(self, *args)

    def addArc(self, *args):
        """addArc(self, NodeId tail, NodeId head)"""
        return _pyAgrum.BayesNet_double_addArc(self, *args)

    def eraseArc(self, *args):
        """
        eraseArc(self, Arc arc)
        eraseArc(self, NodeId tail, NodeId head)
        """
        return _pyAgrum.BayesNet_double_eraseArc(self, *args)

    def beginTopologyTransformation(self):
        """beginTopologyTransformation(self)"""
        return _pyAgrum.BayesNet_double_beginTopologyTransformation(self)

    def endTopologyTransformation(self):
        """endTopologyTransformation(self)"""
        return _pyAgrum.BayesNet_double_endTopologyTransformation(self)

    def addNoisyOR(self, *args):
        """
        addNoisyOR(self, DiscreteVar variable, double externalWeight) -> NodeId
        addNoisyOR(self, DiscreteVar variable, double externalWeight, NodeId id) -> NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyOR(self, *args)

    def addNoisyORNet(self, *args):
        """
        addNoisyORNet(self, DiscreteVar variable, double externalWeight) -> NodeId
        addNoisyORNet(self, DiscreteVar variable, double externalWeight, NodeId id) -> NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORNet(self, *args)

    def addNoisyORCompound(self, *args):
        """
        addNoisyORCompound(self, DiscreteVar variable, double externalWeight) -> NodeId
        addNoisyORCompound(self, DiscreteVar variable, double externalWeight, NodeId id) -> NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORCompound(self, *args)

    def addNoisyAND(self, *args):
        """
        addNoisyAND(self, DiscreteVar variable, double externalWeight, NodeId id) -> NodeId
        addNoisyAND(self, DiscreteVar variable, double externalWeight) -> NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyAND(self, *args)

    def addOR(self, *args):
        """addOR(self, DiscreteVar variable) -> NodeId"""
        return _pyAgrum.BayesNet_double_addOR(self, *args)

    def addAND(self, *args):
        """addAND(self, DiscreteVar variable) -> NodeId"""
        return _pyAgrum.BayesNet_double_addAND(self, *args)

    def insertWeightedArc(self, *args):
        """insertWeightedArc(self, NodeId tail, NodeId head, double causalWeight)"""
        print("WARNING : pyAgrum.BayesNet.insertWeightedArc is deprecated. Please use pyAgrum.BayesNet.addWeightedArc")


        return _pyAgrum.BayesNet_double_insertWeightedArc(self, *args)

    def addWeightedArc(self, *args):
        """addWeightedArc(self, NodeId tail, NodeId head, double causalWeight)"""
        return _pyAgrum.BayesNet_double_addWeightedArc(self, *args)

    def generateCPTs(self):
        """generateCPTs(self)"""
        return _pyAgrum.BayesNet_double_generateCPTs(self)

    def __eq__(self, *args):
        """__eq__(self, BayesNet_double src) -> bool"""
        return _pyAgrum.BayesNet_double___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, BayesNet_double src) -> bool"""
        return _pyAgrum.BayesNet_double___ne__(self, *args)

    def names(self):
        """names(self) -> PyObject"""
        return _pyAgrum.BayesNet_double_names(self)

    def ids(self):
        """ids(self) -> PyObject"""
        return _pyAgrum.BayesNet_double_ids(self)

    def arcs(self):
        """arcs(self) -> PyObject"""
        return _pyAgrum.BayesNet_double_arcs(self)

    def parents(self, *args):
        """parents(self, NodeId id) -> PyObject"""
        return _pyAgrum.BayesNet_double_parents(self, *args)

    def children(self, *args):
        """children(self, NodeId id) -> PyObject"""
        return _pyAgrum.BayesNet_double_children(self, *args)

    def loadBIF(self, *args):
        """
        loadBIF(self, string name, PyObject l = (PyObject *) 0) -> bool
        loadBIF(self, string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadBIF(self, *args)

    def saveBIF(self, *args):
        """saveBIF(self, string name)"""
        return _pyAgrum.BayesNet_double_saveBIF(self, *args)

    def loadDSL(self, *args):
        """
        loadDSL(self, string name, PyObject l = (PyObject *) 0) -> bool
        loadDSL(self, string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadDSL(self, *args)

    def saveDSL(self, *args):
        """saveDSL(self, string name)"""
        return _pyAgrum.BayesNet_double_saveDSL(self, *args)

    def loadNET(self, *args):
        """
        loadNET(self, string name, PyObject l = (PyObject *) 0) -> bool
        loadNET(self, string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadNET(self, *args)

    def saveNET(self, *args):
        """saveNET(self, string name)"""
        return _pyAgrum.BayesNet_double_saveNET(self, *args)

    def loadBIFXML(self, *args):
        """
        loadBIFXML(self, string name, PyObject l = (PyObject *) 0) -> bool
        loadBIFXML(self, string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadBIFXML(self, *args)

    def saveBIFXML(self, *args):
        """saveBIFXML(self, string name)"""
        return _pyAgrum.BayesNet_double_saveBIFXML(self, *args)

BayesNet_double_swigregister = _pyAgrum.BayesNet_double_swigregister
BayesNet_double_swigregister(BayesNet_double)

class BayesNetInference_double(_object):
    """Proxy of C++ gum::BayesNetInference<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNetInference_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNetInference_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_BayesNetInference_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(self)"""
        return _pyAgrum.BayesNetInference_double_makeInference(self)

    def marginal(self, *args):
        """marginal(self, NodeId id) -> Potential_double"""
        val = _pyAgrum.BayesNetInference_double_marginal(self, *args)
        val.__fill_distrib__()


        return val

    def insertEvidence(self, *args):
        """insertEvidence(self, ListPotentials_double pot_list)"""
        return _pyAgrum.BayesNetInference_double_insertEvidence(self, *args)

    def eraseEvidence(self, *args):
        """eraseEvidence(self, Potential_double e)"""
        return _pyAgrum.BayesNetInference_double_eraseEvidence(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(self)"""
        return _pyAgrum.BayesNetInference_double_eraseAllEvidence(self)

    def bn(self):
        """bn(self) -> BayesNet_double"""
        return _pyAgrum.BayesNetInference_double_bn(self)

    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be dict, not %s"
                            %(type(evidces)))
        bn = self.bn()

        # set evidences
        list_pot = ListPotentials_double()
        for var_name, evidce in evidces.iteritems():
            pot = Potential_double()

            if isinstance(var_name, int):
                var = bn.variable(var_name)
            elif isinstance(var_name, str):
                var = bn.variableFromName(var_name)
            else:
                raise TypeError('values of the dict must be int or string')

            pot.add(var)
            if isinstance(evidce, (int, float, str)):
                pot[:] = 0
                # determine the var type
                try:
                    cast_var = var.toLabelizedVar()
                    if isinstance(evidce, int):
                        index = evidce
                    elif isinstance(evidce, str):
                        index = cast_var[evidce]
                    else:
                        raise TypeError('values of the dict must be int or string')
                except RuntimeError:
                    try:
                        cast_var = var.toRangeVar()
                        if isinstance(evidce, int):
                            index = cast_var[str(evidce)]
                        elif isinstance(evidce, str):
                            index = cast_var[evidce]
                        else:
                            raise TypeError('values of the dict must be int or string')
                    except RuntimeError:
                        cast_var = var.toDiscretizedVar()
                        if isinstance(evidce, float):
                            index = cast_var.index(evidce)
                        elif isinstance(evidce, str):
                            index = cast_var.index(float(evidce))
                        else:
                            raise TypeError('values of the dict must be float or string')
                pot[index] = 1
            elif isinstance(evidce, (list, tuple)):
                pot[:] = evidce
            else:
                raise TypeError('dict values must be number, string or sequence')
            list_pot.append(pot)

        self.insertEvidence(list_pot)


BayesNetInference_double_swigregister = _pyAgrum.BayesNetInference_double_swigregister
BayesNetInference_double_swigregister(BayesNetInference_double)

class LazyPropagation_double(BayesNetInference_double):
    """Proxy of C++ gum::LazyPropagation<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LazyPropagation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LazyPropagation_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, BayesNet_double BN) -> LazyPropagation_double
        __init__(self, BayesNet_double BN, std::vector<(gum::NodeId,std::allocator<(gum::NodeId)>)> elim_order) -> LazyPropagation_double
        """
        if self.__class__ == LazyPropagation_double:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_LazyPropagation_double(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_LazyPropagation_double
    __del__ = lambda self : None;
    def insertEvidence(self, *args):
        """insertEvidence(self, ListPotentials_double arg0)"""
        return _pyAgrum.LazyPropagation_double_insertEvidence(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(self)"""
        return _pyAgrum.LazyPropagation_double_eraseAllEvidence(self)

    def eraseEvidence(self, *args):
        """eraseEvidence(self, Potential_double arg0)"""
        return _pyAgrum.LazyPropagation_double_eraseEvidence(self, *args)

    def collect(self, *args):
        """
        collect(self, NodeId id, bool force_collect = False)
        collect(self, NodeId id)
        """
        return _pyAgrum.LazyPropagation_double_collect(self, *args)

    def diffusion(self, *args):
        """
        diffusion(self, NodeId id, bool force_diffusion = False)
        diffusion(self, NodeId id)
        """
        return _pyAgrum.LazyPropagation_double_diffusion(self, *args)

    def makeInference(self, *args):
        """
        makeInference(self)
        makeInference(self, bool force_inference)
        """
        return _pyAgrum.LazyPropagation_double_makeInference(self, *args)

    def evidenceMarginal(self):
        """evidenceMarginal(self) -> double"""
        return _pyAgrum.LazyPropagation_double_evidenceMarginal(self)

    def junctionTree(self):
        """junctionTree(self) -> JunctionTree"""
        return _pyAgrum.LazyPropagation_double_junctionTree(self)

    def H(self, *args):
        """H(self, NodeId X) -> double"""
        return _pyAgrum.LazyPropagation_double_H(self, *args)

    def I(self, *args):
        """I(self, NodeId X, NodeId Y) -> double"""
        return _pyAgrum.LazyPropagation_double_I(self, *args)

    def VI(self, *args):
        """VI(self, NodeId X, NodeId Y) -> double"""
        return _pyAgrum.LazyPropagation_double_VI(self, *args)

    def _fillMarginal(self, *args):
        """_fillMarginal(self, Id id, Potential_double marginal)"""
        return _pyAgrum.LazyPropagation_double__fillMarginal(self, *args)

    def __del__(self):
        self.__disown__()


    def joint(self, *args):
        """
        joint(self, NodeSet nodes) -> Potential_double
        joint(self, PyObject seq_of_ids) -> Potential_double
        """
        return _pyAgrum.LazyPropagation_double_joint(self, *args)

    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_LazyPropagation_double(self)
        return weakref_proxy(self)
LazyPropagation_double_swigregister = _pyAgrum.LazyPropagation_double_swigregister
LazyPropagation_double_swigregister(LazyPropagation_double)

class GibbsInference_double(BayesNetInference_double):
    """Proxy of C++ gum::GibbsInference<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsInference_double, name, value)
    __swig_getmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsInference_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, BayesNet_double BN) -> GibbsInference_double"""
        if self.__class__ == GibbsInference_double:
            _self = None
        else:
            _self = self
        this = _pyAgrum.new_GibbsInference_double(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsInference_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(self)"""
        return _pyAgrum.GibbsInference_double_makeInference(self)

    def insertEvidence(self, *args):
        """insertEvidence(self, ListPotentials_double pot_list)"""
        return _pyAgrum.GibbsInference_double_insertEvidence(self, *args)

    def eraseEvidence(self, *args):
        """eraseEvidence(self, Potential_double e)"""
        return _pyAgrum.GibbsInference_double_eraseEvidence(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(self)"""
        return _pyAgrum.GibbsInference_double_eraseAllEvidence(self)

    def setRequiredInference(self):
        """setRequiredInference(self)"""
        return _pyAgrum.GibbsInference_double_setRequiredInference(self)

    def isInferenceRequired(self):
        """isInferenceRequired(self) -> bool"""
        return _pyAgrum.GibbsInference_double_isInferenceRequired(self)

    def _fillMarginal(self, *args):
        """_fillMarginal(self, NodeId id, Potential_double marginal)"""
        return _pyAgrum.GibbsInference_double__fillMarginal(self, *args)

    def __del__(self):
        self.__disown__()


    def setVerbosity(self, *args):
        """setVerbosity(self, bool v)"""
        return _pyAgrum.GibbsInference_double_setVerbosity(self, *args)

    def setEpsilon(self, *args):
        """setEpsilon(self, double eps)"""
        return _pyAgrum.GibbsInference_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args):
        """setMinEpsilonRate(self, double rate)"""
        return _pyAgrum.GibbsInference_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args):
        """setMaxIter(self, Size max)"""
        return _pyAgrum.GibbsInference_double_setMaxIter(self, *args)

    def setMaxTime(self, *args):
        """setMaxTime(self, double timeout)"""
        return _pyAgrum.GibbsInference_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args):
        """setPeriodSize(self, Size p)"""
        return _pyAgrum.GibbsInference_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args):
        """setBurnIn(self, Size b)"""
        return _pyAgrum.GibbsInference_double_setBurnIn(self, *args)

    def verbosity(self):
        """verbosity(self) -> bool"""
        return _pyAgrum.GibbsInference_double_verbosity(self)

    def epsilon(self):
        """epsilon(self) -> double"""
        return _pyAgrum.GibbsInference_double_epsilon(self)

    def minEpsilonRate(self):
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.GibbsInference_double_minEpsilonRate(self)

    def maxIter(self):
        """maxIter(self) -> Size"""
        return _pyAgrum.GibbsInference_double_maxIter(self)

    def maxTime(self):
        """maxTime(self) -> double"""
        return _pyAgrum.GibbsInference_double_maxTime(self)

    def periodSize(self):
        """periodSize(self) -> Size"""
        return _pyAgrum.GibbsInference_double_periodSize(self)

    def burnIn(self):
        """burnIn(self) -> Size"""
        return _pyAgrum.GibbsInference_double_burnIn(self)

    def nbrIterations(self):
        """nbrIterations(self) -> Size"""
        return _pyAgrum.GibbsInference_double_nbrIterations(self)

    def currentTime(self):
        """currentTime(self) -> double"""
        return _pyAgrum.GibbsInference_double_currentTime(self)

    def messageApproximationScheme(self):
        """messageApproximationScheme(self) -> string"""
        return _pyAgrum.GibbsInference_double_messageApproximationScheme(self)

    def history(self):
        """history(self) -> Vector_double"""
        return _pyAgrum.GibbsInference_double_history(self)

    def __disown__(self):
        self.this.disown()
        _pyAgrum.disown_GibbsInference_double(self)
        return weakref_proxy(self)
GibbsInference_double_swigregister = _pyAgrum.GibbsInference_double_swigregister
GibbsInference_double_swigregister(GibbsInference_double)

class BruteForceKL_double(_object):
    """Proxy of C++ gum::BruteForceKL<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BruteForceKL_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BruteForceKL_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, BayesNet_double P, BayesNet_double Q) -> BruteForceKL_double
        __init__(self, gum::KL<(double)> kl) -> BruteForceKL_double
        """
        this = _pyAgrum.new_BruteForceKL_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_BruteForceKL_double
    __del__ = lambda self : None;
    def compute(self):
        """compute(self) -> PyObject"""
        return _pyAgrum.BruteForceKL_double_compute(self)

BruteForceKL_double_swigregister = _pyAgrum.BruteForceKL_double_swigregister
BruteForceKL_double_swigregister(BruteForceKL_double)

class GibbsKL_double(_object):
    """Proxy of C++ gum::GibbsKL<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsKL_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsKL_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, BayesNet_double P, BayesNet_double Q) -> GibbsKL_double
        __init__(self, gum::KL<(double)> kl) -> GibbsKL_double
        """
        this = _pyAgrum.new_GibbsKL_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsKL_double
    __del__ = lambda self : None;
    def compute(self):
        """compute(self) -> PyObject"""
        return _pyAgrum.GibbsKL_double_compute(self)

    def setVerbosity(self, *args):
        """setVerbosity(self, bool v)"""
        return _pyAgrum.GibbsKL_double_setVerbosity(self, *args)

    def setEpsilon(self, *args):
        """setEpsilon(self, double eps)"""
        return _pyAgrum.GibbsKL_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args):
        """setMinEpsilonRate(self, double rate)"""
        return _pyAgrum.GibbsKL_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args):
        """setMaxIter(self, Size max)"""
        return _pyAgrum.GibbsKL_double_setMaxIter(self, *args)

    def setMaxTime(self, *args):
        """setMaxTime(self, double timeout)"""
        return _pyAgrum.GibbsKL_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args):
        """setPeriodSize(self, Size p)"""
        return _pyAgrum.GibbsKL_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args):
        """setBurnIn(self, Size b)"""
        return _pyAgrum.GibbsKL_double_setBurnIn(self, *args)

    def verbosity(self):
        """verbosity(self) -> bool"""
        return _pyAgrum.GibbsKL_double_verbosity(self)

    def epsilon(self):
        """epsilon(self) -> double"""
        return _pyAgrum.GibbsKL_double_epsilon(self)

    def minEpsilonRate(self):
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.GibbsKL_double_minEpsilonRate(self)

    def maxIter(self):
        """maxIter(self) -> Size"""
        return _pyAgrum.GibbsKL_double_maxIter(self)

    def maxTime(self):
        """maxTime(self) -> double"""
        return _pyAgrum.GibbsKL_double_maxTime(self)

    def periodSize(self):
        """periodSize(self) -> Size"""
        return _pyAgrum.GibbsKL_double_periodSize(self)

    def burnIn(self):
        """burnIn(self) -> Size"""
        return _pyAgrum.GibbsKL_double_burnIn(self)

    def nbrIterations(self):
        """nbrIterations(self) -> Size"""
        return _pyAgrum.GibbsKL_double_nbrIterations(self)

    def currentTime(self):
        """currentTime(self) -> double"""
        return _pyAgrum.GibbsKL_double_currentTime(self)

    def messageApproximationScheme(self):
        """messageApproximationScheme(self) -> string"""
        return _pyAgrum.GibbsKL_double_messageApproximationScheme(self)

    def history(self):
        """history(self) -> Vector_double"""
        return _pyAgrum.GibbsKL_double_history(self)

GibbsKL_double_swigregister = _pyAgrum.GibbsKL_double_swigregister
GibbsKL_double_swigregister(GibbsKL_double)

class CredalNet_double(_object):
    """Proxy of C++ gum::credal::CredalNet<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CredalNet_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CredalNet_double, name)
    __repr__ = _swig_repr
    Precise = _pyAgrum.CredalNet_double_Precise
    Credal = _pyAgrum.CredalNet_double_Credal
    Vacuous = _pyAgrum.CredalNet_double_Vacuous
    Indic = _pyAgrum.CredalNet_double_Indic
    def __init__(self, *args): 
        """
        __init__(self) -> CredalNet_double
        __init__(self, string src_min_num, string src_max_den = "") -> CredalNet_double
        __init__(self, string src_min_num) -> CredalNet_double
        __init__(self, BayesNet_double src_min_num, BayesNet_double src_max_den = gum::BayesNet()) -> CredalNet_double
        __init__(self, BayesNet_double src_min_num) -> CredalNet_double
        """
        this = _pyAgrum.new_CredalNet_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CredalNet_double
    __del__ = lambda self : None;
    def addNode(self, *args):
        """addNode(self, string name, unsigned long card) -> NodeId"""
        return _pyAgrum.CredalNet_double_addNode(self, *args)

    def addArc(self, *args):
        """addArc(self, NodeId tail, NodeId head)"""
        return _pyAgrum.CredalNet_double_addArc(self, *args)

    def setCPTs(self, *args):
        """setCPTs(self, NodeId id, std::vector<(std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>,std::allocator<(std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>)>)> cpt)"""
        return _pyAgrum.CredalNet_double_setCPTs(self, *args)

    def setCPT(self, *args):
        """
        setCPT(self, NodeId id, unsigned long entry, std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)> cpt)
        setCPT(self, NodeId id, Instantiation ins, std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)> cpt)
        """
        return _pyAgrum.CredalNet_double_setCPT(self, *args)

    def fillConstraints(self, *args):
        """fillConstraints(self, NodeId id, Vector_double lower, Vector_double upper)"""
        return _pyAgrum.CredalNet_double_fillConstraints(self, *args)

    def fillConstraint(self, *args):
        """
        fillConstraint(self, NodeId id, unsigned long entry, Vector_double lower, 
            Vector_double upper)
        fillConstraint(self, NodeId id, Instantiation ins, Vector_double lower, 
            Vector_double upper)
        """
        return _pyAgrum.CredalNet_double_fillConstraint(self, *args)

    def instantiation(self, *args):
        """instantiation(self, NodeId id) -> Instantiation"""
        return _pyAgrum.CredalNet_double_instantiation(self, *args)

    def domainSize(self, *args):
        """domainSize(self, NodeId id) -> Size"""
        return _pyAgrum.CredalNet_double_domainSize(self, *args)

    def bnToCredal(self, *args):
        """
        bnToCredal(self, double beta, bool oneNet, bool keepZeroes = False)
        bnToCredal(self, double beta, bool oneNet)
        """
        return _pyAgrum.CredalNet_double_bnToCredal(self, *args)

    def intervalToCredalWithFiles(self):
        """intervalToCredalWithFiles(self)"""
        return _pyAgrum.CredalNet_double_intervalToCredalWithFiles(self)

    def intervalToCredal(self):
        """intervalToCredal(self)"""
        return _pyAgrum.CredalNet_double_intervalToCredal(self)

    def lagrangeNormalization(self):
        """lagrangeNormalization(self)"""
        return _pyAgrum.CredalNet_double_lagrangeNormalization(self)

    def idmLearning(self, s = 0, keepZeroes = False):
        """
        idmLearning(self, unsigned int s = 0, bool keepZeroes = False)
        idmLearning(self, unsigned int s = 0)
        idmLearning(self)
        """
        return _pyAgrum.CredalNet_double_idmLearning(self, s, keepZeroes)

    def approximatedBinarization(self):
        """approximatedBinarization(self)"""
        return _pyAgrum.CredalNet_double_approximatedBinarization(self)

    def saveBNsMinMax(self, *args):
        """saveBNsMinMax(self, string min_path, string max_path)"""
        return _pyAgrum.CredalNet_double_saveBNsMinMax(self, *args)

    def toString(self):
        """toString(self) -> string"""
        return _pyAgrum.CredalNet_double_toString(self)

    def computeCPTMinMax(self):
        """computeCPTMinMax(self)"""
        return _pyAgrum.CredalNet_double_computeCPTMinMax(self)

    def src_bn(self):
        """src_bn(self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_src_bn(self)

    def current_bn(self):
        """current_bn(self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_current_bn(self)

    def credalNet_currentCpt(self):
        """credalNet_currentCpt(self) -> gum::Property<(std::vector<(std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>,std::allocator<(std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>)>)>)>::onNodes"""
        return _pyAgrum.CredalNet_double_credalNet_currentCpt(self)

    def credalNet_srcCpt(self):
        """credalNet_srcCpt(self) -> gum::Property<(std::vector<(std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>,std::allocator<(std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>)>)>)>::onNodes"""
        return _pyAgrum.CredalNet_double_credalNet_srcCpt(self)

    def currentNodeType(self, *args):
        """currentNodeType(self, NodeId id) -> NodeType"""
        return _pyAgrum.CredalNet_double_currentNodeType(self, *args)

    def nodeType(self, *args):
        """nodeType(self, NodeId id) -> NodeType"""
        return _pyAgrum.CredalNet_double_nodeType(self, *args)

    def epsilonMin(self):
        """epsilonMin(self) -> double"""
        return _pyAgrum.CredalNet_double_epsilonMin(self)

    def epsilonMax(self):
        """epsilonMax(self) -> double"""
        return _pyAgrum.CredalNet_double_epsilonMax(self)

    def epsilonMean(self):
        """epsilonMean(self) -> double"""
        return _pyAgrum.CredalNet_double_epsilonMean(self)

    def isSeparatelySpecified(self):
        """isSeparatelySpecified(self) -> bool"""
        return _pyAgrum.CredalNet_double_isSeparatelySpecified(self)

    def get_CPT_min(self):
        """get_CPT_min(self) -> std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>"""
        return _pyAgrum.CredalNet_double_get_CPT_min(self)

    def get_CPT_max(self):
        """get_CPT_max(self) -> std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>"""
        return _pyAgrum.CredalNet_double_get_CPT_max(self)

CredalNet_double_swigregister = _pyAgrum.CredalNet_double_swigregister
CredalNet_double_swigregister(CredalNet_double)

class CNInferenceEngine_double(_object):
    """Proxy of C++ gum::credal::InferenceEngine<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNInferenceEngine_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNInferenceEngine_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_CNInferenceEngine_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(self)"""
        return _pyAgrum.CNInferenceEngine_double_makeInference(self)

    def getVarMod2BNsMap(self):
        """getVarMod2BNsMap(self) -> gum::credal::VarMod2BNsMap<(double)>"""
        return _pyAgrum.CNInferenceEngine_double_getVarMod2BNsMap(self)

    def credalNet(self):
        """credalNet(self) -> CredalNet_double"""
        return _pyAgrum.CNInferenceEngine_double_credalNet(self)

    def getT0Cluster(self):
        """getT0Cluster(self) -> gum::Property<(std::vector<(gum::NodeId,std::allocator<(gum::NodeId)>)>)>::onNodes"""
        return _pyAgrum.CNInferenceEngine_double_getT0Cluster(self)

    def getT1Cluster(self):
        """getT1Cluster(self) -> gum::Property<(std::vector<(gum::NodeId,std::allocator<(gum::NodeId)>)>)>::onNodes"""
        return _pyAgrum.CNInferenceEngine_double_getT1Cluster(self)

    def setRepetitiveInd(self, *args):
        """setRepetitiveInd(self, bool repetitive)"""
        return _pyAgrum.CNInferenceEngine_double_setRepetitiveInd(self, *args)

    def repetitiveInd(self):
        """repetitiveInd(self) -> bool"""
        return _pyAgrum.CNInferenceEngine_double_repetitiveInd(self)

    def storeVertices(self, *args):
        """
        storeVertices(self, bool value)
        storeVertices(self) -> bool
        """
        return _pyAgrum.CNInferenceEngine_double_storeVertices(self, *args)

    def storeBNOpt(self, *args):
        """
        storeBNOpt(self, bool value)
        storeBNOpt(self) -> bool
        """
        return _pyAgrum.CNInferenceEngine_double_storeBNOpt(self, *args)

    def insertModalsFile(self, *args):
        """insertModalsFile(self, string path)"""
        return _pyAgrum.CNInferenceEngine_double_insertModalsFile(self, *args)

    def insertModals(self, *args):
        """insertModals(self, std::map<(std::string,std::vector<(double,std::allocator<(double)>)>)> modals)"""
        return _pyAgrum.CNInferenceEngine_double_insertModals(self, *args)

    def insertEvidenceFile(self, *args):
        """insertEvidenceFile(self, string path)"""
        return _pyAgrum.CNInferenceEngine_double_insertEvidenceFile(self, *args)

    def insertEvidence(self, *args):
        """
        insertEvidence(self, std::map<(std::string,std::vector<(double,std::allocator<(double)>)>)> eviMap)
        insertEvidence(self, gum::Property<(std::vector<(double,std::allocator<(double)>)>)>::onNodes evidence)
        """
        return _pyAgrum.CNInferenceEngine_double_insertEvidence(self, *args)

    def insertQueryFile(self, *args):
        """insertQueryFile(self, string path)"""
        return _pyAgrum.CNInferenceEngine_double_insertQueryFile(self, *args)

    def insertQuery(self, *args):
        """insertQuery(self, gum::Property<(std::vector<(bool,std::allocator<(bool)>)>)>::onNodes query)"""
        return _pyAgrum.CNInferenceEngine_double_insertQuery(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(self)"""
        return _pyAgrum.CNInferenceEngine_double_eraseAllEvidence(self)

    def marginalMin(self, *args):
        """
        marginalMin(self, NodeId id) -> Vector_double
        marginalMin(self, string varName) -> Vector_double
        """
        return _pyAgrum.CNInferenceEngine_double_marginalMin(self, *args)

    def marginalMax(self, *args):
        """
        marginalMax(self, NodeId id) -> Vector_double
        marginalMax(self, string varName) -> Vector_double
        """
        return _pyAgrum.CNInferenceEngine_double_marginalMax(self, *args)

    def expectationMin(self, *args):
        """
        expectationMin(self, NodeId id) -> double
        expectationMin(self, string varName) -> double
        """
        return _pyAgrum.CNInferenceEngine_double_expectationMin(self, *args)

    def expectationMax(self, *args):
        """
        expectationMax(self, NodeId id) -> double
        expectationMax(self, string varName) -> double
        """
        return _pyAgrum.CNInferenceEngine_double_expectationMax(self, *args)

    def dynamicExpMin(self, *args):
        """dynamicExpMin(self, string varName) -> Vector_double"""
        return _pyAgrum.CNInferenceEngine_double_dynamicExpMin(self, *args)

    def dynamicExpMax(self, *args):
        """dynamicExpMax(self, string varName) -> Vector_double"""
        return _pyAgrum.CNInferenceEngine_double_dynamicExpMax(self, *args)

    def vertices(self, *args):
        """vertices(self, NodeId id) -> std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>"""
        return _pyAgrum.CNInferenceEngine_double_vertices(self, *args)

    def saveMarginals(self, *args):
        """saveMarginals(self, string path)"""
        return _pyAgrum.CNInferenceEngine_double_saveMarginals(self, *args)

    def saveExpectations(self, *args):
        """saveExpectations(self, string path)"""
        return _pyAgrum.CNInferenceEngine_double_saveExpectations(self, *args)

    def saveVertices(self, *args):
        """saveVertices(self, string path)"""
        return _pyAgrum.CNInferenceEngine_double_saveVertices(self, *args)

    def dynamicExpectations(self):
        """dynamicExpectations(self)"""
        return _pyAgrum.CNInferenceEngine_double_dynamicExpectations(self)

    def toString(self):
        """toString(self) -> string"""
        return _pyAgrum.CNInferenceEngine_double_toString(self)

    def getApproximationSchemeMsg(self):
        """getApproximationSchemeMsg(self) -> string"""
        return _pyAgrum.CNInferenceEngine_double_getApproximationSchemeMsg(self)

    def setVerbosity(self, *args):
        """setVerbosity(self, bool v)"""
        return _pyAgrum.CNInferenceEngine_double_setVerbosity(self, *args)

    def setEpsilon(self, *args):
        """setEpsilon(self, double eps)"""
        return _pyAgrum.CNInferenceEngine_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args):
        """setMinEpsilonRate(self, double rate)"""
        return _pyAgrum.CNInferenceEngine_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args):
        """setMaxIter(self, Size max)"""
        return _pyAgrum.CNInferenceEngine_double_setMaxIter(self, *args)

    def setMaxTime(self, *args):
        """setMaxTime(self, double timeout)"""
        return _pyAgrum.CNInferenceEngine_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args):
        """setPeriodSize(self, Size p)"""
        return _pyAgrum.CNInferenceEngine_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args):
        """setBurnIn(self, Size b)"""
        return _pyAgrum.CNInferenceEngine_double_setBurnIn(self, *args)

    def verbosity(self):
        """verbosity(self) -> bool"""
        return _pyAgrum.CNInferenceEngine_double_verbosity(self)

    def epsilon(self):
        """epsilon(self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_epsilon(self)

    def minEpsilonRate(self):
        """minEpsilonRate(self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_minEpsilonRate(self)

    def maxIter(self):
        """maxIter(self) -> Size"""
        return _pyAgrum.CNInferenceEngine_double_maxIter(self)

    def maxTime(self):
        """maxTime(self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_maxTime(self)

    def periodSize(self):
        """periodSize(self) -> Size"""
        return _pyAgrum.CNInferenceEngine_double_periodSize(self)

    def burnIn(self):
        """burnIn(self) -> Size"""
        return _pyAgrum.CNInferenceEngine_double_burnIn(self)

    def nbrIterations(self):
        """nbrIterations(self) -> Size"""
        return _pyAgrum.CNInferenceEngine_double_nbrIterations(self)

    def currentTime(self):
        """currentTime(self) -> double"""
        return _pyAgrum.CNInferenceEngine_double_currentTime(self)

    def messageApproximationScheme(self):
        """messageApproximationScheme(self) -> string"""
        return _pyAgrum.CNInferenceEngine_double_messageApproximationScheme(self)

    def history(self):
        """history(self) -> Vector_double"""
        return _pyAgrum.CNInferenceEngine_double_history(self)

CNInferenceEngine_double_swigregister = _pyAgrum.CNInferenceEngine_double_swigregister
CNInferenceEngine_double_swigregister(CNInferenceEngine_double)

class CNMultipleInferenceEngine_double(CNInferenceEngine_double):
    """Proxy of C++ gum::credal::MultipleInferenceEngine<(double,gum::LazyPropagation<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNMultipleInferenceEngine_double, name, value)
    __swig_getmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CNMultipleInferenceEngine_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_CNMultipleInferenceEngine_double
    __del__ = lambda self : None;
    def eraseAllEvidence(self):
        """eraseAllEvidence(self)"""
        return _pyAgrum.CNMultipleInferenceEngine_double_eraseAllEvidence(self)

    def makeInference(self):
        """makeInference(self)"""
        return _pyAgrum.CNMultipleInferenceEngine_double_makeInference(self)

CNMultipleInferenceEngine_double_swigregister = _pyAgrum.CNMultipleInferenceEngine_double_swigregister
CNMultipleInferenceEngine_double_swigregister(CNMultipleInferenceEngine_double)

class CNMonteCarloSampling_double(CNMultipleInferenceEngine_double):
    """Proxy of C++ gum::credal::CNMonteCarloSampling<(double,gum::LazyPropagation<(double)>)> class"""
    __swig_setmethods__ = {}
    for _s in [CNMultipleInferenceEngine_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNMonteCarloSampling_double, name, value)
    __swig_getmethods__ = {}
    for _s in [CNMultipleInferenceEngine_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CNMonteCarloSampling_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, CredalNet_double credalNet) -> CNMonteCarloSampling_double"""
        this = _pyAgrum.new_CNMonteCarloSampling_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNMonteCarloSampling_double
    __del__ = lambda self : None;
    def makeInference(self):
        """makeInference(self)"""
        return _pyAgrum.CNMonteCarloSampling_double_makeInference(self)

CNMonteCarloSampling_double_swigregister = _pyAgrum.CNMonteCarloSampling_double_swigregister
CNMonteCarloSampling_double_swigregister(CNMonteCarloSampling_double)

class CNLoopyPropagation_double(CNInferenceEngine_double):
    """Proxy of C++ gum::credal::CNLoopyPropagation<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNLoopyPropagation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [CNInferenceEngine_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CNLoopyPropagation_double, name)
    __repr__ = _swig_repr
    nodeToNeighbours = _pyAgrum.CNLoopyPropagation_double_nodeToNeighbours
    ordered = _pyAgrum.CNLoopyPropagation_double_ordered
    randomOrder = _pyAgrum.CNLoopyPropagation_double_randomOrder
    def makeInference(self):
        """makeInference(self)"""
        return _pyAgrum.CNLoopyPropagation_double_makeInference(self)

    def inferenceType(self, *args):
        """
        inferenceType(self, InferenceType inft)
        inferenceType(self) -> InferenceType
        """
        return _pyAgrum.CNLoopyPropagation_double_inferenceType(self, *args)

    def eraseAllEvidence(self):
        """eraseAllEvidence(self)"""
        return _pyAgrum.CNLoopyPropagation_double_eraseAllEvidence(self)

    def saveInference(self, *args):
        """saveInference(self, string path)"""
        return _pyAgrum.CNLoopyPropagation_double_saveInference(self, *args)

    def __init__(self, *args): 
        """__init__(self, CredalNet_double cnet) -> CNLoopyPropagation_double"""
        this = _pyAgrum.new_CNLoopyPropagation_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNLoopyPropagation_double
    __del__ = lambda self : None;
CNLoopyPropagation_double_swigregister = _pyAgrum.CNLoopyPropagation_double_swigregister
CNLoopyPropagation_double_swigregister(CNLoopyPropagation_double)

Potential = Potential_double
ListPotentials = ListPotentials_double

BayesNet = BayesNet_double
LazyPropagation = LazyPropagation_double
GibbsInference = GibbsInference_double

BruteForceKL = BruteForceKL_double
GibbsKL = GibbsKL_double

CredalNet = CredalNet_double
CNMonteCarloSampling = CNMonteCarloSampling_double
CNLoopyPropagation = CNLoopyPropagation_double




