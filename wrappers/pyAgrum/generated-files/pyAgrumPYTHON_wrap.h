/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_pyAgrum_WRAP_H_
#define SWIG_pyAgrum_WRAP_H_

#include <map>
#include <string>


class SwigDirector_LabelizedVar : public gum::LabelizedVariable, public Swig::Director {

public:
    SwigDirector_LabelizedVar(PyObject *self, std::string const &aName, std::string const &aDesc = "", int const nbrLabel = 2);
    SwigDirector_LabelizedVar(PyObject *self, gum::LabelizedVariable const &aLDRV);
    SwigDirector_LabelizedVar(PyObject *self);
    virtual ~SwigDirector_LabelizedVar();
    virtual gum::DiscreteVariable *clone() const;
    virtual bool operator ==(gum::Variable const &aRV) const;
    virtual bool operator !=(gum::Variable const &aRV) const;
    virtual gum::Size domainSize() const;
    virtual std::string const label(gum::Idx i) const;
    virtual double const numerical(gum::Idx indice) const;
    virtual gum::DiscreteVariable::VarType varType() const;
    virtual bool operator ==(gum::DiscreteVariable const &aRV) const;
    virtual bool operator !=(gum::DiscreteVariable const &aRV) const;
    virtual gum::Idx operator [](std::string const &aLabel) const;
    virtual gum::Idx index(std::string const &label) const;
    virtual std::string const toString() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class LabelizedVar doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[11];
#endif

};


class SwigDirector_DiscretizedVar : public gum::DiscretizedVariable< float >, public Swig::Director {

public:
    SwigDirector_DiscretizedVar(PyObject *self, std::string const &aName, std::string const &aDesc);
    SwigDirector_DiscretizedVar(PyObject *self, gum::DiscretizedVariable< float > const &aDRV);
    virtual ~SwigDirector_DiscretizedVar();
    virtual gum::DiscreteVariable *clone() const;
    virtual bool operator ==(gum::Variable const &aRV) const;
    virtual bool operator !=(gum::Variable const &aRV) const;
    virtual gum::Size domainSize() const;
    virtual std::string const label(gum::Idx i) const;
    virtual double const numerical(gum::Idx indice) const;
    virtual gum::DiscreteVariable::VarType varType() const;
    virtual bool operator ==(gum::DiscreteVariable const &aRV) const;
    virtual bool operator !=(gum::DiscreteVariable const &aRV) const;
    virtual gum::Idx operator [](std::string const &label) const;
    virtual gum::Idx index(std::string const &label) const;
    virtual std::string const toString() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class DiscretizedVar doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[11];
#endif

};


class SwigDirector_Potential_double : public gum::Potential< double >, public Swig::Director {

public:
    SwigDirector_Potential_double(PyObject *self);
    SwigDirector_Potential_double(PyObject *self, gum::MultiDimImplementation< double > *aContent);
    SwigDirector_Potential_double(PyObject *self, gum::Potential< double > const &src);
    SwigDirector_Potential_double(PyObject *self, gum::MultiDimImplementation< double > *aContent, gum::MultiDimContainer< double > const &src);
    virtual ~SwigDirector_Potential_double();
    virtual gum::Idx nbrDim() const;
    virtual gum::Size domainSize() const;
    virtual void add(gum::DiscreteVariable const &v);
    virtual void erase(gum::DiscreteVariable const &var);
    virtual gum::Sequence< gum::DiscreteVariable const * > const &variablesSequence() const;
    virtual gum::DiscreteVariable const &variable(gum::Idx arg0) const;
    virtual gum::Idx pos(gum::DiscreteVariable const &arg0) const;
    virtual bool contains(gum::DiscreteVariable const &arg0) const;
    virtual bool empty() const;
    virtual void _swap(gum::DiscreteVariable const *x, gum::DiscreteVariable const *y);
    virtual void _swapSwigPublic(gum::DiscreteVariable const *x, gum::DiscreteVariable const *y) {
      gum::Potential< double >::_swap(x,y);
    }
    virtual bool registerSlave(gum::Instantiation &i);
    virtual bool unregisterSlave(gum::Instantiation &arg0);
    virtual void changeNotification(gum::Instantiation &i, gum::DiscreteVariable const *const var, gum::Idx const &oldval, gum::Idx const &newval);
    virtual void setFirstNotification(gum::Instantiation &i);
    virtual void setLastNotification(gum::Instantiation &i);
    virtual void setIncNotification(gum::Instantiation &i);
    virtual void setDecNotification(gum::Instantiation &i);
    virtual void setChangeNotification(gum::Instantiation &i);
    virtual gum::MultiDimImplementation< double > &getMasterRef();
    virtual gum::MultiDimImplementation< double > const &getMasterRef() const;
    virtual std::string const toString(gum::Instantiation const *i) const;
    virtual void set(gum::Instantiation const &i, double const &value) const;
    virtual double get(gum::Instantiation const &i) const;
    virtual void fill(double const &d) const;
    virtual void fillWith(std::vector< double,std::allocator< double > > const &v) const;
    virtual void copy(gum::MultiDimContainer< double > const &src);
    virtual gum::Potential< double > *newFactory() const;
    virtual std::string const toString() const;
    virtual void beginMultipleChanges();
    virtual void endMultipleChanges();
    virtual void endMultipleChanges(double const &arg0);
    virtual double &_get(gum::Instantiation const &i) const;
    virtual double &_getSwigPublic(gum::Instantiation const &i) const {
      return gum::MultiDimDecorator< double >::_get(i);
    }
    virtual void notifyChange() const;
    virtual void homothetic(double alpha, double (*mul)(double const,double const));
    virtual double fold(double (*add)(double const,double const)) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Potential_double doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[35];
#endif

};


class SwigDirector_LazyPropagation_double : public gum::LazyPropagation< double >, public Swig::Director {

public:
    SwigDirector_LazyPropagation_double(PyObject *self, gum::IBayesNet< double > const &BN);
    SwigDirector_LazyPropagation_double(PyObject *self, gum::IBayesNet< double > const &BN, std::vector< gum::NodeId,std::allocator< gum::NodeId > > const &elim_order);
    virtual ~SwigDirector_LazyPropagation_double();
    virtual void makeInference();
    virtual gum::Potential< double > const &marginal(gum::NodeId id);
    virtual void insertEvidence(gum::List< gum::Potential< double > const * > const &arg0);
    virtual void eraseEvidence(gum::Potential< double > const *arg0);
    virtual void eraseAllEvidence();
    virtual void _fillMarginal(gum::Id id, gum::Potential< double > &marginal);
    virtual void _fillMarginalSwigPublic(gum::Id id, gum::Potential< double > &marginal) {
      gum::LazyPropagation< double >::_fillMarginal(id,marginal);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class LazyPropagation_double doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_GibbsInference_double : public gum::GibbsInference< double >, public Swig::Director {

public:
    SwigDirector_GibbsInference_double(PyObject *self, gum::IBayesNet< double > const &BN);
    virtual ~SwigDirector_GibbsInference_double();
    virtual void makeInference();
    virtual gum::Potential< double > const &marginal(gum::NodeId id);
    virtual void insertEvidence(gum::List< gum::Potential< double > const * > const &pot_list);
    virtual void eraseEvidence(gum::Potential< double > const *e);
    virtual void eraseAllEvidence();
    virtual void _fillMarginal(gum::NodeId id, gum::Potential< double > &marginal);
    virtual void _fillMarginalSwigPublic(gum::NodeId id, gum::Potential< double > &marginal) {
      gum::GibbsInference< double >::_fillMarginal(id,marginal);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class GibbsInference_double doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


#endif
