# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
pyAgrum is a Python wrapper for the C++ aGrUM library. It provides a high-level
interface to the part of agrum allowing to create, handle and make computations
into Bayesian Networks. The module is a straightforward application of the SWIG
interface generator.
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyAgrum', [dirname(__file__)])
        except ImportError:
            import _pyAgrum
            return _pyAgrum
        if fp is not None:
            try:
                _mod = imp.load_module('_pyAgrum', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyAgrum = swig_import_helper()
    del swig_import_helper
else:
    import _pyAgrum
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import numpy

class PythonBNListener(_object):
    """Proxy of C++ PythonBNListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonBNListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonBNListener, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(PythonBNListener self, DiGraph g, VariableNodeMap vnm) -> PythonBNListener"""
        this = _pyAgrum.new_PythonBNListener(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonBNListener
    __del__ = lambda self : None;
    def whenNodeAdded(self, *args) -> "void" :
        """whenNodeAdded(PythonBNListener self, void const * source, gum::NodeId id)"""
        return _pyAgrum.PythonBNListener_whenNodeAdded(self, *args)

    def whenNodeDeleted(self, *args) -> "void" :
        """whenNodeDeleted(PythonBNListener self, void const * arg2, gum::NodeId id)"""
        return _pyAgrum.PythonBNListener_whenNodeDeleted(self, *args)

    def whenArcAdded(self, *args) -> "void" :
        """whenArcAdded(PythonBNListener self, void const * arg2, gum::NodeId src, gum::NodeId dst)"""
        return _pyAgrum.PythonBNListener_whenArcAdded(self, *args)

    def whenArcDeleted(self, *args) -> "void" :
        """whenArcDeleted(PythonBNListener self, void const * arg2, gum::NodeId src, gum::NodeId dst)"""
        return _pyAgrum.PythonBNListener_whenArcDeleted(self, *args)

    def setWhenArcAdded(self, *args) -> "void" :
        """setWhenArcAdded(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcAdded(self, *args)

    def setWhenArcDeleted(self, *args) -> "void" :
        """setWhenArcDeleted(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenArcDeleted(self, *args)

    def setWhenNodeAdded(self, *args) -> "void" :
        """setWhenNodeAdded(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeAdded(self, *args)

    def setWhenNodeDeleted(self, *args) -> "void" :
        """setWhenNodeDeleted(PythonBNListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonBNListener_setWhenNodeDeleted(self, *args)

PythonBNListener_swigregister = _pyAgrum.PythonBNListener_swigregister
PythonBNListener_swigregister(PythonBNListener)

class PythonLoadListener(_object):
    """Proxy of C++ PythonLoadListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonLoadListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonLoadListener, name)
    __repr__ = _swig_repr
    def whenLoading(self, *args) -> "void" :
        """whenLoading(PythonLoadListener self, void const * buffer, int percent)"""
        return _pyAgrum.PythonLoadListener_whenLoading(self, *args)

    def setPythonListener(self, *args) -> "bool" :
        """setPythonListener(PythonLoadListener self, PyObject * l) -> bool"""
        return _pyAgrum.PythonLoadListener_setPythonListener(self, *args)

    def __init__(self): 
        """__init__(PythonLoadListener self) -> PythonLoadListener"""
        this = _pyAgrum.new_PythonLoadListener()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonLoadListener
    __del__ = lambda self : None;
PythonLoadListener_swigregister = _pyAgrum.PythonLoadListener_swigregister
PythonLoadListener_swigregister(PythonLoadListener)


def __fillLoadListeners(*args) -> "int" :
  """
    __fillLoadListeners(std::vector< PythonLoadListener,std::allocator< PythonLoadListener > > & py_listener, 
        PyObject * l) -> int
    """
  return _pyAgrum.__fillLoadListeners(*args)
class PythonApproximationListener(_object):
    """Proxy of C++ PythonApproximationListener class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonApproximationListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonApproximationListener, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(PythonApproximationListener self, IApproximationSchemeConfiguration algo) -> PythonApproximationListener"""
        this = _pyAgrum.new_PythonApproximationListener(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PythonApproximationListener
    __del__ = lambda self : None;
    def whenProgress(self, *args) -> "void" :
        """whenProgress(PythonApproximationListener self, void const * src, gum::Size step, double error, double duration)"""
        return _pyAgrum.PythonApproximationListener_whenProgress(self, *args)

    def whenStop(self, *args) -> "void" :
        """whenStop(PythonApproximationListener self, void const * src, std::string message)"""
        return _pyAgrum.PythonApproximationListener_whenStop(self, *args)

    def setWhenProgress(self, *args) -> "void" :
        """setWhenProgress(PythonApproximationListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenProgress(self, *args)

    def setWhenStop(self, *args) -> "void" :
        """setWhenStop(PythonApproximationListener self, PyObject * pyfunc)"""
        return _pyAgrum.PythonApproximationListener_setWhenStop(self, *args)

PythonApproximationListener_swigregister = _pyAgrum.PythonApproximationListener_swigregister
PythonApproximationListener_swigregister(PythonApproximationListener)

class BNGenerator(_object):
    """Proxy of C++ BNGenerator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BNGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BNGenerator, name)
    __repr__ = _swig_repr
    def generate(self, n_nodes : 'gum::Size'=10, n_arcs : 'gum::Size'=15, n_modmax : 'gum::Size'=4) -> "gum::BayesNet< double >" :
        """
        generate(BNGenerator self, gum::Size n_nodes=10, gum::Size n_arcs=15, gum::Size n_modmax=4) -> BayesNet_double
        generate(BNGenerator self, gum::Size n_nodes=10, gum::Size n_arcs=15) -> BayesNet_double
        generate(BNGenerator self, gum::Size n_nodes=10) -> BayesNet_double
        generate(BNGenerator self) -> BayesNet_double
        """
        return _pyAgrum.BNGenerator_generate(self, n_nodes, n_arcs, n_modmax)

    def __init__(self): 
        """__init__(BNGenerator self) -> BNGenerator"""
        this = _pyAgrum.new_BNGenerator()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_BNGenerator
    __del__ = lambda self : None;
BNGenerator_swigregister = _pyAgrum.BNGenerator_swigregister
BNGenerator_swigregister(BNGenerator)

class IDGenerator(_object):
    """Proxy of C++ IDGenerator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDGenerator, name)
    __repr__ = _swig_repr
    def generate(self, nbrNodes : 'gum::Size'=10, arcDensity : 'double'=0.2, chanceNodeDensity : 'double'=0.8, 
    utilityNodeDensity : 'double'=0.1, max_modality : 'int'=2) -> "gum::InfluenceDiagram< double >" :
        """
        generate(IDGenerator self, gum::Size nbrNodes=10, double arcDensity=0.2, double chanceNodeDensity=0.8, double utilityNodeDensity=0.1, 
            int max_modality=2) -> InfluenceDiagram_double
        generate(IDGenerator self, gum::Size nbrNodes=10, double arcDensity=0.2, double chanceNodeDensity=0.8, double utilityNodeDensity=0.1) -> InfluenceDiagram_double
        generate(IDGenerator self, gum::Size nbrNodes=10, double arcDensity=0.2, double chanceNodeDensity=0.8) -> InfluenceDiagram_double
        generate(IDGenerator self, gum::Size nbrNodes=10, double arcDensity=0.2) -> InfluenceDiagram_double
        generate(IDGenerator self, gum::Size nbrNodes=10) -> InfluenceDiagram_double
        generate(IDGenerator self) -> InfluenceDiagram_double
        """
        return _pyAgrum.IDGenerator_generate(self, nbrNodes, arcDensity, chanceNodeDensity, utilityNodeDensity, max_modality)

    def __init__(self): 
        """__init__(IDGenerator self) -> IDGenerator"""
        this = _pyAgrum.new_IDGenerator()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IDGenerator
    __del__ = lambda self : None;
IDGenerator_swigregister = _pyAgrum.IDGenerator_swigregister
IDGenerator_swigregister(IDGenerator)

class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" :
        """value(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_value(self)

    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_incr(self, n)

    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" :
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _pyAgrum.SwigPyIterator_decr(self, n)

    def distance(self, *args) -> "ptrdiff_t" :
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _pyAgrum.SwigPyIterator_distance(self, *args)

    def equal(self, *args) -> "bool" :
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator_equal(self, *args)

    def copy(self) -> "swig::SwigPyIterator *" :
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *" :
        """next(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *" :
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *" :
        """previous(SwigPyIterator self) -> PyObject *"""
        return _pyAgrum.SwigPyIterator_previous(self)

    def advance(self, *args) -> "swig::SwigPyIterator *" :
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args) -> "bool" :
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pyAgrum.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args) -> "swig::SwigPyIterator &" :
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args) -> "swig::SwigPyIterator &" :
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args) -> "swig::SwigPyIterator *" :
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pyAgrum.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args) -> "ptrdiff_t" :
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _pyAgrum.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _pyAgrum.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Vector_double(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector_double, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(Vector_double self) -> SwigPyIterator"""
        return _pyAgrum.Vector_double_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(Vector_double self) -> bool"""
        return _pyAgrum.Vector_double___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(Vector_double self) -> bool"""
        return _pyAgrum.Vector_double___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type" :
        """__len__(Vector_double self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double___len__(self)

    def pop(self) -> "std::vector< double >::value_type" :
        """pop(Vector_double self) -> std::vector< double >::value_type"""
        return _pyAgrum.Vector_double_pop(self)

    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" :
        """__getslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> Vector_double"""
        return _pyAgrum.Vector_double___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            Vector_double v=std::vector< double,std::allocator< double > >())
        __setslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _pyAgrum.Vector_double___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _pyAgrum.Vector_double___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(Vector_double self, std::vector< double >::difference_type i)
        __delitem__(Vector_double self, PySliceObject * slice)
        """
        return _pyAgrum.Vector_double___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &" :
        """
        __getitem__(Vector_double self, PySliceObject * slice) -> Vector_double
        __getitem__(Vector_double self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _pyAgrum.Vector_double___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(Vector_double self, PySliceObject * slice, Vector_double v)
        __setitem__(Vector_double self, PySliceObject * slice)
        __setitem__(Vector_double self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _pyAgrum.Vector_double___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(Vector_double self, std::vector< double >::value_type const & x)"""
        return _pyAgrum.Vector_double_append(self, *args)

    def empty(self) -> "bool" :
        """empty(Vector_double self) -> bool"""
        return _pyAgrum.Vector_double_empty(self)

    def size(self) -> "std::vector< double >::size_type" :
        """size(Vector_double self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double_size(self)

    def clear(self) -> "void" :
        """clear(Vector_double self)"""
        return _pyAgrum.Vector_double_clear(self)

    def swap(self, *args) -> "void" :
        """swap(Vector_double self, Vector_double v)"""
        return _pyAgrum.Vector_double_swap(self, *args)

    def get_allocator(self) -> "std::vector< double >::allocator_type" :
        """get_allocator(Vector_double self) -> std::vector< double >::allocator_type"""
        return _pyAgrum.Vector_double_get_allocator(self)

    def begin(self) -> "std::vector< double >::iterator" :
        """begin(Vector_double self) -> std::vector< double >::iterator"""
        return _pyAgrum.Vector_double_begin(self)

    def end(self) -> "std::vector< double >::iterator" :
        """end(Vector_double self) -> std::vector< double >::iterator"""
        return _pyAgrum.Vector_double_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator" :
        """rbegin(Vector_double self) -> std::vector< double >::reverse_iterator"""
        return _pyAgrum.Vector_double_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator" :
        """rend(Vector_double self) -> std::vector< double >::reverse_iterator"""
        return _pyAgrum.Vector_double_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(Vector_double self)"""
        return _pyAgrum.Vector_double_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator" :
        """
        erase(Vector_double self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(Vector_double self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _pyAgrum.Vector_double_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> Vector_double
        __init__(std::vector<(double)> self, Vector_double arg2) -> Vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> Vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> Vector_double
        """
        this = _pyAgrum.new_Vector_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(Vector_double self, std::vector< double >::value_type const & x)"""
        return _pyAgrum.Vector_double_push_back(self, *args)

    def front(self) -> "std::vector< double >::value_type const &" :
        """front(Vector_double self) -> std::vector< double >::value_type const &"""
        return _pyAgrum.Vector_double_front(self)

    def back(self) -> "std::vector< double >::value_type const &" :
        """back(Vector_double self) -> std::vector< double >::value_type const &"""
        return _pyAgrum.Vector_double_back(self)

    def assign(self, *args) -> "void" :
        """assign(Vector_double self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _pyAgrum.Vector_double_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(Vector_double self, std::vector< double >::size_type new_size)
        resize(Vector_double self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _pyAgrum.Vector_double_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(Vector_double self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(Vector_double self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _pyAgrum.Vector_double_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(Vector_double self, std::vector< double >::size_type n)"""
        return _pyAgrum.Vector_double_reserve(self, *args)

    def capacity(self) -> "std::vector< double >::size_type" :
        """capacity(Vector_double self) -> std::vector< double >::size_type"""
        return _pyAgrum.Vector_double_capacity(self)

    __swig_destroy__ = _pyAgrum.delete_Vector_double
    __del__ = lambda self : None;
Vector_double_swigregister = _pyAgrum.Vector_double_swigregister
Vector_double_swigregister(Vector_double)

class Vector_string(_object):
    """Proxy of C++ std::vector<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector_string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector_string, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" :
        """iterator(Vector_string self) -> SwigPyIterator"""
        return _pyAgrum.Vector_string_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" :
        """__nonzero__(Vector_string self) -> bool"""
        return _pyAgrum.Vector_string___nonzero__(self)

    def __bool__(self) -> "bool" :
        """__bool__(Vector_string self) -> bool"""
        return _pyAgrum.Vector_string___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type" :
        """__len__(Vector_string self) -> std::vector< std::string >::size_type"""
        return _pyAgrum.Vector_string___len__(self)

    def pop(self) -> "std::vector< std::string >::value_type" :
        """pop(Vector_string self) -> std::vector< std::string >::value_type"""
        return _pyAgrum.Vector_string_pop(self)

    def __getslice__(self, *args) -> "std::vector< std::string,std::allocator< std::string > > *" :
        """__getslice__(Vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> Vector_string"""
        return _pyAgrum.Vector_string___getslice__(self, *args)

    def __setslice__(self, *args) -> "void" :
        """
        __setslice__(Vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, 
            Vector_string v=std::vector< std::string,std::allocator< std::string > >())
        __setslice__(Vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        """
        return _pyAgrum.Vector_string___setslice__(self, *args)

    def __delslice__(self, *args) -> "void" :
        """__delslice__(Vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _pyAgrum.Vector_string___delslice__(self, *args)

    def __delitem__(self, *args) -> "void" :
        """
        __delitem__(Vector_string self, std::vector< std::string >::difference_type i)
        __delitem__(Vector_string self, PySliceObject * slice)
        """
        return _pyAgrum.Vector_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &" :
        """
        __getitem__(Vector_string self, PySliceObject * slice) -> Vector_string
        __getitem__(Vector_string self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _pyAgrum.Vector_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void" :
        """
        __setitem__(Vector_string self, PySliceObject * slice, Vector_string v)
        __setitem__(Vector_string self, PySliceObject * slice)
        __setitem__(Vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _pyAgrum.Vector_string___setitem__(self, *args)

    def append(self, *args) -> "void" :
        """append(Vector_string self, std::vector< std::string >::value_type const & x)"""
        return _pyAgrum.Vector_string_append(self, *args)

    def empty(self) -> "bool" :
        """empty(Vector_string self) -> bool"""
        return _pyAgrum.Vector_string_empty(self)

    def size(self) -> "std::vector< std::string >::size_type" :
        """size(Vector_string self) -> std::vector< std::string >::size_type"""
        return _pyAgrum.Vector_string_size(self)

    def clear(self) -> "void" :
        """clear(Vector_string self)"""
        return _pyAgrum.Vector_string_clear(self)

    def swap(self, *args) -> "void" :
        """swap(Vector_string self, Vector_string v)"""
        return _pyAgrum.Vector_string_swap(self, *args)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type" :
        """get_allocator(Vector_string self) -> std::vector< std::string >::allocator_type"""
        return _pyAgrum.Vector_string_get_allocator(self)

    def begin(self) -> "std::vector< std::string >::iterator" :
        """begin(Vector_string self) -> std::vector< std::string >::iterator"""
        return _pyAgrum.Vector_string_begin(self)

    def end(self) -> "std::vector< std::string >::iterator" :
        """end(Vector_string self) -> std::vector< std::string >::iterator"""
        return _pyAgrum.Vector_string_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator" :
        """rbegin(Vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _pyAgrum.Vector_string_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator" :
        """rend(Vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _pyAgrum.Vector_string_rend(self)

    def pop_back(self) -> "void" :
        """pop_back(Vector_string self)"""
        return _pyAgrum.Vector_string_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator" :
        """
        erase(Vector_string self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(Vector_string self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _pyAgrum.Vector_string_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::string)> self) -> Vector_string
        __init__(std::vector<(std::string)> self, Vector_string arg2) -> Vector_string
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> Vector_string
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> Vector_string
        """
        this = _pyAgrum.new_Vector_string(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" :
        """push_back(Vector_string self, std::vector< std::string >::value_type const & x)"""
        return _pyAgrum.Vector_string_push_back(self, *args)

    def front(self) -> "std::vector< std::string >::value_type const &" :
        """front(Vector_string self) -> std::vector< std::string >::value_type const &"""
        return _pyAgrum.Vector_string_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &" :
        """back(Vector_string self) -> std::vector< std::string >::value_type const &"""
        return _pyAgrum.Vector_string_back(self)

    def assign(self, *args) -> "void" :
        """assign(Vector_string self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _pyAgrum.Vector_string_assign(self, *args)

    def resize(self, *args) -> "void" :
        """
        resize(Vector_string self, std::vector< std::string >::size_type new_size)
        resize(Vector_string self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _pyAgrum.Vector_string_resize(self, *args)

    def insert(self, *args) -> "void" :
        """
        insert(Vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(Vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, 
            std::vector< std::string >::value_type const & x)
        """
        return _pyAgrum.Vector_string_insert(self, *args)

    def reserve(self, *args) -> "void" :
        """reserve(Vector_string self, std::vector< std::string >::size_type n)"""
        return _pyAgrum.Vector_string_reserve(self, *args)

    def capacity(self) -> "std::vector< std::string >::size_type" :
        """capacity(Vector_string self) -> std::vector< std::string >::size_type"""
        return _pyAgrum.Vector_string_capacity(self)

    __swig_destroy__ = _pyAgrum.delete_Vector_string
    __del__ = lambda self : None;
Vector_string_swigregister = _pyAgrum.Vector_string_swigregister
Vector_string_swigregister(Vector_string)

GUM_MAJOR_VERSION = _pyAgrum.GUM_MAJOR_VERSION
GUM_MINOR_VERSION = _pyAgrum.GUM_MINOR_VERSION
GUM_PATCH_VERSION = _pyAgrum.GUM_PATCH_VERSION
GUM_VERSION = _pyAgrum.GUM_VERSION
GUM_CHAR_SIZE = _pyAgrum.GUM_CHAR_SIZE
GUM_INT_SIZE = _pyAgrum.GUM_INT_SIZE
GUM_LONG_SIZE = _pyAgrum.GUM_LONG_SIZE
GUM_FLOAT_SIZE = _pyAgrum.GUM_FLOAT_SIZE
GUM_DOUBLE_SIZE = _pyAgrum.GUM_DOUBLE_SIZE
HAVE_MKSTEMP = _pyAgrum.HAVE_MKSTEMP

def __createMsg(*args) -> "std::string const" :
  """__createMsg(std::string const & filename, std::string const & function, int const line, std::string const & msg) -> std::string const"""
  return _pyAgrum.__createMsg(*args)
class Exception(Exception):
    """Proxy of C++ gum::Exception class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Exception, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Exception, name)
    __repr__ = _swig_repr
    def __init__(self, aMsg : 'std::string const'="", aType : 'std::string const'="Generic error"): 
        """
        __init__(gum::Exception self, std::string const aMsg="", std::string const aType="Generic error") -> Exception
        __init__(gum::Exception self, std::string const aMsg="") -> Exception
        __init__(gum::Exception self) -> Exception
        """
        this = _pyAgrum.new_Exception(aMsg, aType)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Exception
    __del__ = lambda self : None;
    def errorContent(self) -> "std::string const" :
        """errorContent(Exception self) -> std::string const"""
        return _pyAgrum.Exception_errorContent(self)

    def errorType(self) -> "std::string const" :
        """errorType(Exception self) -> std::string const"""
        return _pyAgrum.Exception_errorType(self)

    def errorCallStack(self) -> "std::string const" :
        """errorCallStack(Exception self) -> std::string const"""
        return _pyAgrum.Exception_errorCallStack(self)

    def __str__(self) -> "char const *" :
        """__str__(Exception self) -> char const *"""
        return _pyAgrum.Exception___str__(self)

Exception_swigregister = _pyAgrum.Exception_swigregister
Exception_swigregister(Exception)

class IdError(Exception):
    """Proxy of C++ gum::IdError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IdError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::IdError self, std::string aMsg, std::string aType="potential problem with an ID") -> IdError
        __init__(gum::IdError self, std::string aMsg) -> IdError
        """
        this = _pyAgrum.new_IdError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IdError
    __del__ = lambda self : None;
IdError_swigregister = _pyAgrum.IdError_swigregister
IdError_swigregister(IdError)

class FatalError(Exception):
    """Proxy of C++ gum::FatalError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FatalError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FatalError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FatalError self, std::string aMsg, std::string aType="Fatal error") -> FatalError
        __init__(gum::FatalError self, std::string aMsg) -> FatalError
        """
        this = _pyAgrum.new_FatalError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FatalError
    __del__ = lambda self : None;
FatalError_swigregister = _pyAgrum.FatalError_swigregister
FatalError_swigregister(FatalError)

class UndefinedIteratorValue(Exception):
    """Proxy of C++ gum::UndefinedIteratorValue class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorValue, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorValue, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::UndefinedIteratorValue self, std::string aMsg, std::string aType="Iterator\'s value is undefined") -> UndefinedIteratorValue
        __init__(gum::UndefinedIteratorValue self, std::string aMsg) -> UndefinedIteratorValue
        """
        this = _pyAgrum.new_UndefinedIteratorValue(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorValue
    __del__ = lambda self : None;
UndefinedIteratorValue_swigregister = _pyAgrum.UndefinedIteratorValue_swigregister
UndefinedIteratorValue_swigregister(UndefinedIteratorValue)

class UndefinedIteratorKey(Exception):
    """Proxy of C++ gum::UndefinedIteratorKey class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedIteratorKey, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedIteratorKey, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::UndefinedIteratorKey self, std::string aMsg, std::string aType="Iterator\'s key is undefined") -> UndefinedIteratorKey
        __init__(gum::UndefinedIteratorKey self, std::string aMsg) -> UndefinedIteratorKey
        """
        this = _pyAgrum.new_UndefinedIteratorKey(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorKey
    __del__ = lambda self : None;
UndefinedIteratorKey_swigregister = _pyAgrum.UndefinedIteratorKey_swigregister
UndefinedIteratorKey_swigregister(UndefinedIteratorKey)

class NullElement(Exception):
    """Proxy of C++ gum::NullElement class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NullElement, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NullElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NullElement self, std::string aMsg, std::string aType="Null Element") -> NullElement
        __init__(gum::NullElement self, std::string aMsg) -> NullElement
        """
        this = _pyAgrum.new_NullElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NullElement
    __del__ = lambda self : None;
NullElement_swigregister = _pyAgrum.NullElement_swigregister
NullElement_swigregister(NullElement)

class UndefinedElement(Exception):
    """Proxy of C++ gum::UndefinedElement class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndefinedElement, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UndefinedElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::UndefinedElement self, std::string aMsg, std::string aType="could not find the so-called element") -> UndefinedElement
        __init__(gum::UndefinedElement self, std::string aMsg) -> UndefinedElement
        """
        this = _pyAgrum.new_UndefinedElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndefinedElement
    __del__ = lambda self : None;
UndefinedElement_swigregister = _pyAgrum.UndefinedElement_swigregister
UndefinedElement_swigregister(UndefinedElement)

class HashSize(Exception):
    """Proxy of C++ gum::HashSize class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HashSize, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HashSize, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::HashSize self, std::string aMsg, std::string aType="size not admissible in a HashTable") -> HashSize
        __init__(gum::HashSize self, std::string aMsg) -> HashSize
        """
        this = _pyAgrum.new_HashSize(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_HashSize
    __del__ = lambda self : None;
HashSize_swigregister = _pyAgrum.HashSize_swigregister
HashSize_swigregister(HashSize)

class SizeError(Exception):
    """Proxy of C++ gum::SizeError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SizeError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SizeError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::SizeError self, std::string aMsg, std::string aType="incorrect size") -> SizeError
        __init__(gum::SizeError self, std::string aMsg) -> SizeError
        """
        this = _pyAgrum.new_SizeError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_SizeError
    __del__ = lambda self : None;
SizeError_swigregister = _pyAgrum.SizeError_swigregister
SizeError_swigregister(SizeError)

class EmptySet(Exception):
    """Proxy of C++ gum::EmptySet class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptySet, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptySet, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::EmptySet self, std::string aMsg, std::string aType="an empty set has been found where it should not be") -> EmptySet
        __init__(gum::EmptySet self, std::string aMsg) -> EmptySet
        """
        this = _pyAgrum.new_EmptySet(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptySet
    __del__ = lambda self : None;
EmptySet_swigregister = _pyAgrum.EmptySet_swigregister
EmptySet_swigregister(EmptySet)

class InvalidArgumentsNumber(Exception):
    """Proxy of C++ gum::InvalidArgumentsNumber class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgumentsNumber, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgumentsNumber, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidArgumentsNumber self, std::string aMsg, std::string aType="the number of arguments passed differs from what was expected") -> InvalidArgumentsNumber
        __init__(gum::InvalidArgumentsNumber self, std::string aMsg) -> InvalidArgumentsNumber
        """
        this = _pyAgrum.new_InvalidArgumentsNumber(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgumentsNumber
    __del__ = lambda self : None;
InvalidArgumentsNumber_swigregister = _pyAgrum.InvalidArgumentsNumber_swigregister
InvalidArgumentsNumber_swigregister(InvalidArgumentsNumber)

class InvalidArgument(Exception):
    """Proxy of C++ gum::InvalidArgument class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArgument, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArgument, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidArgument self, std::string aMsg, std::string aType="at least one argument passed differs from what was expected") -> InvalidArgument
        __init__(gum::InvalidArgument self, std::string aMsg) -> InvalidArgument
        """
        this = _pyAgrum.new_InvalidArgument(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArgument
    __del__ = lambda self : None;
InvalidArgument_swigregister = _pyAgrum.InvalidArgument_swigregister
InvalidArgument_swigregister(InvalidArgument)

class IOError(Exception):
    """Proxy of C++ gum::IOError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IOError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::IOError self, std::string aMsg, std::string aType="an input/output error occurred") -> IOError
        __init__(gum::IOError self, std::string aMsg) -> IOError
        """
        this = _pyAgrum.new_IOError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IOError
    __del__ = lambda self : None;
IOError_swigregister = _pyAgrum.IOError_swigregister
IOError_swigregister(IOError)

class FormatNotFound(IOError):
    """Proxy of C++ gum::FormatNotFound class"""
    __swig_setmethods__ = {}
    for _s in [IOError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FormatNotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FormatNotFound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FormatNotFound self, std::string aMsg, std::string aType="could not find the specified format") -> FormatNotFound
        __init__(gum::FormatNotFound self, std::string aMsg) -> FormatNotFound
        """
        this = _pyAgrum.new_FormatNotFound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FormatNotFound
    __del__ = lambda self : None;
FormatNotFound_swigregister = _pyAgrum.FormatNotFound_swigregister
FormatNotFound_swigregister(FormatNotFound)

class OperationNotAllowed(Exception):
    """Proxy of C++ gum::OperationNotAllowed class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OperationNotAllowed, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OperationNotAllowed, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OperationNotAllowed self, std::string aMsg, std::string aType="this operation is not allowed") -> OperationNotAllowed
        __init__(gum::OperationNotAllowed self, std::string aMsg) -> OperationNotAllowed
        """
        this = _pyAgrum.new_OperationNotAllowed(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OperationNotAllowed
    __del__ = lambda self : None;
OperationNotAllowed_swigregister = _pyAgrum.OperationNotAllowed_swigregister
OperationNotAllowed_swigregister(OperationNotAllowed)

class NotFound(Exception):
    """Proxy of C++ gum::NotFound class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotFound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NotFound self, std::string aMsg, std::string aType="could not find this object") -> NotFound
        __init__(gum::NotFound self, std::string aMsg) -> NotFound
        """
        this = _pyAgrum.new_NotFound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NotFound
    __del__ = lambda self : None;
NotFound_swigregister = _pyAgrum.NotFound_swigregister
NotFound_swigregister(NotFound)

class ReferenceError(Exception):
    """Proxy of C++ gum::ReferenceError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReferenceError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReferenceError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::ReferenceError self, std::string aMsg, std::string aType="Reference error") -> ReferenceError
        __init__(gum::ReferenceError self, std::string aMsg) -> ReferenceError
        """
        this = _pyAgrum.new_ReferenceError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_ReferenceError
    __del__ = lambda self : None;
ReferenceError_swigregister = _pyAgrum.ReferenceError_swigregister
ReferenceError_swigregister(ReferenceError)

class OutOfBounds(ReferenceError):
    """Proxy of C++ gum::OutOfBounds class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfBounds, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfBounds, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OutOfBounds self, std::string aMsg, std::string aType="Out of bound") -> OutOfBounds
        __init__(gum::OutOfBounds self, std::string aMsg) -> OutOfBounds
        """
        this = _pyAgrum.new_OutOfBounds(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfBounds
    __del__ = lambda self : None;
OutOfBounds_swigregister = _pyAgrum.OutOfBounds_swigregister
OutOfBounds_swigregister(OutOfBounds)

class OutOfLowerBound(OutOfBounds):
    """Proxy of C++ gum::OutOfLowerBound class"""
    __swig_setmethods__ = {}
    for _s in [OutOfBounds]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfLowerBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfLowerBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OutOfLowerBound self, std::string aMsg, std::string aType="Out of lower bound") -> OutOfLowerBound
        __init__(gum::OutOfLowerBound self, std::string aMsg) -> OutOfLowerBound
        """
        this = _pyAgrum.new_OutOfLowerBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfLowerBound
    __del__ = lambda self : None;
OutOfLowerBound_swigregister = _pyAgrum.OutOfLowerBound_swigregister
OutOfLowerBound_swigregister(OutOfLowerBound)

class OutOfUpperBound(OutOfBounds):
    """Proxy of C++ gum::OutOfUpperBound class"""
    __swig_setmethods__ = {}
    for _s in [OutOfBounds]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfUpperBound, name, value)
    __swig_getmethods__ = {}
    for _s in [OutOfBounds]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfUpperBound, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::OutOfUpperBound self, std::string aMsg, std::string aType="Out of upper bound") -> OutOfUpperBound
        __init__(gum::OutOfUpperBound self, std::string aMsg) -> OutOfUpperBound
        """
        this = _pyAgrum.new_OutOfUpperBound(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_OutOfUpperBound
    __del__ = lambda self : None;
OutOfUpperBound_swigregister = _pyAgrum.OutOfUpperBound_swigregister
OutOfUpperBound_swigregister(OutOfUpperBound)

class DuplicateElement(ReferenceError):
    """Proxy of C++ gum::DuplicateElement class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateElement, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DuplicateElement self, std::string aMsg, std::string aType="A similar element already exists") -> DuplicateElement
        __init__(gum::DuplicateElement self, std::string aMsg) -> DuplicateElement
        """
        this = _pyAgrum.new_DuplicateElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateElement
    __del__ = lambda self : None;
DuplicateElement_swigregister = _pyAgrum.DuplicateElement_swigregister
DuplicateElement_swigregister(DuplicateElement)

class DuplicateLabel(ReferenceError):
    """Proxy of C++ gum::DuplicateLabel class"""
    __swig_setmethods__ = {}
    for _s in [ReferenceError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [ReferenceError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateLabel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DuplicateLabel self, std::string aMsg, std::string aType="A similar label already exists") -> DuplicateLabel
        __init__(gum::DuplicateLabel self, std::string aMsg) -> DuplicateLabel
        """
        this = _pyAgrum.new_DuplicateLabel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DuplicateLabel
    __del__ = lambda self : None;
DuplicateLabel_swigregister = _pyAgrum.DuplicateLabel_swigregister
DuplicateLabel_swigregister(DuplicateLabel)

class GraphError(Exception):
    """Proxy of C++ gum::GraphError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GraphError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GraphError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::GraphError self, std::string aMsg, std::string aType="Graph error") -> GraphError
        __init__(gum::GraphError self, std::string aMsg) -> GraphError
        """
        this = _pyAgrum.new_GraphError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GraphError
    __del__ = lambda self : None;
GraphError_swigregister = _pyAgrum.GraphError_swigregister
GraphError_swigregister(GraphError)

class NoNeighbour(GraphError):
    """Proxy of C++ gum::NoNeighbour class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoNeighbour, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoNeighbour, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NoNeighbour self, std::string aMsg, std::string aType="No neighbour can be found to the given node") -> NoNeighbour
        __init__(gum::NoNeighbour self, std::string aMsg) -> NoNeighbour
        """
        this = _pyAgrum.new_NoNeighbour(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoNeighbour
    __del__ = lambda self : None;
NoNeighbour_swigregister = _pyAgrum.NoNeighbour_swigregister
NoNeighbour_swigregister(NoNeighbour)

class NoParent(GraphError):
    """Proxy of C++ gum::NoParent class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoParent, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoParent, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NoParent self, std::string aMsg, std::string aType="No parent can be found w.r.t the given node") -> NoParent
        __init__(gum::NoParent self, std::string aMsg) -> NoParent
        """
        this = _pyAgrum.new_NoParent(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoParent
    __del__ = lambda self : None;
NoParent_swigregister = _pyAgrum.NoParent_swigregister
NoParent_swigregister(NoParent)

class NoChild(GraphError):
    """Proxy of C++ gum::NoChild class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoChild, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoChild, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::NoChild self, std::string aMsg, std::string aType="No child can be found w.r.t the given node") -> NoChild
        __init__(gum::NoChild self, std::string aMsg) -> NoChild
        """
        this = _pyAgrum.new_NoChild(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_NoChild
    __del__ = lambda self : None;
NoChild_swigregister = _pyAgrum.NoChild_swigregister
NoChild_swigregister(NoChild)

class InvalidEdge(GraphError):
    """Proxy of C++ gum::InvalidEdge class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidEdge, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidEdge self, std::string aMsg, std::string aType="the edge is not correct") -> InvalidEdge
        __init__(gum::InvalidEdge self, std::string aMsg) -> InvalidEdge
        """
        this = _pyAgrum.new_InvalidEdge(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidEdge
    __del__ = lambda self : None;
InvalidEdge_swigregister = _pyAgrum.InvalidEdge_swigregister
InvalidEdge_swigregister(InvalidEdge)

class InvalidArc(GraphError):
    """Proxy of C++ gum::InvalidArc class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidArc, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidArc, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidArc self, std::string aMsg, std::string aType="the arc is not correct") -> InvalidArc
        __init__(gum::InvalidArc self, std::string aMsg) -> InvalidArc
        """
        this = _pyAgrum.new_InvalidArc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidArc
    __del__ = lambda self : None;
InvalidArc_swigregister = _pyAgrum.InvalidArc_swigregister
InvalidArc_swigregister(InvalidArc)

class InvalidNode(GraphError):
    """Proxy of C++ gum::InvalidNode class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidNode self, std::string aMsg, std::string aType="the node does not exist") -> InvalidNode
        __init__(gum::InvalidNode self, std::string aMsg) -> InvalidNode
        """
        this = _pyAgrum.new_InvalidNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidNode
    __del__ = lambda self : None;
InvalidNode_swigregister = _pyAgrum.InvalidNode_swigregister
InvalidNode_swigregister(InvalidNode)

class EmptyBSTree(GraphError):
    """Proxy of C++ gum::EmptyBSTree class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptyBSTree, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptyBSTree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::EmptyBSTree self, std::string aMsg, std::string aType="the binary search tree is empty") -> EmptyBSTree
        __init__(gum::EmptyBSTree self, std::string aMsg) -> EmptyBSTree
        """
        this = _pyAgrum.new_EmptyBSTree(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_EmptyBSTree
    __del__ = lambda self : None;
EmptyBSTree_swigregister = _pyAgrum.EmptyBSTree_swigregister
EmptyBSTree_swigregister(EmptyBSTree)

class DefaultInLabel(GraphError):
    """Proxy of C++ gum::DefaultInLabel class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultInLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultInLabel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DefaultInLabel self, std::string aMsg, std::string aType="Error on label") -> DefaultInLabel
        __init__(gum::DefaultInLabel self, std::string aMsg) -> DefaultInLabel
        """
        this = _pyAgrum.new_DefaultInLabel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DefaultInLabel
    __del__ = lambda self : None;
DefaultInLabel_swigregister = _pyAgrum.DefaultInLabel_swigregister
DefaultInLabel_swigregister(DefaultInLabel)

class InvalidDirectedCycle(GraphError):
    """Proxy of C++ gum::InvalidDirectedCycle class"""
    __swig_setmethods__ = {}
    for _s in [GraphError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvalidDirectedCycle, name, value)
    __swig_getmethods__ = {}
    for _s in [GraphError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvalidDirectedCycle, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::InvalidDirectedCycle self, std::string aMsg, std::string aType="the graph contains a directed cycle") -> InvalidDirectedCycle
        __init__(gum::InvalidDirectedCycle self, std::string aMsg) -> InvalidDirectedCycle
        """
        this = _pyAgrum.new_InvalidDirectedCycle(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InvalidDirectedCycle
    __del__ = lambda self : None;
InvalidDirectedCycle_swigregister = _pyAgrum.InvalidDirectedCycle_swigregister
InvalidDirectedCycle_swigregister(InvalidDirectedCycle)

class CPTError(Exception):
    """Proxy of C++ gum::CPTError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::CPTError self, std::string aMsg, std::string aType="CPT error") -> CPTError
        __init__(gum::CPTError self, std::string aMsg) -> CPTError
        """
        this = _pyAgrum.new_CPTError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTError
    __del__ = lambda self : None;
CPTError_swigregister = _pyAgrum.CPTError_swigregister
CPTError_swigregister(CPTError)

class CPTNoSumTo1(CPTError):
    """Proxy of C++ gum::CPTNoSumTo1 class"""
    __swig_setmethods__ = {}
    for _s in [CPTError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPTNoSumTo1, name, value)
    __swig_getmethods__ = {}
    for _s in [CPTError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPTNoSumTo1, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::CPTNoSumTo1 self, std::string aMsg, std::string aType="CPT does not sum to 1") -> CPTNoSumTo1
        __init__(gum::CPTNoSumTo1 self, std::string aMsg) -> CPTNoSumTo1
        """
        this = _pyAgrum.new_CPTNoSumTo1(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CPTNoSumTo1
    __del__ = lambda self : None;
CPTNoSumTo1_swigregister = _pyAgrum.CPTNoSumTo1_swigregister
CPTNoSumTo1_swigregister(CPTNoSumTo1)

class FactoryError(Exception):
    """Proxy of C++ gum::FactoryError class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryError, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FactoryError self, std::string aMsg, std::string aType="factory error") -> FactoryError
        __init__(gum::FactoryError self, std::string aMsg) -> FactoryError
        """
        this = _pyAgrum.new_FactoryError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryError
    __del__ = lambda self : None;
FactoryError_swigregister = _pyAgrum.FactoryError_swigregister
FactoryError_swigregister(FactoryError)

class FactoryInvalidState(FactoryError):
    """Proxy of C++ gum::FactoryInvalidState class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryInvalidState, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryInvalidState, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::FactoryInvalidState self, std::string aMsg, std::string aType="invalid state error") -> FactoryInvalidState
        __init__(gum::FactoryInvalidState self, std::string aMsg) -> FactoryInvalidState
        """
        this = _pyAgrum.new_FactoryInvalidState(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_FactoryInvalidState
    __del__ = lambda self : None;
FactoryInvalidState_swigregister = _pyAgrum.FactoryInvalidState_swigregister
FactoryInvalidState_swigregister(FactoryInvalidState)

class WrongType(FactoryError):
    """Proxy of C++ gum::WrongType class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongType, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongType, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::WrongType self, std::string aMsg, std::string aType="wrong type for this operation") -> WrongType
        __init__(gum::WrongType self, std::string aMsg) -> WrongType
        """
        this = _pyAgrum.new_WrongType(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongType
    __del__ = lambda self : None;
WrongType_swigregister = _pyAgrum.WrongType_swigregister
WrongType_swigregister(WrongType)

class WrongClassElement(FactoryError):
    """Proxy of C++ gum::WrongClassElement class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrongClassElement, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrongClassElement, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::WrongClassElement self, std::string aMsg, std::string aType="wrong ClassElement for this operation") -> WrongClassElement
        __init__(gum::WrongClassElement self, std::string aMsg) -> WrongClassElement
        """
        this = _pyAgrum.new_WrongClassElement(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_WrongClassElement
    __del__ = lambda self : None;
WrongClassElement_swigregister = _pyAgrum.WrongClassElement_swigregister
WrongClassElement_swigregister(WrongClassElement)

class TypeError(FactoryError):
    """Proxy of C++ gum::TypeError class"""
    __swig_setmethods__ = {}
    for _s in [FactoryError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeError, name, value)
    __swig_getmethods__ = {}
    for _s in [FactoryError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TypeError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::TypeError self, std::string aMsg, std::string aType="wrong subtype or subclass") -> TypeError
        __init__(gum::TypeError self, std::string aMsg) -> TypeError
        """
        this = _pyAgrum.new_TypeError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_TypeError
    __del__ = lambda self : None;
TypeError_swigregister = _pyAgrum.TypeError_swigregister
TypeError_swigregister(TypeError)

class IncompatibleScoreApriori(Exception):
    """Proxy of C++ gum::IncompatibleScoreApriori class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IncompatibleScoreApriori, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IncompatibleScoreApriori, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::IncompatibleScoreApriori self, std::string aMsg, std::string aType="The score already contains a different \'implicit\' apriori") -> IncompatibleScoreApriori
        __init__(gum::IncompatibleScoreApriori self, std::string aMsg) -> IncompatibleScoreApriori
        """
        this = _pyAgrum.new_IncompatibleScoreApriori(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_IncompatibleScoreApriori
    __del__ = lambda self : None;
IncompatibleScoreApriori_swigregister = _pyAgrum.IncompatibleScoreApriori_swigregister
IncompatibleScoreApriori_swigregister(IncompatibleScoreApriori)

class PossiblyIncompatibleScoreApriori(Exception):
    """Proxy of C++ gum::PossiblyIncompatibleScoreApriori class"""
    __swig_setmethods__ = {}
    for _s in [Exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PossiblyIncompatibleScoreApriori, name, value)
    __swig_getmethods__ = {}
    for _s in [Exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PossiblyIncompatibleScoreApriori, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::PossiblyIncompatibleScoreApriori self, std::string aMsg, std::string aType="Due to its weight, the apriori is currently compatible with the score but if you change the weight, it will become incompatible") -> PossiblyIncompatibleScoreApriori
        __init__(gum::PossiblyIncompatibleScoreApriori self, std::string aMsg) -> PossiblyIncompatibleScoreApriori
        """
        this = _pyAgrum.new_PossiblyIncompatibleScoreApriori(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_PossiblyIncompatibleScoreApriori
    __del__ = lambda self : None;
PossiblyIncompatibleScoreApriori_swigregister = _pyAgrum.PossiblyIncompatibleScoreApriori_swigregister
PossiblyIncompatibleScoreApriori_swigregister(PossiblyIncompatibleScoreApriori)

class SyntaxError(IOError):
    """Proxy of C++ gum::SyntaxError class"""
    __swig_setmethods__ = {}
    for _s in [IOError]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SyntaxError, name, value)
    __swig_getmethods__ = {}
    for _s in [IOError]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SyntaxError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::SyntaxError self, std::string const & aMsg, gum::Size nol, gum::Size noc, std::string aType="Syntax Error") -> SyntaxError
        __init__(gum::SyntaxError self, std::string const & aMsg, gum::Size nol, gum::Size noc) -> SyntaxError
        """
        this = _pyAgrum.new_SyntaxError(*args)
        try: self.this.append(this)
        except: self.this = this
    def col(self) -> "gum::Size" :
        """col(SyntaxError self) -> gum::Size"""
        return _pyAgrum.SyntaxError_col(self)

    def line(self) -> "gum::Size" :
        """line(SyntaxError self) -> gum::Size"""
        return _pyAgrum.SyntaxError_line(self)

    __swig_destroy__ = _pyAgrum.delete_SyntaxError
    __del__ = lambda self : None;
SyntaxError_swigregister = _pyAgrum.SyntaxError_swigregister
SyntaxError_swigregister(SyntaxError)


def randomProba() -> "double" :
  """randomProba() -> double"""
  return _pyAgrum.randomProba()

def initRandom(init : 'unsigned int'=0) -> "void" :
  """
    initRandom(unsigned int init=0)
    initRandom()
    """
  return _pyAgrum.initRandom(init)

def randomGeneratorSeed(seed : 'unsigned int'=0) -> "unsigned int &" :
  """
    randomGeneratorSeed(unsigned int seed=0) -> unsigned int
    randomGeneratorSeed() -> unsigned int &
    """
  return _pyAgrum.randomGeneratorSeed(seed)

def isOMP() -> "bool" :
  """isOMP() -> bool"""
  return _pyAgrum.isOMP()

def setNumberOfThreads(*args) -> "void" :
  """setNumberOfThreads(unsigned int number)"""
  return _pyAgrum.setNumberOfThreads(*args)

def getMaxNumberOfThreads() -> "unsigned int" :
  """getMaxNumberOfThreads() -> unsigned int"""
  return _pyAgrum.getMaxNumberOfThreads()

def getThreadNumber() -> "unsigned int" :
  """getThreadNumber() -> unsigned int"""
  return _pyAgrum.getThreadNumber()

def getNumberOfRunningThreads() -> "unsigned int" :
  """getNumberOfRunningThreads() -> unsigned int"""
  return _pyAgrum.getNumberOfRunningThreads()

def getNumberOfLogicalProcessors() -> "unsigned int" :
  """getNumberOfLogicalProcessors() -> unsigned int"""
  return _pyAgrum.getNumberOfLogicalProcessors()

def setNestedParallelism(*args) -> "void" :
  """setNestedParallelism(bool value)"""
  return _pyAgrum.setNestedParallelism(*args)

def getNestedParallelism() -> "bool" :
  """getNestedParallelism() -> bool"""
  return _pyAgrum.getNestedParallelism()

def setDynamicThreadsNumber(*args) -> "void" :
  """setDynamicThreadsNumber(bool value)"""
  return _pyAgrum.setDynamicThreadsNumber(*args)

def getDynamicThreadsNumber() -> "bool" :
  """getDynamicThreadsNumber() -> bool"""
  return _pyAgrum.getDynamicThreadsNumber()
class Variable(_object):
    """Proxy of C++ gum::Variable class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_Variable
    __del__ = lambda self : None;
    def clone(self) -> "gum::Variable *" :
        """clone(Variable self) -> Variable"""
        return _pyAgrum.Variable_clone(self)

    def __eq__(self, *args) -> "bool" :
        """__eq__(Variable self, Variable aRV) -> bool"""
        return _pyAgrum.Variable___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(Variable self, Variable aRV) -> bool"""
        return _pyAgrum.Variable___ne__(self, *args)

    def setName(self, *args) -> "void" :
        """setName(Variable self, std::string const & theValue)"""
        return _pyAgrum.Variable_setName(self, *args)

    def name(self) -> "std::string const &" :
        """name(Variable self) -> std::string const &"""
        return _pyAgrum.Variable_name(self)

    def setDescription(self, *args) -> "void" :
        """setDescription(Variable self, std::string const & theValue)"""
        return _pyAgrum.Variable_setDescription(self, *args)

    def description(self) -> "std::string const &" :
        """description(Variable self) -> std::string const &"""
        return _pyAgrum.Variable_description(self)

Variable_swigregister = _pyAgrum.Variable_swigregister
Variable_swigregister(Variable)

class DiscreteVariable(Variable):
    """Proxy of C++ gum::DiscreteVariable class"""
    __swig_setmethods__ = {}
    for _s in [Variable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [Variable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteVariable, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Discretized = _pyAgrum.DiscreteVariable_Discretized
    Labelized = _pyAgrum.DiscreteVariable_Labelized
    Range = _pyAgrum.DiscreteVariable_Range
    __swig_destroy__ = _pyAgrum.delete_DiscreteVariable
    __del__ = lambda self : None;
    def clone(self) -> "gum::DiscreteVariable *" :
        """clone(DiscreteVariable self) -> DiscreteVariable"""
        return _pyAgrum.DiscreteVariable_clone(self)

    def empty(self) -> "bool" :
        """empty(DiscreteVariable self) -> bool"""
        return _pyAgrum.DiscreteVariable_empty(self)

    def domainSize(self) -> "gum::Size" :
        """domainSize(DiscreteVariable self) -> gum::Size"""
        return _pyAgrum.DiscreteVariable_domainSize(self)

    def label(self, *args) -> "std::string const" :
        """label(DiscreteVariable self, gum::Idx indice) -> std::string const"""
        return _pyAgrum.DiscreteVariable_label(self, *args)

    def numerical(self, *args) -> "double" :
        """numerical(DiscreteVariable self, gum::Idx indice) -> double"""
        return _pyAgrum.DiscreteVariable_numerical(self, *args)

    def varType(self) -> "gum::DiscreteVariable::VarType" :
        """varType(DiscreteVariable self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.DiscreteVariable_varType(self)

    def __eq__(self, *args) -> "bool" :
        """__eq__(DiscreteVariable self, DiscreteVariable aRV) -> bool"""
        return _pyAgrum.DiscreteVariable___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(DiscreteVariable self, DiscreteVariable aRV) -> bool"""
        return _pyAgrum.DiscreteVariable___ne__(self, *args)

    def index(self, *args) -> "gum::Idx" :
        """index(DiscreteVariable self, std::string const & label) -> gum::Idx"""
        return _pyAgrum.DiscreteVariable_index(self, *args)

    def __str__(self) -> "std::string const" :
        """__str__(DiscreteVariable self) -> std::string const"""
        return _pyAgrum.DiscreteVariable___str__(self)

    def __getitem__(self,label):   # adding the y() function here
        return self.index(label)

    def toLabelizedVar(self) -> "gum::LabelizedVariable &" :
        """toLabelizedVar(DiscreteVariable self) -> LabelizedVariable"""
        return _pyAgrum.DiscreteVariable_toLabelizedVar(self)

    def toRangeVar(self) -> "gum::RangeVariable &" :
        """toRangeVar(DiscreteVariable self) -> RangeVariable"""
        return _pyAgrum.DiscreteVariable_toRangeVar(self)

    def toDiscretizedVar(self) -> "gum::DiscretizedVariable< double > &" :
        """toDiscretizedVar(DiscreteVariable self) -> DiscretizedVariable_double"""
        return _pyAgrum.DiscreteVariable_toDiscretizedVar(self)

DiscreteVariable_swigregister = _pyAgrum.DiscreteVariable_swigregister
DiscreteVariable_swigregister(DiscreteVariable)

class LabelizedVariable(DiscreteVariable):
    """Proxy of C++ gum::LabelizedVariable class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVariable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelizedVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVariable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelizedVariable, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::LabelizedVariable self, std::string const & aName, std::string const & aDesc="", int const nbrLabel=2) -> LabelizedVariable
        __init__(gum::LabelizedVariable self, std::string const & aName, std::string const & aDesc="") -> LabelizedVariable
        __init__(gum::LabelizedVariable self, std::string const & aName) -> LabelizedVariable
        __init__(gum::LabelizedVariable self, LabelizedVariable aLDRV) -> LabelizedVariable
        """
        this = _pyAgrum.new_LabelizedVariable(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_LabelizedVariable
    __del__ = lambda self : None;
    def clone(self) -> "gum::DiscreteVariable *" :
        """clone(LabelizedVariable self) -> DiscreteVariable"""
        return _pyAgrum.LabelizedVariable_clone(self)

    def index(self, *args) -> "gum::Idx" :
        """index(LabelizedVariable self, std::string const & label) -> gum::Idx"""
        return _pyAgrum.LabelizedVariable_index(self, *args)

    def isLabel(self, *args) -> "bool" :
        """isLabel(LabelizedVariable self, std::string const & aLabel) -> bool"""
        return _pyAgrum.LabelizedVariable_isLabel(self, *args)

    def addLabel(self,*args):
      _pyAgrum.LabelizedVariable_addLabel(self,*args)
      return self


    def changeLabel(self, *args) -> "void" :
        """changeLabel(LabelizedVariable self, gum::Idx pos, std::string const aLabel)"""
        return _pyAgrum.LabelizedVariable_changeLabel(self, *args)

    def eraseLabels(self) -> "void" :
        """eraseLabels(LabelizedVariable self)"""
        return _pyAgrum.LabelizedVariable_eraseLabels(self)

    def label(self, *args) -> "std::string const" :
        """label(LabelizedVariable self, gum::Idx i) -> std::string const"""
        return _pyAgrum.LabelizedVariable_label(self, *args)

    def numerical(self, *args) -> "double" :
        """numerical(LabelizedVariable self, gum::Idx indice) -> double"""
        return _pyAgrum.LabelizedVariable_numerical(self, *args)

    def domainSize(self) -> "gum::Size" :
        """domainSize(LabelizedVariable self) -> gum::Size"""
        return _pyAgrum.LabelizedVariable_domainSize(self)

    def labels(self) -> "gum::Sequence< std::string > const &" :
        """labels(LabelizedVariable self) -> gum::Sequence< std::string > const &"""
        return _pyAgrum.LabelizedVariable_labels(self)

    def varType(self) -> "gum::DiscreteVariable::VarType" :
        """varType(LabelizedVariable self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.LabelizedVariable_varType(self)

LabelizedVariable_swigregister = _pyAgrum.LabelizedVariable_swigregister
LabelizedVariable_swigregister(LabelizedVariable)

class RangeVariable(DiscreteVariable):
    """Proxy of C++ gum::RangeVariable class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVariable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RangeVariable, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVariable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RangeVariable, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::RangeVariable self, std::string const & aName, std::string const & aDesc, gum::Idx minVal=0, gum::Idx maxVal=1) -> RangeVariable
        __init__(gum::RangeVariable self, std::string const & aName, std::string const & aDesc, gum::Idx minVal=0) -> RangeVariable
        __init__(gum::RangeVariable self, std::string const & aName, std::string const & aDesc) -> RangeVariable
        __init__(gum::RangeVariable self, RangeVariable aDRV) -> RangeVariable
        """
        this = _pyAgrum.new_RangeVariable(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_RangeVariable
    __del__ = lambda self : None;
    def clone(self) -> "gum::DiscreteVariable *" :
        """clone(RangeVariable self) -> DiscreteVariable"""
        return _pyAgrum.RangeVariable_clone(self)

    def domainSize(self) -> "gum::Size" :
        """domainSize(RangeVariable self) -> gum::Size"""
        return _pyAgrum.RangeVariable_domainSize(self)

    def varType(self) -> "gum::DiscreteVariable::VarType" :
        """varType(RangeVariable self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.RangeVariable_varType(self)

    def label(self, *args) -> "std::string const" :
        """label(RangeVariable self, gum::Idx indice) -> std::string const"""
        return _pyAgrum.RangeVariable_label(self, *args)

    def numerical(self, *args) -> "double" :
        """numerical(RangeVariable self, gum::Idx indice) -> double"""
        return _pyAgrum.RangeVariable_numerical(self, *args)

    def minVal(self) -> "gum::Idx" :
        """minVal(RangeVariable self) -> gum::Idx"""
        return _pyAgrum.RangeVariable_minVal(self)

    def setMinVal(self, *args) -> "void" :
        """setMinVal(RangeVariable self, gum::Idx minVal)"""
        return _pyAgrum.RangeVariable_setMinVal(self, *args)

    def maxVal(self) -> "gum::Idx" :
        """maxVal(RangeVariable self) -> gum::Idx"""
        return _pyAgrum.RangeVariable_maxVal(self)

    def setMaxVal(self, *args) -> "void" :
        """setMaxVal(RangeVariable self, gum::Idx maxVal)"""
        return _pyAgrum.RangeVariable_setMaxVal(self, *args)

    def belongs(self, *args) -> "bool" :
        """belongs(RangeVariable self, gum::Idx indice) -> bool"""
        return _pyAgrum.RangeVariable_belongs(self, *args)

    def index(self, *args) -> "gum::Idx" :
        """index(RangeVariable self, std::string const & arg2) -> gum::Idx"""
        return _pyAgrum.RangeVariable_index(self, *args)

    def __str__(self) -> "std::string const" :
        """__str__(RangeVariable self) -> std::string const"""
        return _pyAgrum.RangeVariable___str__(self)

RangeVariable_swigregister = _pyAgrum.RangeVariable_swigregister
RangeVariable_swigregister(RangeVariable)

INC_MARKS_ARRAY = _pyAgrum.INC_MARKS_ARRAY
class Edge(_object):
    """Proxy of C++ gum::Edge class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Edge, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Edge, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Edge self, gum::NodeId aN1, gum::NodeId aN2) -> Edge
        __init__(gum::Edge self, Edge src) -> Edge
        """
        this = _pyAgrum.new_Edge(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Edge
    __del__ = lambda self : None;
    def isDirected(self) -> "bool" :
        """isDirected(Edge self) -> bool"""
        return _pyAgrum.Edge_isDirected(self)

    def other(self, *args) -> "gum::NodeId" :
        """other(Edge self, gum::NodeId id) -> gum::NodeId"""
        return _pyAgrum.Edge_other(self, *args)

    def first(self) -> "gum::NodeId" :
        """first(Edge self) -> gum::NodeId"""
        return _pyAgrum.Edge_first(self)

    def second(self) -> "gum::NodeId" :
        """second(Edge self) -> gum::NodeId"""
        return _pyAgrum.Edge_second(self)

    def __eq__(self, *args) -> "bool" :
        """__eq__(Edge self, Edge src) -> bool"""
        return _pyAgrum.Edge___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(Edge self, Edge src) -> bool"""
        return _pyAgrum.Edge___ne__(self, *args)

Edge_swigregister = _pyAgrum.Edge_swigregister
Edge_swigregister(Edge)

class Arc(_object):
    """Proxy of C++ gum::Arc class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Arc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Arc, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Arc self, gum::NodeId tail, gum::NodeId head) -> Arc
        __init__(gum::Arc self, Arc src) -> Arc
        """
        this = _pyAgrum.new_Arc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Arc
    __del__ = lambda self : None;
    def tail(self) -> "gum::NodeId" :
        """tail(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_tail(self)

    def head(self) -> "gum::NodeId" :
        """head(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_head(self)

    def isDirected(self) -> "bool" :
        """isDirected(Arc self) -> bool"""
        return _pyAgrum.Arc_isDirected(self)

    def other(self, *args) -> "gum::NodeId" :
        """other(Arc self, gum::NodeId id) -> gum::NodeId"""
        return _pyAgrum.Arc_other(self, *args)

    def first(self) -> "gum::NodeId" :
        """first(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_first(self)

    def second(self) -> "gum::NodeId" :
        """second(Arc self) -> gum::NodeId"""
        return _pyAgrum.Arc_second(self)

    def __eq__(self, *args) -> "bool" :
        """__eq__(Arc self, Arc src) -> bool"""
        return _pyAgrum.Arc___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(Arc self, Arc src) -> bool"""
        return _pyAgrum.Arc___ne__(self, *args)

Arc_swigregister = _pyAgrum.Arc_swigregister
Arc_swigregister(Arc)

class DiGraph(_object):
    """Proxy of C++ gum::DiGraph class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DiGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size, bool arcs_resize_policy=True) -> DiGraph
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size) -> DiGraph
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True) -> DiGraph
        __init__(gum::DiGraph self, gum::Size nodes_size=HashTableConst::default_size) -> DiGraph
        __init__(gum::DiGraph self) -> DiGraph
        __init__(gum::DiGraph self, DiGraph g) -> DiGraph
        """
        this = _pyAgrum.new_DiGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiGraph
    __del__ = lambda self : None;
    def __eq__(self, *args) -> "bool" :
        """__eq__(DiGraph self, DiGraph g) -> bool"""
        return _pyAgrum.DiGraph___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(DiGraph self, DiGraph g) -> bool"""
        return _pyAgrum.DiGraph___ne__(self, *args)

    def addArc(self, *args) -> "void" :
        """addArc(DiGraph self, gum::NodeId const tail, gum::NodeId const head)"""
        return _pyAgrum.DiGraph_addArc(self, *args)

    def eraseNode(self, *args) -> "void" :
        """eraseNode(DiGraph self, gum::NodeId const id)"""
        return _pyAgrum.DiGraph_eraseNode(self, *args)

    def clear(self) -> "void" :
        """clear(DiGraph self)"""
        return _pyAgrum.DiGraph_clear(self)

    def __str__(self) -> "std::string const" :
        """__str__(DiGraph self) -> std::string const"""
        return _pyAgrum.DiGraph___str__(self)

    def toDot(self, name : 'std::string const &'="G") -> "std::string const" :
        """
        toDot(DiGraph self, std::string const & name="G") -> std::string const
        toDot(DiGraph self) -> std::string const
        """
        return _pyAgrum.DiGraph_toDot(self, name)

    def ids(self) -> "PyObject *" :
        """ids(DiGraph self) -> PyObject *"""
        return _pyAgrum.DiGraph_ids(self)

    def arcs(self) -> "PyObject *" :
        """arcs(DiGraph self) -> PyObject *"""
        return _pyAgrum.DiGraph_arcs(self)

    def addNode(self, *args) -> "void" :
        """
        addNode(DiGraph self) -> gum::NodeId
        addNode(DiGraph self, gum::NodeId const id)
        """
        return _pyAgrum.DiGraph_addNode(self, *args)

    def existsNode(self, *args) -> "bool" :
        """existsNode(DiGraph self, gum::NodeId const id) -> bool"""
        return _pyAgrum.DiGraph_existsNode(self, *args)

    def size(self) -> "gum::Size" :
        """size(DiGraph self) -> gum::Size"""
        return _pyAgrum.DiGraph_size(self)

    def empty(self) -> "bool" :
        """empty(DiGraph self) -> bool"""
        return _pyAgrum.DiGraph_empty(self)

    def eraseArc(self, *args) -> "void" :
        """eraseArc(DiGraph self, Arc arc)"""
        return _pyAgrum.DiGraph_eraseArc(self, *args)

    def existsArc(self, *args) -> "bool" :
        """
        existsArc(DiGraph self, Arc arc) -> bool
        existsArc(DiGraph self, gum::NodeId const tail, gum::NodeId const head) -> bool
        """
        return _pyAgrum.DiGraph_existsArc(self, *args)

    def eraseParents(self, *args) -> "void" :
        """eraseParents(DiGraph self, gum::NodeId const id)"""
        return _pyAgrum.DiGraph_eraseParents(self, *args)

    def eraseChildren(self, *args) -> "void" :
        """eraseChildren(DiGraph self, gum::NodeId const id)"""
        return _pyAgrum.DiGraph_eraseChildren(self, *args)

    def sizeArcs(self) -> "gum::Size" :
        """sizeArcs(DiGraph self) -> gum::Size"""
        return _pyAgrum.DiGraph_sizeArcs(self)

    def emptyArcs(self) -> "bool" :
        """emptyArcs(DiGraph self) -> bool"""
        return _pyAgrum.DiGraph_emptyArcs(self)

DiGraph_swigregister = _pyAgrum.DiGraph_swigregister
DiGraph_swigregister(DiGraph)

class DAG(DiGraph):
    """Proxy of C++ gum::DAG class"""
    __swig_setmethods__ = {}
    for _s in [DiGraph]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DAG, name, value)
    __swig_getmethods__ = {}
    for _s in [DiGraph]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DAG, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DAG self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size, bool arcs_resize_policy=True) -> DAG
        __init__(gum::DAG self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size) -> DAG
        __init__(gum::DAG self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True) -> DAG
        __init__(gum::DAG self, gum::Size nodes_size=HashTableConst::default_size) -> DAG
        __init__(gum::DAG self) -> DAG
        __init__(gum::DAG self, DAG g) -> DAG
        """
        this = _pyAgrum.new_DAG(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DAG
    __del__ = lambda self : None;
    def addArc(self, *args) -> "void" :
        """addArc(DAG self, gum::NodeId const tail, gum::NodeId const head)"""
        return _pyAgrum.DAG_addArc(self, *args)

DAG_swigregister = _pyAgrum.DAG_swigregister
DAG_swigregister(DAG)

class UndiGraph(_object):
    """Proxy of C++ gum::UndiGraph class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UndiGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UndiGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::UndiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size edges_size=HashTableConst::default_size, bool edges_resize_policy=True) -> UndiGraph
        __init__(gum::UndiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size edges_size=HashTableConst::default_size) -> UndiGraph
        __init__(gum::UndiGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True) -> UndiGraph
        __init__(gum::UndiGraph self, gum::Size nodes_size=HashTableConst::default_size) -> UndiGraph
        __init__(gum::UndiGraph self) -> UndiGraph
        __init__(gum::UndiGraph self, UndiGraph g) -> UndiGraph
        """
        this = _pyAgrum.new_UndiGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_UndiGraph
    __del__ = lambda self : None;
    def __eq__(self, *args) -> "bool" :
        """__eq__(UndiGraph self, UndiGraph g) -> bool"""
        return _pyAgrum.UndiGraph___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(UndiGraph self, UndiGraph g) -> bool"""
        return _pyAgrum.UndiGraph___ne__(self, *args)

    def addEdge(self, *args) -> "void" :
        """addEdge(UndiGraph self, gum::NodeId const first, gum::NodeId const second)"""
        return _pyAgrum.UndiGraph_addEdge(self, *args)

    def eraseNode(self, *args) -> "void" :
        """eraseNode(UndiGraph self, gum::NodeId const id)"""
        return _pyAgrum.UndiGraph_eraseNode(self, *args)

    def clear(self) -> "void" :
        """clear(UndiGraph self)"""
        return _pyAgrum.UndiGraph_clear(self)

    def __str__(self) -> "std::string const" :
        """__str__(UndiGraph self) -> std::string const"""
        return _pyAgrum.UndiGraph___str__(self)

    def toDot(self) -> "std::string const" :
        """toDot(UndiGraph self) -> std::string const"""
        return _pyAgrum.UndiGraph_toDot(self)

    def hasUndirectedCycle(self) -> "bool" :
        """hasUndirectedCycle(UndiGraph self) -> bool"""
        return _pyAgrum.UndiGraph_hasUndirectedCycle(self)

    def partialUndiGraph(self, *args) -> "gum::UndiGraph" :
        """partialUndiGraph(UndiGraph self, gum::NodeSet nodesSet) -> UndiGraph"""
        return _pyAgrum.UndiGraph_partialUndiGraph(self, *args)

    def ids(self) -> "PyObject *" :
        """ids(UndiGraph self) -> PyObject *"""
        return _pyAgrum.UndiGraph_ids(self)

    def edges(self) -> "PyObject *" :
        """edges(UndiGraph self) -> PyObject *"""
        return _pyAgrum.UndiGraph_edges(self)

    def neighbours(self, *args) -> "PyObject *" :
        """neighbours(UndiGraph self, gum::NodeId id) -> PyObject *"""
        return _pyAgrum.UndiGraph_neighbours(self, *args)

    def addNode(self, *args) -> "void" :
        """
        addNode(UndiGraph self) -> gum::NodeId
        addNode(UndiGraph self, gum::NodeId const id)
        """
        return _pyAgrum.UndiGraph_addNode(self, *args)

    def existsNode(self, *args) -> "bool" :
        """existsNode(UndiGraph self, gum::NodeId const id) -> bool"""
        return _pyAgrum.UndiGraph_existsNode(self, *args)

    def size(self) -> "gum::Size" :
        """size(UndiGraph self) -> gum::Size"""
        return _pyAgrum.UndiGraph_size(self)

    def empty(self) -> "bool" :
        """empty(UndiGraph self) -> bool"""
        return _pyAgrum.UndiGraph_empty(self)

    def eraseEdge(self, *args) -> "void" :
        """eraseEdge(UndiGraph self, Edge edge)"""
        return _pyAgrum.UndiGraph_eraseEdge(self, *args)

    def existsEdge(self, *args) -> "bool" :
        """
        existsEdge(UndiGraph self, Edge edge) -> bool
        existsEdge(UndiGraph self, gum::NodeId const n1, gum::NodeId const n2) -> bool
        """
        return _pyAgrum.UndiGraph_existsEdge(self, *args)

    def sizeEdges(self) -> "gum::Size" :
        """sizeEdges(UndiGraph self) -> gum::Size"""
        return _pyAgrum.UndiGraph_sizeEdges(self)

    def emptyEdges(self) -> "bool" :
        """emptyEdges(UndiGraph self) -> bool"""
        return _pyAgrum.UndiGraph_emptyEdges(self)

    def eraseNeighbours(self, *args) -> "void" :
        """eraseNeighbours(UndiGraph self, gum::NodeId const id)"""
        return _pyAgrum.UndiGraph_eraseNeighbours(self, *args)

UndiGraph_swigregister = _pyAgrum.UndiGraph_swigregister
UndiGraph_swigregister(UndiGraph)

class MixedGraph(UndiGraph,DiGraph):
    """Proxy of C++ gum::MixedGraph class"""
    __swig_setmethods__ = {}
    for _s in [UndiGraph,DiGraph]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MixedGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [UndiGraph,DiGraph]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MixedGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::MixedGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size, bool arcs_resize_policy=True, 
            gum::Size edges_size=HashTableConst::default_size, bool edges_resize_policy=True) -> MixedGraph
        __init__(gum::MixedGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size, bool arcs_resize_policy=True, 
            gum::Size edges_size=HashTableConst::default_size) -> MixedGraph
        __init__(gum::MixedGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size, bool arcs_resize_policy=True) -> MixedGraph
        __init__(gum::MixedGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size arcs_size=HashTableConst::default_size) -> MixedGraph
        __init__(gum::MixedGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True) -> MixedGraph
        __init__(gum::MixedGraph self, gum::Size nodes_size=HashTableConst::default_size) -> MixedGraph
        __init__(gum::MixedGraph self) -> MixedGraph
        __init__(gum::MixedGraph self, MixedGraph g) -> MixedGraph
        """
        this = _pyAgrum.new_MixedGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_MixedGraph
    __del__ = lambda self : None;
    def __eq__(self, *args) -> "bool" :
        """__eq__(MixedGraph self, MixedGraph g) -> bool"""
        return _pyAgrum.MixedGraph___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(MixedGraph self, MixedGraph g) -> bool"""
        return _pyAgrum.MixedGraph___ne__(self, *args)

    def eraseNode(self, *args) -> "void" :
        """eraseNode(MixedGraph self, gum::NodeId const id)"""
        return _pyAgrum.MixedGraph_eraseNode(self, *args)

    def clear(self) -> "void" :
        """clear(MixedGraph self)"""
        return _pyAgrum.MixedGraph_clear(self)

    def mixedOrientedPath(self, *args) -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > > const" :
        """mixedOrientedPath(MixedGraph self, gum::NodeId const node1, gum::NodeId const node2) -> std::vector< gum::NodeId,std::allocator< gum::NodeId > > const"""
        return _pyAgrum.MixedGraph_mixedOrientedPath(self, *args)

    def mixedUnorientedPath(self, *args) -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > > const" :
        """mixedUnorientedPath(MixedGraph self, gum::NodeId const node1, gum::NodeId const node2) -> std::vector< gum::NodeId,std::allocator< gum::NodeId > > const"""
        return _pyAgrum.MixedGraph_mixedUnorientedPath(self, *args)

    def __str__(self) -> "std::string const" :
        """__str__(MixedGraph self) -> std::string const"""
        return _pyAgrum.MixedGraph___str__(self)

    def addNode(self, *args) -> "void" :
        """
        addNode(MixedGraph self) -> gum::NodeId
        addNode(MixedGraph self, gum::NodeId const id)
        """
        return _pyAgrum.MixedGraph_addNode(self, *args)

    def existsNode(self, *args) -> "bool" :
        """existsNode(MixedGraph self, gum::NodeId const id) -> bool"""
        return _pyAgrum.MixedGraph_existsNode(self, *args)

    def size(self) -> "gum::Size" :
        """size(MixedGraph self) -> gum::Size"""
        return _pyAgrum.MixedGraph_size(self)

    def empty(self) -> "bool" :
        """empty(MixedGraph self) -> bool"""
        return _pyAgrum.MixedGraph_empty(self)

    def eraseEdge(self, *args) -> "void" :
        """eraseEdge(MixedGraph self, Edge edge)"""
        return _pyAgrum.MixedGraph_eraseEdge(self, *args)

    def existsEdge(self, *args) -> "bool" :
        """
        existsEdge(MixedGraph self, Edge edge) -> bool
        existsEdge(MixedGraph self, gum::NodeId const n1, gum::NodeId const n2) -> bool
        """
        return _pyAgrum.MixedGraph_existsEdge(self, *args)

    def sizeEdges(self) -> "gum::Size" :
        """sizeEdges(MixedGraph self) -> gum::Size"""
        return _pyAgrum.MixedGraph_sizeEdges(self)

    def emptyEdges(self) -> "bool" :
        """emptyEdges(MixedGraph self) -> bool"""
        return _pyAgrum.MixedGraph_emptyEdges(self)

    def eraseNeighbours(self, *args) -> "void" :
        """eraseNeighbours(MixedGraph self, gum::NodeId const id)"""
        return _pyAgrum.MixedGraph_eraseNeighbours(self, *args)

    def eraseArc(self, *args) -> "void" :
        """eraseArc(MixedGraph self, Arc arc)"""
        return _pyAgrum.MixedGraph_eraseArc(self, *args)

    def existsArc(self, *args) -> "bool" :
        """
        existsArc(MixedGraph self, Arc arc) -> bool
        existsArc(MixedGraph self, gum::NodeId const tail, gum::NodeId const head) -> bool
        """
        return _pyAgrum.MixedGraph_existsArc(self, *args)

    def eraseParents(self, *args) -> "void" :
        """
        eraseParents(MixedGraph self)
        eraseParents(MixedGraph self, gum::NodeId const id)
        """
        return _pyAgrum.MixedGraph_eraseParents(self, *args)

    def eraseChildren(self, *args) -> "void" :
        """
        eraseChildren(MixedGraph self)
        eraseChildren(MixedGraph self, gum::NodeId const id)
        """
        return _pyAgrum.MixedGraph_eraseChildren(self, *args)

    def sizeArcs(self) -> "gum::Size" :
        """sizeArcs(MixedGraph self) -> gum::Size"""
        return _pyAgrum.MixedGraph_sizeArcs(self)

    def emptyArcs(self) -> "bool" :
        """emptyArcs(MixedGraph self) -> bool"""
        return _pyAgrum.MixedGraph_emptyArcs(self)

MixedGraph_swigregister = _pyAgrum.MixedGraph_swigregister
MixedGraph_swigregister(MixedGraph)

class CliqueGraph(UndiGraph):
    """Proxy of C++ gum::CliqueGraph class"""
    __swig_setmethods__ = {}
    for _s in [UndiGraph]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CliqueGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [UndiGraph]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CliqueGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::CliqueGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size edges_size=HashTableConst::default_size, bool edges_resize_policy=True) -> CliqueGraph
        __init__(gum::CliqueGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True, 
            gum::Size edges_size=HashTableConst::default_size) -> CliqueGraph
        __init__(gum::CliqueGraph self, gum::Size nodes_size=HashTableConst::default_size, bool nodes_resize_policy=True) -> CliqueGraph
        __init__(gum::CliqueGraph self, gum::Size nodes_size=HashTableConst::default_size) -> CliqueGraph
        __init__(gum::CliqueGraph self) -> CliqueGraph
        __init__(gum::CliqueGraph self, CliqueGraph _from) -> CliqueGraph
        """
        this = _pyAgrum.new_CliqueGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CliqueGraph
    __del__ = lambda self : None;
    def addEdge(self, *args) -> "void" :
        """addEdge(CliqueGraph self, gum::NodeId const first, gum::NodeId const second)"""
        return _pyAgrum.CliqueGraph_addEdge(self, *args)

    def eraseEdge(self, *args) -> "void" :
        """eraseEdge(CliqueGraph self, Edge edge)"""
        return _pyAgrum.CliqueGraph_eraseEdge(self, *args)

    def clearEdges(self) -> "void" :
        """clearEdges(CliqueGraph self)"""
        return _pyAgrum.CliqueGraph_clearEdges(self)

    def eraseNode(self, *args) -> "void" :
        """eraseNode(CliqueGraph self, gum::NodeId const node)"""
        return _pyAgrum.CliqueGraph_eraseNode(self, *args)

    def clear(self) -> "void" :
        """clear(CliqueGraph self)"""
        return _pyAgrum.CliqueGraph_clear(self)

    def container(self, *args) -> "gum::NodeId" :
        """container(CliqueGraph self, gum::NodeId const idNode) -> gum::NodeId"""
        return _pyAgrum.CliqueGraph_container(self, *args)

    def setClique(self, *args) -> "void" :
        """setClique(CliqueGraph self, gum::NodeId const idClique, gum::NodeSet const & new_clique)"""
        return _pyAgrum.CliqueGraph_setClique(self, *args)

    def addToClique(self, *args) -> "void" :
        """addToClique(CliqueGraph self, gum::NodeId const clique_id, gum::NodeId const node_id)"""
        return _pyAgrum.CliqueGraph_addToClique(self, *args)

    def eraseFromClique(self, *args) -> "void" :
        """eraseFromClique(CliqueGraph self, gum::NodeId const clique_id, gum::NodeId const node_id)"""
        return _pyAgrum.CliqueGraph_eraseFromClique(self, *args)

    def separator(self, *args) -> "gum::NodeSet const &" :
        """
        separator(CliqueGraph self, Edge edge) -> gum::NodeSet const
        separator(CliqueGraph self, gum::NodeId const clique1, gum::NodeId const clique) -> gum::NodeSet const &
        """
        return _pyAgrum.CliqueGraph_separator(self, *args)

    def containerPath(self, *args) -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > >" :
        """containerPath(CliqueGraph self, gum::NodeId const node1, gum::NodeId const node2) -> std::vector< gum::NodeId,std::allocator< gum::NodeId > >"""
        return _pyAgrum.CliqueGraph_containerPath(self, *args)

    def hasRunningIntersection(self) -> "bool" :
        """hasRunningIntersection(CliqueGraph self) -> bool"""
        return _pyAgrum.CliqueGraph_hasRunningIntersection(self)

    def isJoinTree(self) -> "bool" :
        """isJoinTree(CliqueGraph self) -> bool"""
        return _pyAgrum.CliqueGraph_isJoinTree(self)

    def __str__(self) -> "std::string const" :
        """__str__(CliqueGraph self) -> std::string const"""
        return _pyAgrum.CliqueGraph___str__(self)

    def toDot(self) -> "std::string const" :
        """toDot(CliqueGraph self) -> std::string const"""
        return _pyAgrum.CliqueGraph_toDot(self)

    def __ne__(self, *args) -> "bool" :
        """__ne__(CliqueGraph self, CliqueGraph _from) -> bool"""
        return _pyAgrum.CliqueGraph___ne__(self, *args)

    def __eq__(self, *args) -> "bool" :
        """__eq__(CliqueGraph self, CliqueGraph _from) -> bool"""
        return _pyAgrum.CliqueGraph___eq__(self, *args)

    def clique(self, *args) -> "PyObject *" :
        """clique(CliqueGraph self, gum::NodeId const clique) -> PyObject *"""
        return _pyAgrum.CliqueGraph_clique(self, *args)

CliqueGraph_swigregister = _pyAgrum.CliqueGraph_swigregister
CliqueGraph_swigregister(CliqueGraph)

class Instantiation(_object):
    """Proxy of C++ gum::Instantiation class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Instantiation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Instantiation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Instantiation self) -> Instantiation
        __init__(gum::Instantiation self, Instantiation aI, bool const notifyMaster=True) -> Instantiation
        __init__(gum::Instantiation self, Instantiation aI) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        __init__(gum::Instantiation self, MultiDimAdressable aMD) -> Instantiation
        """
        this = _pyAgrum.new_Instantiation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_Instantiation
    __del__ = lambda self : None;
    def nbrDim(self) -> "gum::Idx" :
        """nbrDim(Instantiation self) -> gum::Idx"""
        return _pyAgrum.Instantiation_nbrDim(self)

    def add(self, *args) -> "void" :
        """add(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_add(self, *args)

    def erase(self, *args) -> "void" :
        """erase(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_erase(self, *args)

    def clear(self) -> "void" :
        """clear(Instantiation self)"""
        return _pyAgrum.Instantiation_clear(self)

    def domainSize(self) -> "gum::Size" :
        """domainSize(Instantiation self) -> gum::Size"""
        return _pyAgrum.Instantiation_domainSize(self)

    def pos(self, *args) -> "gum::Idx" :
        """pos(Instantiation self, DiscreteVariable v) -> gum::Idx"""
        return _pyAgrum.Instantiation_pos(self, *args)

    def val(self, *args) -> "gum::Idx" :
        """
        val(Instantiation self, gum::Idx i) -> gum::Idx
        val(Instantiation self, DiscreteVariable var) -> gum::Idx
        """
        return _pyAgrum.Instantiation_val(self, *args)

    def valFromPtr(self, *args) -> "gum::Idx" :
        """valFromPtr(Instantiation self, DiscreteVariable pvar) -> gum::Idx"""
        return _pyAgrum.Instantiation_valFromPtr(self, *args)

    def variable(self, *args) -> "gum::DiscreteVariable const &" :
        """variable(Instantiation self, gum::Idx i) -> DiscreteVariable"""
        return _pyAgrum.Instantiation_variable(self, *args)

    def chgVal(self, *args) -> "gum::Instantiation &" :
        """
        chgVal(Instantiation self, DiscreteVariable v, gum::Idx newval) -> Instantiation
        chgVal(Instantiation self, DiscreteVariable v, gum::Idx newval) -> Instantiation
        chgVal(Instantiation self, gum::Idx varPos, gum::Idx newval) -> Instantiation
        """
        return _pyAgrum.Instantiation_chgVal(self, *args)

    def setVals(self, *args) -> "gum::Instantiation &" :
        """setVals(Instantiation self, Instantiation i) -> Instantiation"""
        return _pyAgrum.Instantiation_setVals(self, *args)

    def contains(self, *args) -> "bool" :
        """
        contains(Instantiation self, DiscreteVariable v) -> bool
        contains(Instantiation self, DiscreteVariable v) -> bool
        """
        return _pyAgrum.Instantiation_contains(self, *args)

    def variablesSequence(self) -> "gum::Sequence< gum::DiscreteVariable const * > const &" :
        """variablesSequence(Instantiation self) -> gum::Sequence< gum::DiscreteVariable const * > const &"""
        return _pyAgrum.Instantiation_variablesSequence(self)

    def empty(self) -> "bool" :
        """empty(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_empty(self)

    def inOverflow(self) -> "bool" :
        """inOverflow(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_inOverflow(self)

    def unsetOverflow(self) -> "void" :
        """unsetOverflow(Instantiation self)"""
        return _pyAgrum.Instantiation_unsetOverflow(self)

    def unsetEnd(self) -> "void" :
        """unsetEnd(Instantiation self)"""
        return _pyAgrum.Instantiation_unsetEnd(self)

    def end(self) -> "bool" :
        """end(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_end(self)

    def rend(self) -> "bool" :
        """rend(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_rend(self)

    def inc(self) -> "void" :
        """inc(Instantiation self)"""
        return _pyAgrum.Instantiation_inc(self)

    def dec(self) -> "void" :
        """dec(Instantiation self)"""
        return _pyAgrum.Instantiation_dec(self)

    def incIn(self, *args) -> "void" :
        """incIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_incIn(self, *args)

    def decIn(self, *args) -> "void" :
        """decIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_decIn(self, *args)

    def incOut(self, *args) -> "void" :
        """incOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_incOut(self, *args)

    def decOut(self, *args) -> "void" :
        """decOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_decOut(self, *args)

    def incNotVar(self, *args) -> "void" :
        """incNotVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_incNotVar(self, *args)

    def decNotVar(self, *args) -> "void" :
        """decNotVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_decNotVar(self, *args)

    def incVar(self, *args) -> "void" :
        """incVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_incVar(self, *args)

    def decVar(self, *args) -> "void" :
        """decVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_decVar(self, *args)

    def setFirst(self) -> "void" :
        """setFirst(Instantiation self)"""
        return _pyAgrum.Instantiation_setFirst(self)

    def setLast(self) -> "void" :
        """setLast(Instantiation self)"""
        return _pyAgrum.Instantiation_setLast(self)

    def setFirstIn(self, *args) -> "void" :
        """setFirstIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setFirstIn(self, *args)

    def setLastIn(self, *args) -> "void" :
        """setLastIn(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setLastIn(self, *args)

    def setFirstOut(self, *args) -> "void" :
        """setFirstOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setFirstOut(self, *args)

    def setLastOut(self, *args) -> "void" :
        """setLastOut(Instantiation self, Instantiation i)"""
        return _pyAgrum.Instantiation_setLastOut(self, *args)

    def setFirstNotVar(self, *args) -> "void" :
        """setFirstNotVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_setFirstNotVar(self, *args)

    def setLastNotVar(self, *args) -> "void" :
        """setLastNotVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_setLastNotVar(self, *args)

    def setFirstVar(self, *args) -> "void" :
        """setFirstVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_setFirstVar(self, *args)

    def setLastVar(self, *args) -> "void" :
        """setLastVar(Instantiation self, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_setLastVar(self, *args)

    def actAsSlave(self, *args) -> "bool" :
        """actAsSlave(Instantiation self, MultiDimAdressable aMD) -> bool"""
        return _pyAgrum.Instantiation_actAsSlave(self, *args)

    def forgetMaster(self) -> "bool" :
        """forgetMaster(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_forgetMaster(self)

    def isSlave(self) -> "bool" :
        """isSlave(Instantiation self) -> bool"""
        return _pyAgrum.Instantiation_isSlave(self)

    def isMaster(self, *args) -> "bool" :
        """
        isMaster(Instantiation self, MultiDimAdressable m) -> bool
        isMaster(Instantiation self, MultiDimAdressable m) -> bool
        """
        return _pyAgrum.Instantiation_isMaster(self, *args)

    def synchronizeWithMaster(self, *args) -> "void" :
        """synchronizeWithMaster(Instantiation self, MultiDimAdressable m)"""
        return _pyAgrum.Instantiation_synchronizeWithMaster(self, *args)

    def addWithMaster(self, *args) -> "void" :
        """addWithMaster(Instantiation self, MultiDimAdressable m, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_addWithMaster(self, *args)

    def eraseWithMaster(self, *args) -> "void" :
        """eraseWithMaster(Instantiation self, MultiDimAdressable m, DiscreteVariable v)"""
        return _pyAgrum.Instantiation_eraseWithMaster(self, *args)

    def __iadd__(self, *args) -> "gum::Instantiation &" :
        """__iadd__(Instantiation self, gum::Id depl) -> Instantiation"""
        return _pyAgrum.Instantiation___iadd__(self, *args)

    def __isub__(self, *args) -> "gum::Instantiation &" :
        """__isub__(Instantiation self, gum::Id depl) -> Instantiation"""
        return _pyAgrum.Instantiation___isub__(self, *args)

    def hamming(self) -> "gum::Idx" :
        """hamming(Instantiation self) -> gum::Idx"""
        return _pyAgrum.Instantiation_hamming(self)

    def __str__(self) -> "std::string" :
        """__str__(Instantiation self) -> std::string"""
        return _pyAgrum.Instantiation___str__(self)

    def reorder(self, *args) -> "void" :
        """
        reorder(Instantiation self, gum::Sequence< gum::DiscreteVariable const * > const & v)
        reorder(Instantiation self, Instantiation i)
        """
        return _pyAgrum.Instantiation_reorder(self, *args)

Instantiation_swigregister = _pyAgrum.Instantiation_swigregister
Instantiation_swigregister(Instantiation)

GUM_DEFAULT_ITERATOR_NUMBER = _pyAgrum.GUM_DEFAULT_ITERATOR_NUMBER
class DAGmodel(_object):
    """Proxy of C++ gum::DAGmodel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DAGmodel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DAGmodel, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_DAGmodel
    __del__ = lambda self : None;
    def property(self, *args) -> "std::string const &" :
        """property(DAGmodel self, std::string const & name) -> std::string const &"""
        return _pyAgrum.DAGmodel_property(self, *args)

    def propertyWithDefault(self, *args) -> "std::string const &" :
        """propertyWithDefault(DAGmodel self, std::string const & name, std::string const & byDefault) -> std::string const &"""
        return _pyAgrum.DAGmodel_propertyWithDefault(self, *args)

    def setProperty(self, *args) -> "void" :
        """setProperty(DAGmodel self, std::string const & name, std::string const & value)"""
        return _pyAgrum.DAGmodel_setProperty(self, *args)

    def dag(self) -> "gum::DAG const &" :
        """dag(DAGmodel self) -> DAG"""
        return _pyAgrum.DAGmodel_dag(self)

    def variableNodeMap(self) -> "gum::VariableNodeMap const &" :
        """variableNodeMap(DAGmodel self) -> VariableNodeMap"""
        return _pyAgrum.DAGmodel_variableNodeMap(self)

    def size(self) -> "gum::Size" :
        """size(DAGmodel self) -> gum::Size"""
        return _pyAgrum.DAGmodel_size(self)

    def sizeArcs(self) -> "gum::Size" :
        """sizeArcs(DAGmodel self) -> gum::Size"""
        return _pyAgrum.DAGmodel_sizeArcs(self)

    def empty(self) -> "bool" :
        """empty(DAGmodel self) -> bool"""
        return _pyAgrum.DAGmodel_empty(self)

    def variable(self, *args) -> "gum::DiscreteVariable const &" :
        """variable(DAGmodel self, gum::NodeId id) -> DiscreteVariable"""
        return _pyAgrum.DAGmodel_variable(self, *args)

    def nodeId(self, *args) -> "gum::NodeId" :
        """nodeId(DAGmodel self, DiscreteVariable var) -> gum::NodeId"""
        return _pyAgrum.DAGmodel_nodeId(self, *args)

    def idFromName(self, *args) -> "gum::NodeId" :
        """idFromName(DAGmodel self, std::string const & name) -> gum::NodeId"""
        return _pyAgrum.DAGmodel_idFromName(self, *args)

    def variableFromName(self, *args) -> "gum::DiscreteVariable const &" :
        """variableFromName(DAGmodel self, std::string const & name) -> DiscreteVariable"""
        return _pyAgrum.DAGmodel_variableFromName(self, *args)

    def completeInstantiation(self, *args) -> "void" :
        """completeInstantiation(DAGmodel self, Instantiation I)"""
        return _pyAgrum.DAGmodel_completeInstantiation(self, *args)

    def arcs(self) -> "gum::ArcSet const &" :
        """arcs(DAGmodel self) -> gum::ArcSet const &"""
        return _pyAgrum.DAGmodel_arcs(self)

    def moralGraph(self, clear : 'bool'=True) -> "gum::UndiGraph const &" :
        """
        moralGraph(DAGmodel self, bool clear=True) -> UndiGraph
        moralGraph(DAGmodel self) -> UndiGraph
        """
        return _pyAgrum.DAGmodel_moralGraph(self, clear)

    def topologicalOrder(self, clear : 'bool'=True) -> "gum::Sequence< gum::NodeId > const &" :
        """
        topologicalOrder(DAGmodel self, bool clear=True) -> gum::Sequence< gum::NodeId > const
        topologicalOrder(DAGmodel self) -> gum::Sequence< gum::NodeId > const &
        """
        return _pyAgrum.DAGmodel_topologicalOrder(self, clear)

    def log10DomainSize(self) -> "double" :
        """log10DomainSize(DAGmodel self) -> double"""
        return _pyAgrum.DAGmodel_log10DomainSize(self)

DAGmodel_swigregister = _pyAgrum.DAGmodel_swigregister
DAGmodel_swigregister(DAGmodel)
cvar = _pyAgrum.cvar
__list_end_safe = cvar.__list_end_safe
__list_end = cvar.__list_end

class BNLearner(_object):
    """Proxy of C++ gum::learning::BNLearner class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BNLearner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BNLearner, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::learning::BNLearner self, std::string const & filename) -> BNLearner
        __init__(gum::learning::BNLearner self, BNLearner arg2) -> BNLearner
        __init__(gum::learning::BNLearner self, BNLearner arg2) -> BNLearner
        """
        this = _pyAgrum.new_BNLearner(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_BNLearner
    __del__ = lambda self : None;
    def learnDAG(self) -> "gum::DAG" :
        """learnDAG(BNLearner self) -> DAG"""
        return _pyAgrum.BNLearner_learnDAG(self)

    def setInitialDAG(self, *args) -> "void" :
        """setInitialDAG(BNLearner self, DAG arg2)"""
        return _pyAgrum.BNLearner_setInitialDAG(self, *args)

    def names(self) -> "std::vector< std::string,std::allocator< std::string > > const &" :
        """names(BNLearner self) -> Vector_string"""
        return _pyAgrum.BNLearner_names(self)

    def idFromName(self, *args) -> "gum::NodeId" :
        """idFromName(BNLearner self, std::string const & var_name) -> gum::NodeId"""
        return _pyAgrum.BNLearner_idFromName(self, *args)

    def nameFromId(self, *args) -> "std::string const &" :
        """nameFromId(BNLearner self, gum::NodeId id) -> std::string const &"""
        return _pyAgrum.BNLearner_nameFromId(self, *args)

    def useScoreAIC(self) -> "void" :
        """useScoreAIC(BNLearner self)"""
        return _pyAgrum.BNLearner_useScoreAIC(self)

    def useScoreBD(self) -> "void" :
        """useScoreBD(BNLearner self)"""
        return _pyAgrum.BNLearner_useScoreBD(self)

    def useScoreBDeu(self) -> "void" :
        """useScoreBDeu(BNLearner self)"""
        return _pyAgrum.BNLearner_useScoreBDeu(self)

    def useScoreBIC(self) -> "void" :
        """useScoreBIC(BNLearner self)"""
        return _pyAgrum.BNLearner_useScoreBIC(self)

    def useScoreK2(self) -> "void" :
        """useScoreK2(BNLearner self)"""
        return _pyAgrum.BNLearner_useScoreK2(self)

    def useScoreLog2Likelihood(self) -> "void" :
        """useScoreLog2Likelihood(BNLearner self)"""
        return _pyAgrum.BNLearner_useScoreLog2Likelihood(self)

    def setAprioriWeight(self, *args) -> "void" :
        """setAprioriWeight(BNLearner self, float weight)"""
        return _pyAgrum.BNLearner_setAprioriWeight(self, *args)

    def useNoApriori(self) -> "void" :
        """useNoApriori(BNLearner self)"""
        return _pyAgrum.BNLearner_useNoApriori(self)

    def useAprioriSmoothing(self, *args) -> "void" :
        """
        useAprioriSmoothing(BNLearner self, float weight=-1)
        useAprioriSmoothing(BNLearner self)
        """
        return _pyAgrum.BNLearner_useAprioriSmoothing(self, *args)

    def useAprioriDirichlet(self, *args) -> "void" :
        """useAprioriDirichlet(BNLearner self, std::string const & filename)"""
        return _pyAgrum.BNLearner_useAprioriDirichlet(self, *args)

    def useGreedyHillClimbing(self) -> "void" :
        """useGreedyHillClimbing(BNLearner self)"""
        return _pyAgrum.BNLearner_useGreedyHillClimbing(self)

    def useLocalSearchWithTabuList(self, tabu_size : 'unsigned int'=100, nb_decrease : 'unsigned int'=2) -> "void" :
        """
        useLocalSearchWithTabuList(BNLearner self, unsigned int tabu_size=100, unsigned int nb_decrease=2)
        useLocalSearchWithTabuList(BNLearner self, unsigned int tabu_size=100)
        useLocalSearchWithTabuList(BNLearner self)
        """
        return _pyAgrum.BNLearner_useLocalSearchWithTabuList(self, tabu_size, nb_decrease)

    def setMaxIndegree(self, *args) -> "void" :
        """setMaxIndegree(BNLearner self, unsigned int max_indegree)"""
        return _pyAgrum.BNLearner_setMaxIndegree(self, *args)

    def addForbiddenArc(self, *args) -> "void" :
        """
        addForbiddenArc(BNLearner self, gum::NodeId const tail, gum::NodeId const head)
        addForbiddenArc(BNLearner self, std::string const & tail, std::string const & head)
        """
        return _pyAgrum.BNLearner_addForbiddenArc(self, *args)

    def eraseForbiddenArc(self, *args) -> "void" :
        """
        eraseForbiddenArc(BNLearner self, gum::NodeId const tail, gum::NodeId const head)
        eraseForbiddenArc(BNLearner self, std::string const & tail, std::string const & head)
        """
        return _pyAgrum.BNLearner_eraseForbiddenArc(self, *args)

    def addMandatoryArc(self, *args) -> "void" :
        """
        addMandatoryArc(BNLearner self, gum::NodeId const tail, gum::NodeId const head)
        addMandatoryArc(BNLearner self, std::string const & tail, std::string const & head)
        """
        return _pyAgrum.BNLearner_addMandatoryArc(self, *args)

    def eraseMandatoryArc(self, *args) -> "void" :
        """
        eraseMandatoryArc(BNLearner self, gum::NodeId const tail, gum::NodeId const head)
        eraseMandatoryArc(BNLearner self, std::string const & tail, std::string const & head)
        """
        return _pyAgrum.BNLearner_eraseMandatoryArc(self, *args)

    def setCurrentApproximationScheme(self, *args) -> "void" :
        """setCurrentApproximationScheme(BNLearner self, ApproximationScheme approximationScheme)"""
        return _pyAgrum.BNLearner_setCurrentApproximationScheme(self, *args)

    def distributeProgress(self, *args) -> "void" :
        """distributeProgress(BNLearner self, ApproximationScheme approximationScheme, gum::Size pourcent, double error, double time)"""
        return _pyAgrum.BNLearner_distributeProgress(self, *args)

    def distributeStop(self, *args) -> "void" :
        """distributeStop(BNLearner self, ApproximationScheme approximationScheme, std::string message)"""
        return _pyAgrum.BNLearner_distributeStop(self, *args)

    def setEpsilon(self, *args) -> "void" :
        """setEpsilon(BNLearner self, double eps)"""
        return _pyAgrum.BNLearner_setEpsilon(self, *args)

    def epsilon(self) -> "double" :
        """epsilon(BNLearner self) -> double"""
        return _pyAgrum.BNLearner_epsilon(self)

    def disableEpsilon(self) -> "void" :
        """disableEpsilon(BNLearner self)"""
        return _pyAgrum.BNLearner_disableEpsilon(self)

    def enableEpsilon(self) -> "void" :
        """enableEpsilon(BNLearner self)"""
        return _pyAgrum.BNLearner_enableEpsilon(self)

    def isEnabledEpsilon(self) -> "bool" :
        """isEnabledEpsilon(BNLearner self) -> bool"""
        return _pyAgrum.BNLearner_isEnabledEpsilon(self)

    def setMinEpsilonRate(self, *args) -> "void" :
        """setMinEpsilonRate(BNLearner self, double rate)"""
        return _pyAgrum.BNLearner_setMinEpsilonRate(self, *args)

    def minEpsilonRate(self) -> "double" :
        """minEpsilonRate(BNLearner self) -> double"""
        return _pyAgrum.BNLearner_minEpsilonRate(self)

    def disableMinEpsilonRate(self) -> "void" :
        """disableMinEpsilonRate(BNLearner self)"""
        return _pyAgrum.BNLearner_disableMinEpsilonRate(self)

    def enableMinEpsilonRate(self) -> "void" :
        """enableMinEpsilonRate(BNLearner self)"""
        return _pyAgrum.BNLearner_enableMinEpsilonRate(self)

    def isEnabledMinEpsilonRate(self) -> "bool" :
        """isEnabledMinEpsilonRate(BNLearner self) -> bool"""
        return _pyAgrum.BNLearner_isEnabledMinEpsilonRate(self)

    def setMaxIter(self, *args) -> "void" :
        """setMaxIter(BNLearner self, gum::Size max)"""
        return _pyAgrum.BNLearner_setMaxIter(self, *args)

    def maxIter(self) -> "gum::Size" :
        """maxIter(BNLearner self) -> gum::Size"""
        return _pyAgrum.BNLearner_maxIter(self)

    def disableMaxIter(self) -> "void" :
        """disableMaxIter(BNLearner self)"""
        return _pyAgrum.BNLearner_disableMaxIter(self)

    def enableMaxIter(self) -> "void" :
        """enableMaxIter(BNLearner self)"""
        return _pyAgrum.BNLearner_enableMaxIter(self)

    def isEnabledMaxIter(self) -> "bool" :
        """isEnabledMaxIter(BNLearner self) -> bool"""
        return _pyAgrum.BNLearner_isEnabledMaxIter(self)

    def setMaxTime(self, *args) -> "void" :
        """setMaxTime(BNLearner self, double timeout)"""
        return _pyAgrum.BNLearner_setMaxTime(self, *args)

    def maxTime(self) -> "double" :
        """maxTime(BNLearner self) -> double"""
        return _pyAgrum.BNLearner_maxTime(self)

    def currentTime(self) -> "double" :
        """currentTime(BNLearner self) -> double"""
        return _pyAgrum.BNLearner_currentTime(self)

    def disableMaxTime(self) -> "void" :
        """disableMaxTime(BNLearner self)"""
        return _pyAgrum.BNLearner_disableMaxTime(self)

    def enableMaxTime(self) -> "void" :
        """enableMaxTime(BNLearner self)"""
        return _pyAgrum.BNLearner_enableMaxTime(self)

    def isEnabledMaxTime(self) -> "bool" :
        """isEnabledMaxTime(BNLearner self) -> bool"""
        return _pyAgrum.BNLearner_isEnabledMaxTime(self)

    def setPeriodSize(self, *args) -> "void" :
        """setPeriodSize(BNLearner self, gum::Size p)"""
        return _pyAgrum.BNLearner_setPeriodSize(self, *args)

    def periodSize(self) -> "gum::Size" :
        """periodSize(BNLearner self) -> gum::Size"""
        return _pyAgrum.BNLearner_periodSize(self)

    def setBurnIn(self, *args) -> "void" :
        """setBurnIn(BNLearner self, gum::Size b)"""
        return _pyAgrum.BNLearner_setBurnIn(self, *args)

    def burnIn(self) -> "gum::Size" :
        """burnIn(BNLearner self) -> gum::Size"""
        return _pyAgrum.BNLearner_burnIn(self)

    def setVerbosity(self, *args) -> "void" :
        """setVerbosity(BNLearner self, bool v)"""
        return _pyAgrum.BNLearner_setVerbosity(self, *args)

    def verbosity(self) -> "bool" :
        """verbosity(BNLearner self) -> bool"""
        return _pyAgrum.BNLearner_verbosity(self)

    def stateApproximationScheme(self) -> "gum::IApproximationSchemeConfiguration::ApproximationSchemeSTATE" :
        """stateApproximationScheme(BNLearner self) -> gum::IApproximationSchemeConfiguration::ApproximationSchemeSTATE"""
        return _pyAgrum.BNLearner_stateApproximationScheme(self)

    def nbrIterations(self) -> "gum::Size" :
        """nbrIterations(BNLearner self) -> gum::Size"""
        return _pyAgrum.BNLearner_nbrIterations(self)

    def history(self) -> "std::vector< double,std::allocator< double > > const &" :
        """history(BNLearner self) -> Vector_double"""
        return _pyAgrum.BNLearner_history(self)

    def learnBN(self) -> "gum::BayesNet< double >" :
        """learnBN(BNLearner self) -> BayesNet_double"""
        return _pyAgrum.BNLearner_learnBN(self)

    def learnParameters(self, *args) -> "gum::BayesNet< double >" :
        """learnParameters(BNLearner self, DAG dag) -> BayesNet_double"""
        return _pyAgrum.BNLearner_learnParameters(self, *args)

    def setSliceOrder(self, *args) -> "void" :
        """setSliceOrder(BNLearner self, PyObject * l)"""
        return _pyAgrum.BNLearner_setSliceOrder(self, *args)

    def useK2(self, *args) -> "void" :
        """useK2(BNLearner self, PyObject * l)"""
        return _pyAgrum.BNLearner_useK2(self, *args)

    def castAsASC(self, *args) -> "gum::IApproximationSchemeConfiguration const &" :
        """castAsASC(BNLearner self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.BNLearner_castAsASC(self, *args)

    def messageApproximationScheme(self) -> "std::string" :
        """messageApproximationScheme(BNLearner self) -> std::string"""
        return _pyAgrum.BNLearner_messageApproximationScheme(self)

BNLearner_swigregister = _pyAgrum.BNLearner_swigregister
BNLearner_swigregister(BNLearner)


def randomDistribution_double(*args) -> "std::vector< double,std::allocator< double > >" :
  """randomDistribution_double(gum::Size n) -> Vector_double"""
  return _pyAgrum.randomDistribution_double(*args)
class DiscretizedVariable_double(DiscreteVariable):
    """Proxy of C++ gum::DiscretizedVariable<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [DiscreteVariable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscretizedVariable_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DiscreteVariable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscretizedVariable_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::DiscretizedVariable<(double)> self, std::string const & aName, std::string const & aDesc) -> DiscretizedVariable_double
        __init__(gum::DiscretizedVariable<(double)> self, DiscretizedVariable_double aDRV) -> DiscretizedVariable_double
        """
        this = _pyAgrum.new_DiscretizedVariable_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_DiscretizedVariable_double
    __del__ = lambda self : None;
    def clone(self) -> "gum::DiscreteVariable *" :
        """clone(DiscretizedVariable_double self) -> DiscreteVariable"""
        return _pyAgrum.DiscretizedVariable_double_clone(self)

    def varType(self) -> "gum::DiscreteVariable::VarType" :
        """varType(DiscretizedVariable_double self) -> gum::DiscreteVariable::VarType"""
        return _pyAgrum.DiscretizedVariable_double_varType(self)

    def isTick(self, *args) -> "bool" :
        """isTick(DiscretizedVariable_double self, double const & aTick) -> bool"""
        return _pyAgrum.DiscretizedVariable_double_isTick(self, *args)

    def addTick(self,*args):
      _pyAgrum.DiscretizedVariable_double_addTick(self,*args)
      return self


    def eraseTicks(self) -> "void" :
        """eraseTicks(DiscretizedVariable_double self)"""
        return _pyAgrum.DiscretizedVariable_double_eraseTicks(self)

    def label(self, *args) -> "std::string const" :
        """label(DiscretizedVariable_double self, gum::Idx i) -> std::string const"""
        return _pyAgrum.DiscretizedVariable_double_label(self, *args)

    def numerical(self, *args) -> "double" :
        """numerical(DiscretizedVariable_double self, gum::Idx indice) -> double"""
        return _pyAgrum.DiscretizedVariable_double_numerical(self, *args)

    def index(self, *args) -> "gum::Idx" :
        """
        index(DiscretizedVariable_double self, std::string const & label) -> gum::Idx
        index(DiscretizedVariable_double self, double const & aTarget) -> gum::Idx
        """
        return _pyAgrum.DiscretizedVariable_double_index(self, *args)

    def domainSize(self) -> "gum::Size" :
        """domainSize(DiscretizedVariable_double self) -> gum::Size"""
        return _pyAgrum.DiscretizedVariable_double_domainSize(self)

    def tick(self, *args) -> "double const &" :
        """tick(DiscretizedVariable_double self, gum::Idx i) -> double const &"""
        return _pyAgrum.DiscretizedVariable_double_tick(self, *args)

DiscretizedVariable_double_swigregister = _pyAgrum.DiscretizedVariable_double_swigregister
DiscretizedVariable_double_swigregister(DiscretizedVariable_double)

class MultiDimContainer_double(_object):
    """Proxy of C++ gum::MultiDimContainer<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiDimContainer_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiDimContainer_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_MultiDimContainer_double
    __del__ = lambda self : None;
    def set(self, *args) -> "void" :
        """set(MultiDimContainer_double self, Instantiation i, double const & value)"""
        return _pyAgrum.MultiDimContainer_double_set(self, *args)

    def get(self, *args) -> "double" :
        """get(MultiDimContainer_double self, Instantiation i) -> double"""
        return _pyAgrum.MultiDimContainer_double_get(self, *args)

    def fill(self, *args) -> "void" :
        """fill(MultiDimContainer_double self, double const & d)"""
        return _pyAgrum.MultiDimContainer_double_fill(self, *args)

    def fillWith(self, *args) -> "void" :
        """fillWith(MultiDimContainer_double self, Vector_double v)"""
        return _pyAgrum.MultiDimContainer_double_fillWith(self, *args)

    def copyFrom(self, *args) -> "void" :
        """
        copyFrom(MultiDimContainer_double self, MultiDimContainer_double src, Instantiation p_i=(Instantiation *) 0)
        copyFrom(MultiDimContainer_double self, MultiDimContainer_double src)
        """
        return _pyAgrum.MultiDimContainer_double_copyFrom(self, *args)

    def copy(self, *args) -> "void" :
        """copy(MultiDimContainer_double self, MultiDimContainer_double src)"""
        return _pyAgrum.MultiDimContainer_double_copy(self, *args)

    def newFactory(self) -> "gum::MultiDimContainer< double > *" :
        """newFactory(MultiDimContainer_double self) -> MultiDimContainer_double"""
        return _pyAgrum.MultiDimContainer_double_newFactory(self)

    def __str__(self) -> "std::string const" :
        """__str__(MultiDimContainer_double self) -> std::string const"""
        return _pyAgrum.MultiDimContainer_double___str__(self)

    def toString(self, *args) -> "std::string const" :
        """toString(MultiDimContainer_double self, Instantiation i) -> std::string const"""
        return _pyAgrum.MultiDimContainer_double_toString(self, *args)

    def __eq__(self, *args) -> "bool" :
        """__eq__(MultiDimContainer_double self, MultiDimContainer_double p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(MultiDimContainer_double self, MultiDimContainer_double p) -> bool"""
        return _pyAgrum.MultiDimContainer_double___ne__(self, *args)

    def beginMultipleChanges(self) -> "void" :
        """beginMultipleChanges(MultiDimContainer_double self)"""
        return _pyAgrum.MultiDimContainer_double_beginMultipleChanges(self)

    def endMultipleChanges(self, *args) -> "void" :
        """
        endMultipleChanges(MultiDimContainer_double self)
        endMultipleChanges(MultiDimContainer_double self, double const & arg2)
        """
        return _pyAgrum.MultiDimContainer_double_endMultipleChanges(self, *args)

MultiDimContainer_double_swigregister = _pyAgrum.MultiDimContainer_double_swigregister
MultiDimContainer_double_swigregister(MultiDimContainer_double)

class Potential_double(_object):
    """Proxy of C++ gum::Potential<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Potential_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Potential_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::Potential<(double)> self) -> Potential_double
        __init__(gum::Potential<(double)> self, gum::MultiDimImplementation< double > * aContent) -> Potential_double
        __init__(gum::Potential<(double)> self, Potential_double src) -> Potential_double
        __init__(gum::Potential<(double)> self, gum::MultiDimImplementation< double > * aContent, MultiDimContainer_double src) -> Potential_double
        """
        this = _pyAgrum.new_Potential_double(*args)
        try: self.this.append(this)
        except: self.this = this
        self._notSync=True



    __swig_destroy__ = _pyAgrum.delete_Potential_double
    __del__ = lambda self : None;
    def newFactory(self) -> "gum::Potential< double > *" :
        """newFactory(Potential_double self) -> Potential_double"""
        return _pyAgrum.Potential_double_newFactory(self)

    def normalize(self) -> "gum::Potential< double > &" :
        """normalize(Potential_double self) -> Potential_double"""
        return _pyAgrum.Potential_double_normalize(self)

    def marginalize(self, *args) -> "gum::Potential< double > &" :
        """marginalize(Potential_double self, Potential_double p) -> Potential_double"""
        return _pyAgrum.Potential_double_marginalize(self, *args)

    def multiplicate(self, *args) -> "void" :
        """multiplicate(Potential_double self, Potential_double p1, Potential_double p2)"""
        return _pyAgrum.Potential_double_multiplicate(self, *args)

    def multiplicateBy(self, *args) -> "gum::Potential< double > &" :
        """multiplicateBy(Potential_double self, Potential_double p1) -> Potential_double"""
        return _pyAgrum.Potential_double_multiplicateBy(self, *args)

    def sum(self) -> "double const" :
        """sum(Potential_double self) -> double const"""
        return _pyAgrum.Potential_double_sum(self)

    def variablesSequence(self):
        varlist = []
        for i in range(0, self.nbrDim()):
            varlist.append(self.variable(i))
        return varlist

    def __mul__(self,p2):
        """
        return self * p2
        """
        p=Potential()
        p.multiplicate(self,p2)
        return p

    def eliminates(self,var):
        """
        eliminates a variable in the Potential. Returns the new Potential or self if the variable is not in self.
        @warning : returns a list with only one scalar if eliminates remove the last variable
        """
        if var.name() in self.var_names:
            q=Potential()
            for i in range(self.nbrDim()):
                if self.variable(i)!=var:
                    q.add(self.variable(i))
            if q.nbrDim()>0:
                q.marginalize(self)
            else:
                q=[self.sum()]
            return q
        else:
            return self

    def __fill_distrib__(self):
      if not hasattr(self,'_notSync'):
        self._notSync=True

      if self._notSync:
        self._notSync=False
        self._var_names = []
        self._var_dims = []
        content = []
        if self.empty():
            self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
            return
        i = Instantiation(self)
        i.setFirst()
        while not i.end():
            content.append(self.get(i))
            i.inc()
        self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
        for var in self.variablesSequence():
            self._var_names.append(var.name())
            self._var_dims.append(var.domainSize())
        self._var_names.reverse()
        self._var_dims.reverse()
        self.__distrib__.shape = tuple(self._var_dims)


    def __indexfromdict__(self, id_dict):
        index = []
        for name, dim in zip(self._var_names, self._var_dims):
            if name in id_dict:
                id_value = id_dict[name]
                if isinstance(id_value, str):
                    # id_value is a label of a LabelizedVar
                    i = self._var_names.index(name)
                    var = self.variable(len(self._var_names) - 1 - i)
                    id_value = var[id_value]
                if id_value >= dim:
                    raise IndexError("\"%s\" size is %d !"%(name, dim))
                index.append(id_value)
            else:
                index.append(slice(None, None, None)) # equivalent to ':'
        return tuple(index)


    def __str__(self, *args) -> "char const *" :
        """
        __str__(Potential_double self) -> std::string const
        __str__(Potential_double self) -> char const *
        """
        return _pyAgrum.Potential_double___str__(self, *args)

    def tolist(self):
        self.__fill_distrib__()
        return self.__distrib__.tolist()


    def toarray(self):
        return numpy.array(self.tolist())


    def __getitem__(self, id):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        return self.__distrib__[id_slice]


    def __setitem__(self, id, value):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        self.__distrib__[id_slice] = value
        self.fillWith(self.__distrib__.reshape(self.__distrib__.size).tolist())


    @property
    def var_names(self):
        self.__fill_distrib__()
        return self._var_names


    @property
    def var_dims(self):
        self.__fill_distrib__()
        return self._var_dims


    def get(self, *args) -> "double" :
        """get(Potential_double self, Instantiation i) -> double"""
        return _pyAgrum.Potential_double_get(self, *args)

    def set(self, *args) -> "void" :
        """set(Potential_double self, Instantiation i, double const & value)"""
        val = _pyAgrum.Potential_double_set(self, *args)
        self._notSync=True


        return val

    def empty(self) -> "bool" :
        """empty(Potential_double self) -> bool"""
        return _pyAgrum.Potential_double_empty(self)

    def pos(self, *args) -> "gum::Idx" :
        """pos(Potential_double self, DiscreteVariable v) -> gum::Idx"""
        return _pyAgrum.Potential_double_pos(self, *args)

    def contains(self, *args) -> "bool" :
        """contains(Potential_double self, DiscreteVariable v) -> bool"""
        return _pyAgrum.Potential_double_contains(self, *args)

    def nbrDim(self) -> "gum::Idx" :
        """nbrDim(Potential_double self) -> gum::Idx"""
        return _pyAgrum.Potential_double_nbrDim(self)

    def variable(self, *args) -> "gum::DiscreteVariable const &" :
        """variable(Potential_double self, gum::Idx i) -> DiscreteVariable"""
        return _pyAgrum.Potential_double_variable(self, *args)

    def fillWith(self, *args) -> "void" :
        """fillWith(Potential_double self, Vector_double v)"""
        return _pyAgrum.Potential_double_fillWith(self, *args)

    def fill(self, *args) -> "void" :
        """fill(Potential_double self, double const & d)"""
        return _pyAgrum.Potential_double_fill(self, *args)

    def remove(self, *args) -> "void" :
        """remove(Potential_double self, DiscreteVariable var)"""
        val = _pyAgrum.Potential_double_remove(self, *args)
        self._notSync=True


        return val

    def add(self, *args) -> "void" :
        """add(Potential_double self, DiscreteVariable v)"""
        val = _pyAgrum.Potential_double_add(self, *args)
        self._notSync=True


        return val

Potential_double_swigregister = _pyAgrum.Potential_double_swigregister
Potential_double_swigregister(Potential_double)

class UtilityTable_double(_object):
    """Proxy of C++ gum::UtilityTable<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UtilityTable_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UtilityTable_double, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_UtilityTable_double
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(gum::UtilityTable<(double)> self) -> UtilityTable_double
        __init__(gum::UtilityTable<(double)> self, gum::MultiDimImplementation< double > * aContent) -> UtilityTable_double
        __init__(gum::UtilityTable<(double)> self, UtilityTable_double toCopy) -> UtilityTable_double
        """
        this = _pyAgrum.new_UtilityTable_double(*args)
        try: self.this.append(this)
        except: self.this = this
        self._notSync=True



    def newFactory(self) -> "gum::UtilityTable< double > *" :
        """newFactory(UtilityTable_double self) -> UtilityTable_double"""
        return _pyAgrum.UtilityTable_double_newFactory(self)

    def sum(self, *args) -> "void" :
        """sum(UtilityTable_double self, UtilityTable_double p1, UtilityTable_double p2)"""
        return _pyAgrum.UtilityTable_double_sum(self, *args)

    def sumBy(self, *args) -> "void" :
        """
        sumBy(UtilityTable_double self, UtilityTable_double toAdd)
        sumBy(UtilityTable_double self, gum::List< gum::UtilityTable< double > * > const & utilitiesList)
        """
        return _pyAgrum.UtilityTable_double_sumBy(self, *args)

    def reduceBy(self, *args) -> "gum::UtilityTable< double >" :
        """reduceBy(UtilityTable_double self, gum::List< gum::DiscreteVariable const * > const & varList) -> UtilityTable_double"""
        return _pyAgrum.UtilityTable_double_reduceBy(self, *args)

    def variablesSequence(self):
        varlist = []
        for i in range(0, self.nbrDim()):
            varlist.append(self.variable(i))
        return varlist

    def __mul__(self,p2):
        """
        return self * p2
        """
        p=UtilityTable()
        p.multiplicate(self,p2)
        return p

    def eliminates(self,var):
        """
        eliminates a variable in the UtilityTable. Returns the new UtilityTable or self if the variable is not in self.
        @warning : returns a list with only one scalar if eliminates remove the last variable
        """
        if var.name() in self.var_names:
            q=UtilityTable()
            for i in range(self.nbrDim()):
                if self.variable(i)!=var:
                    q.add(self.variable(i))
            if q.nbrDim()>0:
                q.marginalize(self)
            else:
                q=[self.sum()]
            return q
        else:
            return self

    def __fill_distrib__(self):
      if not hasattr(self,'_notSync'):
        self._notSync=True

      if self._notSync:
        self._notSync=False
        self._var_names = []
        self._var_dims = []
        content = []
        if self.empty():
            self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
            return
        i = Instantiation(self)
        i.setFirst()
        while not i.end():
            content.append(self.get(i))
            i.inc()
        self.__distrib__ = numpy.array(content, dtype=numpy.float64) #M
        for var in self.variablesSequence():
            self._var_names.append(var.name())
            self._var_dims.append(var.domainSize())
        self._var_names.reverse()
        self._var_dims.reverse()
        self.__distrib__.shape = tuple(self._var_dims)


    def __indexfromdict__(self, id_dict):
        index = []
        for name, dim in zip(self._var_names, self._var_dims):
            if name in id_dict:
                id_value = id_dict[name]
                if isinstance(id_value, str):
                    # id_value is a label of a LabelizedVar
                    i = self._var_names.index(name)
                    var = self.variable(len(self._var_names) - 1 - i)
                    id_value = var[id_value]
                if id_value >= dim:
                    raise IndexError("\"%s\" size is %d !"%(name, dim))
                index.append(id_value)
            else:
                index.append(slice(None, None, None)) # equivalent to ':'
        return tuple(index)


    def __str__(self) -> "char const *" :
        """__str__(UtilityTable_double self) -> char const *"""
        return _pyAgrum.UtilityTable_double___str__(self)

    def tolist(self):
        self.__fill_distrib__()
        return self.__distrib__.tolist()


    def toarray(self):
        return numpy.array(self.tolist())


    def __getitem__(self, id):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        return self.__distrib__[id_slice]


    def __setitem__(self, id, value):
        self.__fill_distrib__()
        if self.empty():
            raise IndexError("%s is empty !!"%(str(self)))
        if isinstance(id, dict):
            id_slice = self.__indexfromdict__(id)
        else:
            id_slice = id
        self.__distrib__[id_slice] = value
        self.fillWith(self.__distrib__.reshape(self.__distrib__.size).tolist())


    @property
    def var_names(self):
        self.__fill_distrib__()
        return self._var_names


    @property
    def var_dims(self):
        self.__fill_distrib__()
        return self._var_dims


    def get(self, *args) -> "double" :
        """get(UtilityTable_double self, Instantiation i) -> double"""
        return _pyAgrum.UtilityTable_double_get(self, *args)

    def set(self, *args) -> "void" :
        """set(UtilityTable_double self, Instantiation i, double const & value)"""
        val = _pyAgrum.UtilityTable_double_set(self, *args)
        self._notSync=True


        return val

    def empty(self) -> "bool" :
        """empty(UtilityTable_double self) -> bool"""
        return _pyAgrum.UtilityTable_double_empty(self)

    def pos(self, *args) -> "gum::Idx" :
        """pos(UtilityTable_double self, DiscreteVariable v) -> gum::Idx"""
        return _pyAgrum.UtilityTable_double_pos(self, *args)

    def contains(self, *args) -> "bool" :
        """contains(UtilityTable_double self, DiscreteVariable v) -> bool"""
        return _pyAgrum.UtilityTable_double_contains(self, *args)

    def nbrDim(self) -> "gum::Idx" :
        """nbrDim(UtilityTable_double self) -> gum::Idx"""
        return _pyAgrum.UtilityTable_double_nbrDim(self)

    def variable(self, *args) -> "gum::DiscreteVariable const &" :
        """variable(UtilityTable_double self, gum::Idx i) -> DiscreteVariable"""
        return _pyAgrum.UtilityTable_double_variable(self, *args)

    def fillWith(self, *args) -> "void" :
        """fillWith(UtilityTable_double self, Vector_double v)"""
        return _pyAgrum.UtilityTable_double_fillWith(self, *args)

    def fill(self, *args) -> "void" :
        """fill(UtilityTable_double self, double const & d)"""
        return _pyAgrum.UtilityTable_double_fill(self, *args)

    def remove(self, *args) -> "void" :
        """remove(UtilityTable_double self, DiscreteVariable var)"""
        val = _pyAgrum.UtilityTable_double_remove(self, *args)
        self._notSync=True


        return val

    def add(self, *args) -> "void" :
        """add(UtilityTable_double self, DiscreteVariable v)"""
        val = _pyAgrum.UtilityTable_double_add(self, *args)
        self._notSync=True


        return val

UtilityTable_double_swigregister = _pyAgrum.UtilityTable_double_swigregister
UtilityTable_double_swigregister(UtilityTable_double)

class IBayesNet_double(DAGmodel):
    """Proxy of C++ gum::IBayesNet<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [DAGmodel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IBayesNet_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DAGmodel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IBayesNet_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_IBayesNet_double
    __del__ = lambda self : None;
    def cpt(self, *args) -> "gum::Potential< double > const &" :
        """cpt(IBayesNet_double self, gum::NodeId varId) -> Potential_double"""
        return _pyAgrum.IBayesNet_double_cpt(self, *args)

    def variableNodeMap(self) -> "gum::VariableNodeMap const &" :
        """variableNodeMap(IBayesNet_double self) -> VariableNodeMap"""
        return _pyAgrum.IBayesNet_double_variableNodeMap(self)

    def variable(self, *args) -> "gum::DiscreteVariable const &" :
        """variable(IBayesNet_double self, gum::NodeId id) -> DiscreteVariable"""
        return _pyAgrum.IBayesNet_double_variable(self, *args)

    def nodeId(self, *args) -> "gum::NodeId" :
        """nodeId(IBayesNet_double self, DiscreteVariable var) -> gum::NodeId"""
        return _pyAgrum.IBayesNet_double_nodeId(self, *args)

    def idFromName(self, *args) -> "gum::NodeId" :
        """idFromName(IBayesNet_double self, std::string const & name) -> gum::NodeId"""
        return _pyAgrum.IBayesNet_double_idFromName(self, *args)

    def variableFromName(self, *args) -> "gum::DiscreteVariable const &" :
        """variableFromName(IBayesNet_double self, std::string const & name) -> DiscreteVariable"""
        return _pyAgrum.IBayesNet_double_variableFromName(self, *args)

    def jointProbability(self, *args) -> "double" :
        """jointProbability(IBayesNet_double self, Instantiation i) -> double"""
        return _pyAgrum.IBayesNet_double_jointProbability(self, *args)

    def log2JointProbability(self, *args) -> "double" :
        """log2JointProbability(IBayesNet_double self, Instantiation i) -> double"""
        return _pyAgrum.IBayesNet_double_log2JointProbability(self, *args)

    def __eq__(self, *args) -> "bool" :
        """__eq__(IBayesNet_double self, IBayesNet_double src) -> bool"""
        return _pyAgrum.IBayesNet_double___eq__(self, *args)

    def __ne__(self, *args) -> "bool" :
        """__ne__(IBayesNet_double self, IBayesNet_double src) -> bool"""
        return _pyAgrum.IBayesNet_double___ne__(self, *args)

    def dim(self) -> "gum::Idx" :
        """dim(IBayesNet_double self) -> gum::Idx"""
        return _pyAgrum.IBayesNet_double_dim(self)

    def toDot(self) -> "std::string" :
        """toDot(IBayesNet_double self) -> std::string"""
        return _pyAgrum.IBayesNet_double_toDot(self)

    def __str__(self) -> "std::string" :
        """__str__(IBayesNet_double self) -> std::string"""
        return _pyAgrum.IBayesNet_double___str__(self)

IBayesNet_double_swigregister = _pyAgrum.IBayesNet_double_swigregister
IBayesNet_double_swigregister(IBayesNet_double)

class BayesNet_double(IBayesNet_double):
    """Proxy of C++ gum::BayesNet<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [IBayesNet_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNet_double, name, value)
    __swig_getmethods__ = {}
    for _s in [IBayesNet_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNet_double, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_BayesNet_double
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(gum::BayesNet<(double)> self) -> BayesNet_double
        __init__(gum::BayesNet<(double)> self, std::string name) -> BayesNet_double
        __init__(gum::BayesNet<(double)> self, BayesNet_double source) -> BayesNet_double
        """
        this = _pyAgrum.new_BayesNet_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def cpt(self, *args) -> "gum::Potential< double > const &" :
        """cpt(BayesNet_double self, gum::NodeId varId) -> Potential_double"""
        val = _pyAgrum.BayesNet_double_cpt(self, *args)
        val.__fill_distrib__()


        return val

    def variableNodeMap(self) -> "gum::VariableNodeMap const &" :
        """variableNodeMap(BayesNet_double self) -> VariableNodeMap"""
        return _pyAgrum.BayesNet_double_variableNodeMap(self)

    def toDot(self) -> "std::string" :
        """toDot(BayesNet_double self) -> std::string"""
        return _pyAgrum.BayesNet_double_toDot(self)

    def add(self, *args) -> "gum::NodeId" :
        """
        add(BayesNet_double self, DiscreteVariable variable) -> gum::NodeId
        add(BayesNet_double self, DiscreteVariable variable, gum::MultiDimImplementation< double > * aContent) -> gum::NodeId
        add(BayesNet_double self, DiscreteVariable variable, gum::NodeId id) -> gum::NodeId
        add(BayesNet_double self, DiscreteVariable variable, gum::MultiDimImplementation< double > * aContent, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_add(self, *args)

    def erase(self, *args) -> "void" :
        """
        erase(BayesNet_double self, gum::NodeId id)
        erase(BayesNet_double self, DiscreteVariable var)
        """
        return _pyAgrum.BayesNet_double_erase(self, *args)

    def variable(self, *args) -> "gum::DiscreteVariable const &" :
        """variable(BayesNet_double self, gum::NodeId id) -> DiscreteVariable"""
        return _pyAgrum.BayesNet_double_variable(self, *args)

    def changeVariableName(self, *args) -> "void" :
        """changeVariableName(BayesNet_double self, gum::NodeId id, std::string const & new_name)"""
        return _pyAgrum.BayesNet_double_changeVariableName(self, *args)

    def nodeId(self, *args) -> "gum::NodeId" :
        """nodeId(BayesNet_double self, DiscreteVariable var) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_nodeId(self, *args)

    def idFromName(self, *args) -> "gum::NodeId" :
        """idFromName(BayesNet_double self, std::string const & name) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_idFromName(self, *args)

    def variableFromName(self, *args) -> "gum::DiscreteVariable const &" :
        """variableFromName(BayesNet_double self, std::string const & name) -> DiscreteVariable"""
        return _pyAgrum.BayesNet_double_variableFromName(self, *args)

    def addArc(self, *args) -> "void" :
        """addArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head)"""
        return _pyAgrum.BayesNet_double_addArc(self, *args)

    def eraseArc(self, *args) -> "void" :
        """
        eraseArc(BayesNet_double self, Arc arc)
        eraseArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head)
        """
        return _pyAgrum.BayesNet_double_eraseArc(self, *args)

    def beginTopologyTransformation(self) -> "void" :
        """beginTopologyTransformation(BayesNet_double self)"""
        return _pyAgrum.BayesNet_double_beginTopologyTransformation(self)

    def endTopologyTransformation(self) -> "void" :
        """endTopologyTransformation(BayesNet_double self)"""
        return _pyAgrum.BayesNet_double_endTopologyTransformation(self)

    def reverseArc(self, *args) -> "void" :
        """
        reverseArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head)
        reverseArc(BayesNet_double self, Arc arc)
        """
        return _pyAgrum.BayesNet_double_reverseArc(self, *args)

    def addNoisyOR(self, *args) -> "gum::NodeId" :
        """
        addNoisyOR(BayesNet_double self, DiscreteVariable variable, double externalWeight) -> gum::NodeId
        addNoisyOR(BayesNet_double self, DiscreteVariable variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyOR(self, *args)

    def addNoisyORNet(self, *args) -> "gum::NodeId" :
        """
        addNoisyORNet(BayesNet_double self, DiscreteVariable variable, double externalWeight) -> gum::NodeId
        addNoisyORNet(BayesNet_double self, DiscreteVariable variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORNet(self, *args)

    def addNoisyORCompound(self, *args) -> "gum::NodeId" :
        """
        addNoisyORCompound(BayesNet_double self, DiscreteVariable variable, double externalWeight) -> gum::NodeId
        addNoisyORCompound(BayesNet_double self, DiscreteVariable variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyORCompound(self, *args)

    def addNoisyAND(self, *args) -> "gum::NodeId" :
        """
        addNoisyAND(BayesNet_double self, DiscreteVariable variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        addNoisyAND(BayesNet_double self, DiscreteVariable variable, double externalWeight) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addNoisyAND(self, *args)

    def addLogit(self, *args) -> "gum::NodeId" :
        """
        addLogit(BayesNet_double self, DiscreteVariable variable, double externalWeight, gum::NodeId id) -> gum::NodeId
        addLogit(BayesNet_double self, DiscreteVariable variable, double externalWeight) -> gum::NodeId
        """
        return _pyAgrum.BayesNet_double_addLogit(self, *args)

    def addOR(self, *args) -> "gum::NodeId" :
        """addOR(BayesNet_double self, DiscreteVariable variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addOR(self, *args)

    def addAND(self, *args) -> "gum::NodeId" :
        """addAND(BayesNet_double self, DiscreteVariable variable) -> gum::NodeId"""
        return _pyAgrum.BayesNet_double_addAND(self, *args)

    def addWeightedArc(self, *args) -> "void" :
        """addWeightedArc(BayesNet_double self, gum::NodeId tail, gum::NodeId head, double causalWeight)"""
        return _pyAgrum.BayesNet_double_addWeightedArc(self, *args)

    def generateCPTs(self) -> "void" :
        """generateCPTs(BayesNet_double self)"""
        return _pyAgrum.BayesNet_double_generateCPTs(self)

    def changePotential(self, *args) -> "void" :
        """changePotential(BayesNet_double self, gum::NodeId id, Potential_double newPot)"""
        return _pyAgrum.BayesNet_double_changePotential(self, *args)

    def dag(self) -> "gum::DAG const &" :
        """dag(BayesNet_double self) -> DAG"""
        return _pyAgrum.BayesNet_double_dag(self)

    def size(self) -> "gum::Size" :
        """size(BayesNet_double self) -> gum::Size"""
        return _pyAgrum.BayesNet_double_size(self)

    def log10DomainSize(self) -> "double" :
        """log10DomainSize(BayesNet_double self) -> double"""
        return _pyAgrum.BayesNet_double_log10DomainSize(self)

    def names(self) -> "PyObject *" :
        """names(BayesNet_double self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_names(self)

    def ids(self) -> "PyObject *" :
        """ids(BayesNet_double self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_ids(self)

    def arcs(self) -> "PyObject *" :
        """arcs(BayesNet_double self) -> PyObject *"""
        return _pyAgrum.BayesNet_double_arcs(self)

    def parents(self, *args) -> "PyObject *" :
        """parents(BayesNet_double self, gum::NodeId const id) -> PyObject *"""
        return _pyAgrum.BayesNet_double_parents(self, *args)

    def children(self, *args) -> "PyObject *" :
        """children(BayesNet_double self, gum::NodeId const id) -> PyObject *"""
        return _pyAgrum.BayesNet_double_children(self, *args)

    def loadBIF(self, *args) -> "bool" :
        """
        loadBIF(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadBIF(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadBIF(self, *args)

    def saveBIF(self, *args) -> "void" :
        """saveBIF(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveBIF(self, *args)

    def loadDSL(self, *args) -> "bool" :
        """
        loadDSL(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadDSL(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadDSL(self, *args)

    def saveDSL(self, *args) -> "void" :
        """saveDSL(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveDSL(self, *args)

    def loadNET(self, *args) -> "bool" :
        """
        loadNET(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadNET(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadNET(self, *args)

    def saveNET(self, *args) -> "void" :
        """saveNET(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveNET(self, *args)

    def loadBIFXML(self, *args) -> "bool" :
        """
        loadBIFXML(BayesNet_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadBIFXML(BayesNet_double self, std::string name) -> bool
        """
        return _pyAgrum.BayesNet_double_loadBIFXML(self, *args)

    def saveBIFXML(self, *args) -> "void" :
        """saveBIFXML(BayesNet_double self, std::string name)"""
        return _pyAgrum.BayesNet_double_saveBIFXML(self, *args)

BayesNet_double_swigregister = _pyAgrum.BayesNet_double_swigregister
BayesNet_double_swigregister(BayesNet_double)

class BayesNetInference_double(_object):
    """Proxy of C++ gum::BayesNetInference<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BayesNetInference_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BayesNetInference_double, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_BayesNetInference_double
    __del__ = lambda self : None;
    def makeInference(self) -> "void" :
        """makeInference(BayesNetInference_double self)"""
        return _pyAgrum.BayesNetInference_double_makeInference(self)

    def posterior(self, *args) -> "gum::Potential< double > const &" :
        """posterior(BayesNetInference_double self, gum::NodeId id) -> Potential_double"""
        val = _pyAgrum.BayesNetInference_double_posterior(self, *args)
        val.__fill_distrib__()


        return val

    def insertEvidence(self, *args) -> "void" :
        """insertEvidence(BayesNetInference_double self, gum::List< gum::Potential< double > const * > const & pot_list)"""
        return _pyAgrum.BayesNetInference_double_insertEvidence(self, *args)

    def addHardEvidence(self, *args) -> "void" :
        """addHardEvidence(BayesNetInference_double self, gum::NodeId const id, gum::Idx const val)"""
        return _pyAgrum.BayesNetInference_double_addHardEvidence(self, *args)

    def eraseEvidence(self, *args) -> "void" :
        """eraseEvidence(BayesNetInference_double self, Potential_double e)"""
        return _pyAgrum.BayesNetInference_double_eraseEvidence(self, *args)

    def eraseAllEvidence(self) -> "void" :
        """eraseAllEvidence(BayesNetInference_double self)"""
        return _pyAgrum.BayesNetInference_double_eraseAllEvidence(self)

    def bn(self) -> "gum::IBayesNet< double > const &" :
        """bn(BayesNetInference_double self) -> IBayesNet_double"""
        return _pyAgrum.BayesNetInference_double_bn(self)

    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be dict, not %s"%(type(evidces)))
        bn = self.bn()


        # set evidences
        self.list_pot = []
        try:
          items=evidces.iteritems()
        except AttributeError:
          items=evidces.items()

        for var_name, evidce in items:
            pot = Potential_double()

            if isinstance(var_name, int):
                var = bn.variable(var_name)
            elif isinstance(var_name, str):
                var = bn.variableFromName(var_name)
            else:
                raise TypeError('values of the dict must be int or string')

            pot.add(var)
            if isinstance(evidce, (int, float, str)):
                pot[:] = 0
                # determine the var type
                try:
                    cast_var = var.toLabelizedVar()
                    if isinstance(evidce, int):
                        index = evidce
                    elif isinstance(evidce, str):
                        index = cast_var[evidce]
                    else:
                        raise TypeError('values of the dict must be int or string')
                except RuntimeError:
                    try:
                        cast_var = var.toRangeVar()
                        if isinstance(evidce, int):
                            index = cast_var[str(evidce)]
                        elif isinstance(evidce, str):
                            index = cast_var[evidce]
                        else:
                            raise TypeError('values of the dict must be int or string')
                    except RuntimeError:
                        cast_var = var.toDiscretizedVar()
                        if isinstance(evidce, float):
                            index = cast_var.index(evidce)
                        elif isinstance(evidce, str):
                            index = cast_var.index(float(evidce))
                        else:
                            raise TypeError('values of the dict must be float or string')
                pot[index] = 1
            elif isinstance(evidce, (list, tuple)):
                pot[:] = evidce
            else:
                raise TypeError('dict values must be number, string or sequence')
            self.list_pot.append(pot)

        self.eraseAllEvidence()
        self._setEvidence(self.list_pot)


    def _setEvidence(self, *args) -> "void" :
        """_setEvidence(BayesNetInference_double self, PyObject * evidences)"""
        return _pyAgrum.BayesNetInference_double__setEvidence(self, *args)

BayesNetInference_double_swigregister = _pyAgrum.BayesNetInference_double_swigregister
BayesNetInference_double_swigregister(BayesNetInference_double)

class LazyPropagation_double(BayesNetInference_double):
    """Proxy of C++ gum::LazyPropagation<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LazyPropagation_double, name, value)
    __swig_getmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LazyPropagation_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::LazyPropagation<(double)> self, IBayesNet_double BN) -> LazyPropagation_double
        __init__(gum::LazyPropagation<(double)> self, IBayesNet_double BN, std::vector< gum::NodeId,std::allocator< gum::NodeId > > const & elim_order) -> LazyPropagation_double
        """
        this = _pyAgrum.new_LazyPropagation_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_LazyPropagation_double
    __del__ = lambda self : None;
    def insertEvidence(self, *args) -> "void" :
        """insertEvidence(LazyPropagation_double self, gum::List< gum::Potential< double > const * > const & arg2)"""
        return _pyAgrum.LazyPropagation_double_insertEvidence(self, *args)

    def eraseAllEvidence(self) -> "void" :
        """eraseAllEvidence(LazyPropagation_double self)"""
        return _pyAgrum.LazyPropagation_double_eraseAllEvidence(self)

    def eraseEvidence(self, *args) -> "void" :
        """eraseEvidence(LazyPropagation_double self, Potential_double arg2)"""
        return _pyAgrum.LazyPropagation_double_eraseEvidence(self, *args)

    def collect(self, *args) -> "void" :
        """
        collect(LazyPropagation_double self, gum::NodeId id, bool force_collect=False)
        collect(LazyPropagation_double self, gum::NodeId id)
        """
        return _pyAgrum.LazyPropagation_double_collect(self, *args)

    def diffusion(self, *args) -> "void" :
        """
        diffusion(LazyPropagation_double self, gum::NodeId id, bool force_diffusion=False)
        diffusion(LazyPropagation_double self, gum::NodeId id)
        """
        return _pyAgrum.LazyPropagation_double_diffusion(self, *args)

    def makeInference(self, *args) -> "void" :
        """
        makeInference(LazyPropagation_double self)
        makeInference(LazyPropagation_double self, bool force_inference)
        """
        return _pyAgrum.LazyPropagation_double_makeInference(self, *args)

    def evidenceProbability(self) -> "double" :
        """evidenceProbability(LazyPropagation_double self) -> double"""
        return _pyAgrum.LazyPropagation_double_evidenceProbability(self)

    def junctionTree(self) -> "gum::JunctionTree const *" :
        """junctionTree(LazyPropagation_double self) -> CliqueGraph"""
        return _pyAgrum.LazyPropagation_double_junctionTree(self)

    def H(self, *args) -> "double" :
        """H(LazyPropagation_double self, gum::NodeId X) -> double"""
        return _pyAgrum.LazyPropagation_double_H(self, *args)

    def I(self, *args) -> "double" :
        """I(LazyPropagation_double self, gum::NodeId X, gum::NodeId Y) -> double"""
        return _pyAgrum.LazyPropagation_double_I(self, *args)

    def VI(self, *args) -> "double" :
        """VI(LazyPropagation_double self, gum::NodeId X, gum::NodeId Y) -> double"""
        return _pyAgrum.LazyPropagation_double_VI(self, *args)

    def junctionTreeToDot(self) -> "std::string const" :
        """junctionTreeToDot(LazyPropagation_double self) -> std::string const"""
        return _pyAgrum.LazyPropagation_double_junctionTreeToDot(self)

    def joint(self, *args) -> "gum::Potential< double > *" :
        """
        joint(LazyPropagation_double self, gum::NodeSet const & nodes) -> Potential_double
        joint(LazyPropagation_double self, PyObject * seq_of_ids) -> Potential_double
        """
        return _pyAgrum.LazyPropagation_double_joint(self, *args)

    def addHardEvidence(self, *args) -> "void" :
        """addHardEvidence(LazyPropagation_double self, gum::NodeId const id, gum::Idx val)"""
        return _pyAgrum.LazyPropagation_double_addHardEvidence(self, *args)

LazyPropagation_double_swigregister = _pyAgrum.LazyPropagation_double_swigregister
LazyPropagation_double_swigregister(LazyPropagation_double)

class GibbsInference_double(BayesNetInference_double):
    """Proxy of C++ gum::GibbsInference<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsInference_double, name, value)
    __swig_getmethods__ = {}
    for _s in [BayesNetInference_double]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsInference_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gum::GibbsInference<(double)> self, IBayesNet_double BN) -> GibbsInference_double"""
        this = _pyAgrum.new_GibbsInference_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsInference_double
    __del__ = lambda self : None;
    def makeInference(self) -> "void" :
        """makeInference(GibbsInference_double self)"""
        return _pyAgrum.GibbsInference_double_makeInference(self)

    def insertEvidence(self, *args) -> "void" :
        """insertEvidence(GibbsInference_double self, gum::List< gum::Potential< double > const * > const & pot_list)"""
        return _pyAgrum.GibbsInference_double_insertEvidence(self, *args)

    def eraseEvidence(self, *args) -> "void" :
        """eraseEvidence(GibbsInference_double self, Potential_double e)"""
        return _pyAgrum.GibbsInference_double_eraseEvidence(self, *args)

    def eraseAllEvidence(self) -> "void" :
        """eraseAllEvidence(GibbsInference_double self)"""
        return _pyAgrum.GibbsInference_double_eraseAllEvidence(self)

    def setRequiredInference(self) -> "void" :
        """setRequiredInference(GibbsInference_double self)"""
        return _pyAgrum.GibbsInference_double_setRequiredInference(self)

    def isInferenceRequired(self) -> "bool" :
        """isInferenceRequired(GibbsInference_double self) -> bool"""
        return _pyAgrum.GibbsInference_double_isInferenceRequired(self)

    def castAsASC(self, *args) -> "gum::IApproximationSchemeConfiguration const &" :
        """castAsASC(GibbsInference_double self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.GibbsInference_double_castAsASC(self, *args)

    def addHardEvidence(self, *args) -> "void" :
        """addHardEvidence(GibbsInference_double self, gum::NodeId const id, gum::Idx val)"""
        return _pyAgrum.GibbsInference_double_addHardEvidence(self, *args)

    def setVerbosity(self, *args) -> "void" :
        """setVerbosity(GibbsInference_double self, bool v)"""
        return _pyAgrum.GibbsInference_double_setVerbosity(self, *args)

    def setEpsilon(self, *args) -> "void" :
        """setEpsilon(GibbsInference_double self, double eps)"""
        return _pyAgrum.GibbsInference_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args) -> "void" :
        """setMinEpsilonRate(GibbsInference_double self, double rate)"""
        return _pyAgrum.GibbsInference_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args) -> "void" :
        """setMaxIter(GibbsInference_double self, gum::Size max)"""
        return _pyAgrum.GibbsInference_double_setMaxIter(self, *args)

    def setMaxTime(self, *args) -> "void" :
        """setMaxTime(GibbsInference_double self, double timeout)"""
        return _pyAgrum.GibbsInference_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args) -> "void" :
        """setPeriodSize(GibbsInference_double self, gum::Size p)"""
        return _pyAgrum.GibbsInference_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args) -> "void" :
        """setBurnIn(GibbsInference_double self, gum::Size b)"""
        return _pyAgrum.GibbsInference_double_setBurnIn(self, *args)

    def verbosity(self) -> "bool" :
        """verbosity(GibbsInference_double self) -> bool"""
        return _pyAgrum.GibbsInference_double_verbosity(self)

    def epsilon(self) -> "double" :
        """epsilon(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_epsilon(self)

    def minEpsilonRate(self) -> "double" :
        """minEpsilonRate(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_minEpsilonRate(self)

    def maxIter(self) -> "gum::Size" :
        """maxIter(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_maxIter(self)

    def maxTime(self) -> "double" :
        """maxTime(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_maxTime(self)

    def periodSize(self) -> "gum::Size" :
        """periodSize(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_periodSize(self)

    def burnIn(self) -> "gum::Size" :
        """burnIn(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_burnIn(self)

    def nbrIterations(self) -> "gum::Size" :
        """nbrIterations(GibbsInference_double self) -> gum::Size"""
        return _pyAgrum.GibbsInference_double_nbrIterations(self)

    def currentTime(self) -> "double" :
        """currentTime(GibbsInference_double self) -> double"""
        return _pyAgrum.GibbsInference_double_currentTime(self)

    def messageApproximationScheme(self) -> "std::string" :
        """messageApproximationScheme(GibbsInference_double self) -> std::string"""
        return _pyAgrum.GibbsInference_double_messageApproximationScheme(self)

    def history(self) -> "std::vector< double,std::allocator< double > > const &" :
        """history(GibbsInference_double self) -> Vector_double"""
        return _pyAgrum.GibbsInference_double_history(self)

GibbsInference_double_swigregister = _pyAgrum.GibbsInference_double_swigregister
GibbsInference_double_swigregister(GibbsInference_double)

class BruteForceKL_double(_object):
    """Proxy of C++ gum::BruteForceKL<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BruteForceKL_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BruteForceKL_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::BruteForceKL<(double)> self, IBayesNet_double P, IBayesNet_double Q) -> BruteForceKL_double
        __init__(gum::BruteForceKL<(double)> self, gum::KL< double > const & kl) -> BruteForceKL_double
        """
        this = _pyAgrum.new_BruteForceKL_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_BruteForceKL_double
    __del__ = lambda self : None;
    def compute(self) -> "PyObject *" :
        """compute(BruteForceKL_double self) -> PyObject *"""
        return _pyAgrum.BruteForceKL_double_compute(self)

BruteForceKL_double_swigregister = _pyAgrum.BruteForceKL_double_swigregister
BruteForceKL_double_swigregister(BruteForceKL_double)

class GibbsKL_double(_object):
    """Proxy of C++ gum::GibbsKL<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GibbsKL_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GibbsKL_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gum::GibbsKL<(double)> self, IBayesNet_double P, IBayesNet_double Q) -> GibbsKL_double
        __init__(gum::GibbsKL<(double)> self, gum::KL< double > const & kl) -> GibbsKL_double
        """
        this = _pyAgrum.new_GibbsKL_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_GibbsKL_double
    __del__ = lambda self : None;
    def compute(self) -> "PyObject *" :
        """compute(GibbsKL_double self) -> PyObject *"""
        return _pyAgrum.GibbsKL_double_compute(self)

    def castAsASC(self, *args) -> "gum::IApproximationSchemeConfiguration const &" :
        """castAsASC(GibbsKL_double self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.GibbsKL_double_castAsASC(self, *args)

    def setVerbosity(self, *args) -> "void" :
        """setVerbosity(GibbsKL_double self, bool v)"""
        return _pyAgrum.GibbsKL_double_setVerbosity(self, *args)

    def setEpsilon(self, *args) -> "void" :
        """setEpsilon(GibbsKL_double self, double eps)"""
        return _pyAgrum.GibbsKL_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args) -> "void" :
        """setMinEpsilonRate(GibbsKL_double self, double rate)"""
        return _pyAgrum.GibbsKL_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args) -> "void" :
        """setMaxIter(GibbsKL_double self, gum::Size max)"""
        return _pyAgrum.GibbsKL_double_setMaxIter(self, *args)

    def setMaxTime(self, *args) -> "void" :
        """setMaxTime(GibbsKL_double self, double timeout)"""
        return _pyAgrum.GibbsKL_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args) -> "void" :
        """setPeriodSize(GibbsKL_double self, gum::Size p)"""
        return _pyAgrum.GibbsKL_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args) -> "void" :
        """setBurnIn(GibbsKL_double self, gum::Size b)"""
        return _pyAgrum.GibbsKL_double_setBurnIn(self, *args)

    def verbosity(self) -> "bool" :
        """verbosity(GibbsKL_double self) -> bool"""
        return _pyAgrum.GibbsKL_double_verbosity(self)

    def epsilon(self) -> "double" :
        """epsilon(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_epsilon(self)

    def minEpsilonRate(self) -> "double" :
        """minEpsilonRate(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_minEpsilonRate(self)

    def maxIter(self) -> "gum::Size" :
        """maxIter(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_maxIter(self)

    def maxTime(self) -> "double" :
        """maxTime(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_maxTime(self)

    def periodSize(self) -> "gum::Size" :
        """periodSize(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_periodSize(self)

    def burnIn(self) -> "gum::Size" :
        """burnIn(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_burnIn(self)

    def nbrIterations(self) -> "gum::Size" :
        """nbrIterations(GibbsKL_double self) -> gum::Size"""
        return _pyAgrum.GibbsKL_double_nbrIterations(self)

    def currentTime(self) -> "double" :
        """currentTime(GibbsKL_double self) -> double"""
        return _pyAgrum.GibbsKL_double_currentTime(self)

    def messageApproximationScheme(self) -> "std::string" :
        """messageApproximationScheme(GibbsKL_double self) -> std::string"""
        return _pyAgrum.GibbsKL_double_messageApproximationScheme(self)

    def history(self) -> "std::vector< double,std::allocator< double > > const &" :
        """history(GibbsKL_double self) -> Vector_double"""
        return _pyAgrum.GibbsKL_double_history(self)

GibbsKL_double_swigregister = _pyAgrum.GibbsKL_double_swigregister
GibbsKL_double_swigregister(GibbsKL_double)

class CredalNet_double(_object):
    """Proxy of C++ gum::credal::CredalNet<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CredalNet_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CredalNet_double, name)
    __repr__ = _swig_repr
    Precise = _pyAgrum.CredalNet_double_Precise
    Credal = _pyAgrum.CredalNet_double_Credal
    Vacuous = _pyAgrum.CredalNet_double_Vacuous
    Indic = _pyAgrum.CredalNet_double_Indic
    def __init__(self, *args): 
        """
        __init__(gum::credal::CredalNet<(double)> self) -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, std::string const & src_min_num, std::string const & src_max_den="") -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, std::string const & src_min_num) -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, BayesNet_double src_min_num, BayesNet_double src_max_den=gum::BayesNet()) -> CredalNet_double
        __init__(gum::credal::CredalNet<(double)> self, BayesNet_double src_min_num) -> CredalNet_double
        """
        this = _pyAgrum.new_CredalNet_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CredalNet_double
    __del__ = lambda self : None;
    def addNode(self, *args) -> "gum::NodeId" :
        """addNode(CredalNet_double self, std::string const & name, unsigned long const & card) -> gum::NodeId"""
        return _pyAgrum.CredalNet_double_addNode(self, *args)

    def addArc(self, *args) -> "void" :
        """addArc(CredalNet_double self, gum::NodeId const & tail, gum::NodeId const & head)"""
        return _pyAgrum.CredalNet_double_addArc(self, *args)

    def setCPTs(self, *args) -> "void" :
        """setCPTs(CredalNet_double self, gum::NodeId const & id, std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > const & cpt)"""
        return _pyAgrum.CredalNet_double_setCPTs(self, *args)

    def setCPT(self, *args) -> "void" :
        """
        setCPT(CredalNet_double self, gum::NodeId const & id, unsigned long & entry, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & cpt)
        setCPT(CredalNet_double self, gum::NodeId const & id, Instantiation ins, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & cpt)
        """
        return _pyAgrum.CredalNet_double_setCPT(self, *args)

    def fillConstraints(self, *args) -> "void" :
        """fillConstraints(CredalNet_double self, gum::NodeId const & id, Vector_double lower, Vector_double upper)"""
        return _pyAgrum.CredalNet_double_fillConstraints(self, *args)

    def fillConstraint(self, *args) -> "void" :
        """
        fillConstraint(CredalNet_double self, gum::NodeId const & id, unsigned long & entry, Vector_double lower, Vector_double upper)
        fillConstraint(CredalNet_double self, gum::NodeId const & id, Instantiation ins, Vector_double lower, Vector_double upper)
        """
        return _pyAgrum.CredalNet_double_fillConstraint(self, *args)

    def instantiation(self, *args) -> "gum::Instantiation" :
        """instantiation(CredalNet_double self, gum::NodeId const & id) -> Instantiation"""
        return _pyAgrum.CredalNet_double_instantiation(self, *args)

    def domainSize(self, *args) -> "gum::Size" :
        """domainSize(CredalNet_double self, gum::NodeId const & id) -> gum::Size"""
        return _pyAgrum.CredalNet_double_domainSize(self, *args)

    def bnToCredal(self, *args) -> "void" :
        """
        bnToCredal(CredalNet_double self, double const beta, bool const oneNet, bool const keepZeroes=False)
        bnToCredal(CredalNet_double self, double const beta, bool const oneNet)
        """
        return _pyAgrum.CredalNet_double_bnToCredal(self, *args)

    def intervalToCredalWithFiles(self) -> "void" :
        """intervalToCredalWithFiles(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_intervalToCredalWithFiles(self)

    def intervalToCredal(self) -> "void" :
        """intervalToCredal(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_intervalToCredal(self)

    def lagrangeNormalization(self) -> "void" :
        """lagrangeNormalization(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_lagrangeNormalization(self)

    def idmLearning(self, s : 'unsigned int const'=0, keepZeroes : 'bool const'=False) -> "void" :
        """
        idmLearning(CredalNet_double self, unsigned int const s=0, bool const keepZeroes=False)
        idmLearning(CredalNet_double self, unsigned int const s=0)
        idmLearning(CredalNet_double self)
        """
        return _pyAgrum.CredalNet_double_idmLearning(self, s, keepZeroes)

    def approximatedBinarization(self) -> "void" :
        """approximatedBinarization(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_approximatedBinarization(self)

    def saveBNsMinMax(self, *args) -> "void" :
        """saveBNsMinMax(CredalNet_double self, std::string const & min_path, std::string const & max_path)"""
        return _pyAgrum.CredalNet_double_saveBNsMinMax(self, *args)

    def __str__(self) -> "std::string" :
        """__str__(CredalNet_double self) -> std::string"""
        return _pyAgrum.CredalNet_double___str__(self)

    def computeCPTMinMax(self) -> "void" :
        """computeCPTMinMax(CredalNet_double self)"""
        return _pyAgrum.CredalNet_double_computeCPTMinMax(self)

    def src_bn(self) -> "gum::BayesNet< double > const &" :
        """src_bn(CredalNet_double self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_src_bn(self)

    def current_bn(self) -> "gum::BayesNet< double > const &" :
        """current_bn(CredalNet_double self) -> BayesNet_double"""
        return _pyAgrum.CredalNet_double_current_bn(self)

    def credalNet_currentCpt(self) -> "NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &" :
        """credalNet_currentCpt(CredalNet_double self) -> NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &"""
        return _pyAgrum.CredalNet_double_credalNet_currentCpt(self)

    def credalNet_srcCpt(self) -> "NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &" :
        """credalNet_srcCpt(CredalNet_double self) -> NodeProperty< std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > > > const &"""
        return _pyAgrum.CredalNet_double_credalNet_srcCpt(self)

    def currentNodeType(self, *args) -> "gum::credal::CredalNet< double >::NodeType" :
        """currentNodeType(CredalNet_double self, gum::NodeId const & id) -> gum::credal::CredalNet< double >::NodeType"""
        return _pyAgrum.CredalNet_double_currentNodeType(self, *args)

    def nodeType(self, *args) -> "gum::credal::CredalNet< double >::NodeType" :
        """nodeType(CredalNet_double self, gum::NodeId const & id) -> gum::credal::CredalNet< double >::NodeType"""
        return _pyAgrum.CredalNet_double_nodeType(self, *args)

    def epsilonMin(self) -> "double const &" :
        """epsilonMin(CredalNet_double self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMin(self)

    def epsilonMax(self) -> "double const &" :
        """epsilonMax(CredalNet_double self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMax(self)

    def epsilonMean(self) -> "double const &" :
        """epsilonMean(CredalNet_double self) -> double const &"""
        return _pyAgrum.CredalNet_double_epsilonMean(self)

    def isSeparatelySpecified(self) -> "bool const" :
        """isSeparatelySpecified(CredalNet_double self) -> bool const"""
        return _pyAgrum.CredalNet_double_isSeparatelySpecified(self)

    def hasComputedCPTMinMax(self) -> "bool const" :
        """hasComputedCPTMinMax(CredalNet_double self) -> bool const"""
        return _pyAgrum.CredalNet_double_hasComputedCPTMinMax(self)

    def get_CPT_min(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &" :
        """get_CPT_min(CredalNet_double self) -> std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &"""
        return _pyAgrum.CredalNet_double_get_CPT_min(self)

    def get_CPT_max(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &" :
        """get_CPT_max(CredalNet_double self) -> std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &"""
        return _pyAgrum.CredalNet_double_get_CPT_max(self)

CredalNet_double_swigregister = _pyAgrum.CredalNet_double_swigregister
CredalNet_double_swigregister(CredalNet_double)

class CNMonteCarloSampling_double(_object):
    """Proxy of C++ gum::credal::CNMonteCarloSampling<(double,gum::LazyPropagation<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNMonteCarloSampling_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNMonteCarloSampling_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gum::credal::CNMonteCarloSampling<(double,gum::LazyPropagation<(double)>)> self, CredalNet_double credalNet) -> CNMonteCarloSampling_double"""
        this = _pyAgrum.new_CNMonteCarloSampling_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNMonteCarloSampling_double
    __del__ = lambda self : None;
    def makeInference(self) -> "void" :
        """makeInference(CNMonteCarloSampling_double self)"""
        return _pyAgrum.CNMonteCarloSampling_double_makeInference(self)

    def insertEvidenceFile(self, *args) -> "void" :
        """insertEvidenceFile(CNMonteCarloSampling_double self, std::string const & path)"""
        return _pyAgrum.CNMonteCarloSampling_double_insertEvidenceFile(self, *args)

    def castAsASC(self, *args) -> "gum::IApproximationSchemeConfiguration const &" :
        """castAsASC(CNMonteCarloSampling_double self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.CNMonteCarloSampling_double_castAsASC(self, *args)

    def setVerbosity(self, *args) -> "void" :
        """setVerbosity(CNMonteCarloSampling_double self, bool v)"""
        return _pyAgrum.CNMonteCarloSampling_double_setVerbosity(self, *args)

    def setEpsilon(self, *args) -> "void" :
        """setEpsilon(CNMonteCarloSampling_double self, double eps)"""
        return _pyAgrum.CNMonteCarloSampling_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args) -> "void" :
        """setMinEpsilonRate(CNMonteCarloSampling_double self, double rate)"""
        return _pyAgrum.CNMonteCarloSampling_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args) -> "void" :
        """setMaxIter(CNMonteCarloSampling_double self, gum::Size max)"""
        return _pyAgrum.CNMonteCarloSampling_double_setMaxIter(self, *args)

    def setMaxTime(self, *args) -> "void" :
        """setMaxTime(CNMonteCarloSampling_double self, double timeout)"""
        return _pyAgrum.CNMonteCarloSampling_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args) -> "void" :
        """setPeriodSize(CNMonteCarloSampling_double self, gum::Size p)"""
        return _pyAgrum.CNMonteCarloSampling_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args) -> "void" :
        """setBurnIn(CNMonteCarloSampling_double self, gum::Size b)"""
        return _pyAgrum.CNMonteCarloSampling_double_setBurnIn(self, *args)

    def verbosity(self) -> "bool" :
        """verbosity(CNMonteCarloSampling_double self) -> bool"""
        return _pyAgrum.CNMonteCarloSampling_double_verbosity(self)

    def epsilon(self) -> "double" :
        """epsilon(CNMonteCarloSampling_double self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_epsilon(self)

    def minEpsilonRate(self) -> "double" :
        """minEpsilonRate(CNMonteCarloSampling_double self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_minEpsilonRate(self)

    def maxIter(self) -> "gum::Size" :
        """maxIter(CNMonteCarloSampling_double self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_maxIter(self)

    def maxTime(self) -> "double" :
        """maxTime(CNMonteCarloSampling_double self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_maxTime(self)

    def periodSize(self) -> "gum::Size" :
        """periodSize(CNMonteCarloSampling_double self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_periodSize(self)

    def burnIn(self) -> "gum::Size" :
        """burnIn(CNMonteCarloSampling_double self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_burnIn(self)

    def nbrIterations(self) -> "gum::Size" :
        """nbrIterations(CNMonteCarloSampling_double self) -> gum::Size"""
        return _pyAgrum.CNMonteCarloSampling_double_nbrIterations(self)

    def currentTime(self) -> "double" :
        """currentTime(CNMonteCarloSampling_double self) -> double"""
        return _pyAgrum.CNMonteCarloSampling_double_currentTime(self)

    def messageApproximationScheme(self) -> "std::string" :
        """messageApproximationScheme(CNMonteCarloSampling_double self) -> std::string"""
        return _pyAgrum.CNMonteCarloSampling_double_messageApproximationScheme(self)

    def history(self) -> "std::vector< double,std::allocator< double > > const &" :
        """history(CNMonteCarloSampling_double self) -> Vector_double"""
        return _pyAgrum.CNMonteCarloSampling_double_history(self)

    def setRepetitiveInd(self, *args) -> "void" :
        """setRepetitiveInd(CNMonteCarloSampling_double self, bool const flag)"""
        return _pyAgrum.CNMonteCarloSampling_double_setRepetitiveInd(self, *args)

    def marginalMax(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """
        marginalMax(CNMonteCarloSampling_double self, gum::NodeId const id) -> Vector_double
        marginalMax(CNMonteCarloSampling_double self, std::string const name) -> Vector_double
        """
        return _pyAgrum.CNMonteCarloSampling_double_marginalMax(self, *args)

    def marginalMin(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """
        marginalMin(CNMonteCarloSampling_double self, gum::NodeId const id) -> Vector_double
        marginalMin(CNMonteCarloSampling_double self, std::string const name) -> Vector_double
        """
        return _pyAgrum.CNMonteCarloSampling_double_marginalMin(self, *args)

    def insertModalsFile(self, *args) -> "void" :
        """insertModalsFile(CNMonteCarloSampling_double self, std::string const & path)"""
        return _pyAgrum.CNMonteCarloSampling_double_insertModalsFile(self, *args)

    def dynamicExpMax(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """dynamicExpMax(CNMonteCarloSampling_double self, std::string const & varName) -> Vector_double"""
        return _pyAgrum.CNMonteCarloSampling_double_dynamicExpMax(self, *args)

    def dynamicExpMin(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """dynamicExpMin(CNMonteCarloSampling_double self, std::string const & varName) -> Vector_double"""
        return _pyAgrum.CNMonteCarloSampling_double_dynamicExpMin(self, *args)

CNMonteCarloSampling_double_swigregister = _pyAgrum.CNMonteCarloSampling_double_swigregister
CNMonteCarloSampling_double_swigregister(CNMonteCarloSampling_double)

class CNLoopyPropagation_double(_object):
    """Proxy of C++ gum::credal::CNLoopyPropagation<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNLoopyPropagation_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNLoopyPropagation_double, name)
    __repr__ = _swig_repr
    nodeToNeighbours = _pyAgrum.CNLoopyPropagation_double_nodeToNeighbours
    ordered = _pyAgrum.CNLoopyPropagation_double_ordered
    randomOrder = _pyAgrum.CNLoopyPropagation_double_randomOrder
    def makeInference(self) -> "void" :
        """makeInference(CNLoopyPropagation_double self)"""
        return _pyAgrum.CNLoopyPropagation_double_makeInference(self)

    def inferenceType(self, *args) -> "gum::credal::CNLoopyPropagation< double >::InferenceType" :
        """
        inferenceType(CNLoopyPropagation_double self, gum::credal::CNLoopyPropagation< double >::InferenceType inft)
        inferenceType(CNLoopyPropagation_double self) -> gum::credal::CNLoopyPropagation< double >::InferenceType
        """
        return _pyAgrum.CNLoopyPropagation_double_inferenceType(self, *args)

    def eraseAllEvidence(self) -> "void" :
        """eraseAllEvidence(CNLoopyPropagation_double self)"""
        return _pyAgrum.CNLoopyPropagation_double_eraseAllEvidence(self)

    def saveInference(self, *args) -> "void" :
        """saveInference(CNLoopyPropagation_double self, std::string const & path)"""
        return _pyAgrum.CNLoopyPropagation_double_saveInference(self, *args)

    def __init__(self, *args): 
        """__init__(gum::credal::CNLoopyPropagation<(double)> self, CredalNet_double cnet) -> CNLoopyPropagation_double"""
        this = _pyAgrum.new_CNLoopyPropagation_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_CNLoopyPropagation_double
    __del__ = lambda self : None;
    def insertEvidenceFile(self, *args) -> "void" :
        """insertEvidenceFile(CNLoopyPropagation_double self, std::string const & path)"""
        return _pyAgrum.CNLoopyPropagation_double_insertEvidenceFile(self, *args)

    def castAsASC(self, *args) -> "gum::IApproximationSchemeConfiguration const &" :
        """castAsASC(CNLoopyPropagation_double self) -> IApproximationSchemeConfiguration"""
        return _pyAgrum.CNLoopyPropagation_double_castAsASC(self, *args)

    def setVerbosity(self, *args) -> "void" :
        """setVerbosity(CNLoopyPropagation_double self, bool v)"""
        return _pyAgrum.CNLoopyPropagation_double_setVerbosity(self, *args)

    def setEpsilon(self, *args) -> "void" :
        """setEpsilon(CNLoopyPropagation_double self, double eps)"""
        return _pyAgrum.CNLoopyPropagation_double_setEpsilon(self, *args)

    def setMinEpsilonRate(self, *args) -> "void" :
        """setMinEpsilonRate(CNLoopyPropagation_double self, double rate)"""
        return _pyAgrum.CNLoopyPropagation_double_setMinEpsilonRate(self, *args)

    def setMaxIter(self, *args) -> "void" :
        """setMaxIter(CNLoopyPropagation_double self, gum::Size max)"""
        return _pyAgrum.CNLoopyPropagation_double_setMaxIter(self, *args)

    def setMaxTime(self, *args) -> "void" :
        """setMaxTime(CNLoopyPropagation_double self, double timeout)"""
        return _pyAgrum.CNLoopyPropagation_double_setMaxTime(self, *args)

    def setPeriodSize(self, *args) -> "void" :
        """setPeriodSize(CNLoopyPropagation_double self, gum::Size p)"""
        return _pyAgrum.CNLoopyPropagation_double_setPeriodSize(self, *args)

    def setBurnIn(self, *args) -> "void" :
        """setBurnIn(CNLoopyPropagation_double self, gum::Size b)"""
        return _pyAgrum.CNLoopyPropagation_double_setBurnIn(self, *args)

    def verbosity(self) -> "bool" :
        """verbosity(CNLoopyPropagation_double self) -> bool"""
        return _pyAgrum.CNLoopyPropagation_double_verbosity(self)

    def epsilon(self) -> "double" :
        """epsilon(CNLoopyPropagation_double self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_epsilon(self)

    def minEpsilonRate(self) -> "double" :
        """minEpsilonRate(CNLoopyPropagation_double self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_minEpsilonRate(self)

    def maxIter(self) -> "gum::Size" :
        """maxIter(CNLoopyPropagation_double self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_maxIter(self)

    def maxTime(self) -> "double" :
        """maxTime(CNLoopyPropagation_double self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_maxTime(self)

    def periodSize(self) -> "gum::Size" :
        """periodSize(CNLoopyPropagation_double self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_periodSize(self)

    def burnIn(self) -> "gum::Size" :
        """burnIn(CNLoopyPropagation_double self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_burnIn(self)

    def nbrIterations(self) -> "gum::Size" :
        """nbrIterations(CNLoopyPropagation_double self) -> gum::Size"""
        return _pyAgrum.CNLoopyPropagation_double_nbrIterations(self)

    def currentTime(self) -> "double" :
        """currentTime(CNLoopyPropagation_double self) -> double"""
        return _pyAgrum.CNLoopyPropagation_double_currentTime(self)

    def messageApproximationScheme(self) -> "std::string" :
        """messageApproximationScheme(CNLoopyPropagation_double self) -> std::string"""
        return _pyAgrum.CNLoopyPropagation_double_messageApproximationScheme(self)

    def history(self) -> "std::vector< double,std::allocator< double > > const &" :
        """history(CNLoopyPropagation_double self) -> Vector_double"""
        return _pyAgrum.CNLoopyPropagation_double_history(self)

    def setRepetitiveInd(self, *args) -> "void" :
        """setRepetitiveInd(CNLoopyPropagation_double self, bool const flag)"""
        return _pyAgrum.CNLoopyPropagation_double_setRepetitiveInd(self, *args)

    def marginalMax(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """
        marginalMax(CNLoopyPropagation_double self, gum::NodeId const id) -> Vector_double
        marginalMax(CNLoopyPropagation_double self, std::string const name) -> Vector_double
        """
        return _pyAgrum.CNLoopyPropagation_double_marginalMax(self, *args)

    def marginalMin(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """
        marginalMin(CNLoopyPropagation_double self, gum::NodeId const id) -> Vector_double
        marginalMin(CNLoopyPropagation_double self, std::string const name) -> Vector_double
        """
        return _pyAgrum.CNLoopyPropagation_double_marginalMin(self, *args)

    def insertModalsFile(self, *args) -> "void" :
        """insertModalsFile(CNLoopyPropagation_double self, std::string const & path)"""
        return _pyAgrum.CNLoopyPropagation_double_insertModalsFile(self, *args)

    def dynamicExpMax(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """dynamicExpMax(CNLoopyPropagation_double self, std::string const & varName) -> Vector_double"""
        return _pyAgrum.CNLoopyPropagation_double_dynamicExpMax(self, *args)

    def dynamicExpMin(self, *args) -> "std::vector< double,std::allocator< double > > const &" :
        """dynamicExpMin(CNLoopyPropagation_double self, std::string const & varName) -> Vector_double"""
        return _pyAgrum.CNLoopyPropagation_double_dynamicExpMin(self, *args)

CNLoopyPropagation_double_swigregister = _pyAgrum.CNLoopyPropagation_double_swigregister
CNLoopyPropagation_double_swigregister(CNLoopyPropagation_double)

class InfluenceDiagram_double(DAGmodel):
    """Proxy of C++ gum::InfluenceDiagram<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [DAGmodel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfluenceDiagram_double, name, value)
    __swig_getmethods__ = {}
    for _s in [DAGmodel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InfluenceDiagram_double, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pyAgrum.delete_InfluenceDiagram_double
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(gum::InfluenceDiagram<(double)> self) -> InfluenceDiagram_double
        __init__(gum::InfluenceDiagram<(double)> self, InfluenceDiagram_double source) -> InfluenceDiagram_double
        """
        this = _pyAgrum.new_InfluenceDiagram_double(*args)
        try: self.this.append(this)
        except: self.this = this
    def toDot(self) -> "std::string" :
        """toDot(InfluenceDiagram_double self) -> std::string"""
        return _pyAgrum.InfluenceDiagram_double_toDot(self)

    def __str__(self) -> "std::string" :
        """__str__(InfluenceDiagram_double self) -> std::string"""
        return _pyAgrum.InfluenceDiagram_double___str__(self)

    def cpt(self, *args) -> "gum::Potential< double > const &" :
        """cpt(InfluenceDiagram_double self, gum::NodeId varId) -> Potential_double"""
        val = _pyAgrum.InfluenceDiagram_double_cpt(self, *args)
        val.__fill_distrib__()


        return val

    def utility(self, *args) -> "gum::UtilityTable< double > const &" :
        """utility(InfluenceDiagram_double self, gum::NodeId varId) -> UtilityTable_double"""
        val = _pyAgrum.InfluenceDiagram_double_utility(self, *args)
        val.__fill_distrib__()


        return val

    def isUtilityNode(self, *args) -> "bool" :
        """isUtilityNode(InfluenceDiagram_double self, gum::NodeId varId) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_isUtilityNode(self, *args)

    def isDecisionNode(self, *args) -> "bool" :
        """isDecisionNode(InfluenceDiagram_double self, gum::NodeId varId) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_isDecisionNode(self, *args)

    def isChanceNode(self, *args) -> "bool" :
        """isChanceNode(InfluenceDiagram_double self, gum::NodeId varId) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_isChanceNode(self, *args)

    def utilityNodeSize(self) -> "gum::Size" :
        """utilityNodeSize(InfluenceDiagram_double self) -> gum::Size"""
        return _pyAgrum.InfluenceDiagram_double_utilityNodeSize(self)

    def chanceNodeSize(self) -> "gum::Size" :
        """chanceNodeSize(InfluenceDiagram_double self) -> gum::Size"""
        return _pyAgrum.InfluenceDiagram_double_chanceNodeSize(self)

    def decisionNodeSize(self) -> "gum::Size" :
        """decisionNodeSize(InfluenceDiagram_double self) -> gum::Size"""
        return _pyAgrum.InfluenceDiagram_double_decisionNodeSize(self)

    def variable(self, *args) -> "gum::DiscreteVariable const &" :
        """variable(InfluenceDiagram_double self, gum::NodeId id) -> DiscreteVariable"""
        return _pyAgrum.InfluenceDiagram_double_variable(self, *args)

    def nodeId(self, *args) -> "gum::NodeId" :
        """nodeId(InfluenceDiagram_double self, DiscreteVariable var) -> gum::NodeId"""
        return _pyAgrum.InfluenceDiagram_double_nodeId(self, *args)

    def idFromName(self, *args) -> "gum::NodeId" :
        """idFromName(InfluenceDiagram_double self, std::string const & name) -> gum::NodeId"""
        return _pyAgrum.InfluenceDiagram_double_idFromName(self, *args)

    def variableFromName(self, *args) -> "gum::DiscreteVariable const &" :
        """variableFromName(InfluenceDiagram_double self, std::string const & name) -> DiscreteVariable"""
        return _pyAgrum.InfluenceDiagram_double_variableFromName(self, *args)

    def add(self, *args) -> "gum::NodeId" :
        """
        add(InfluenceDiagram_double self, DiscreteVariable variable, gum::NodeId id=0) -> gum::NodeId
        add(InfluenceDiagram_double self, DiscreteVariable variable) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_add(self, *args)

    def addDecisionNode(self, *args) -> "gum::NodeId" :
        """
        addDecisionNode(InfluenceDiagram_double self, DiscreteVariable variable, gum::NodeId id=0) -> gum::NodeId
        addDecisionNode(InfluenceDiagram_double self, DiscreteVariable variable) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_addDecisionNode(self, *args)

    def addChanceNode(self, *args) -> "gum::NodeId" :
        """
        addChanceNode(InfluenceDiagram_double self, DiscreteVariable variable, gum::NodeId id=0) -> gum::NodeId
        addChanceNode(InfluenceDiagram_double self, DiscreteVariable variable) -> gum::NodeId
        addChanceNode(InfluenceDiagram_double self, DiscreteVariable variable, gum::MultiDimImplementation< double > * aContent, gum::NodeId id=0) -> gum::NodeId
        addChanceNode(InfluenceDiagram_double self, DiscreteVariable variable, gum::MultiDimImplementation< double > * aContent) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_addChanceNode(self, *args)

    def addUtilityNode(self, *args) -> "gum::NodeId" :
        """
        addUtilityNode(InfluenceDiagram_double self, DiscreteVariable variable, gum::NodeId id=0) -> gum::NodeId
        addUtilityNode(InfluenceDiagram_double self, DiscreteVariable variable) -> gum::NodeId
        addUtilityNode(InfluenceDiagram_double self, DiscreteVariable variable, gum::MultiDimImplementation< double > * aContent, gum::NodeId id=0) -> gum::NodeId
        addUtilityNode(InfluenceDiagram_double self, DiscreteVariable variable, gum::MultiDimImplementation< double > * aContent) -> gum::NodeId
        """
        return _pyAgrum.InfluenceDiagram_double_addUtilityNode(self, *args)

    def erase(self, *args) -> "void" :
        """
        erase(InfluenceDiagram_double self, gum::NodeId id)
        erase(InfluenceDiagram_double self, DiscreteVariable var)
        """
        return _pyAgrum.InfluenceDiagram_double_erase(self, *args)

    def changeVariableName(self, *args) -> "void" :
        """changeVariableName(InfluenceDiagram_double self, gum::NodeId id, std::string const & new_name)"""
        return _pyAgrum.InfluenceDiagram_double_changeVariableName(self, *args)

    def addArc(self, *args) -> "void" :
        """addArc(InfluenceDiagram_double self, gum::NodeId tail, gum::NodeId head)"""
        return _pyAgrum.InfluenceDiagram_double_addArc(self, *args)

    def eraseArc(self, *args) -> "void" :
        """
        eraseArc(InfluenceDiagram_double self, Arc arc)
        eraseArc(InfluenceDiagram_double self, gum::NodeId tail, gum::NodeId head)
        """
        return _pyAgrum.InfluenceDiagram_double_eraseArc(self, *args)

    def decisionOrderExists(self) -> "bool" :
        """decisionOrderExists(InfluenceDiagram_double self) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_decisionOrderExists(self)

    def getDecisionGraph(self) -> "gum::DAG *" :
        """getDecisionGraph(InfluenceDiagram_double self) -> DAG"""
        return _pyAgrum.InfluenceDiagram_double_getDecisionGraph(self)

    def getDecisionOrder(self) -> "std::vector< gum::NodeId,std::allocator< gum::NodeId > > *" :
        """getDecisionOrder(InfluenceDiagram_double self) -> std::vector< gum::NodeId,std::allocator< gum::NodeId > > *"""
        return _pyAgrum.InfluenceDiagram_double_getDecisionOrder(self)

    def existsPathBetween(self, *args) -> "bool" :
        """existsPathBetween(InfluenceDiagram_double self, gum::NodeId src, gum::NodeId dest) -> bool"""
        return _pyAgrum.InfluenceDiagram_double_existsPathBetween(self, *args)

    def names(self) -> "PyObject *" :
        """names(InfluenceDiagram_double self) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_names(self)

    def ids(self) -> "PyObject *" :
        """ids(InfluenceDiagram_double self) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_ids(self)

    def arcs(self) -> "PyObject *" :
        """arcs(InfluenceDiagram_double self) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_arcs(self)

    def parents(self, *args) -> "PyObject *" :
        """parents(InfluenceDiagram_double self, gum::NodeId const id) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_parents(self, *args)

    def children(self, *args) -> "PyObject *" :
        """children(InfluenceDiagram_double self, gum::NodeId const id) -> PyObject *"""
        return _pyAgrum.InfluenceDiagram_double_children(self, *args)

    def loadBIFXML(self, *args) -> "bool" :
        """
        loadBIFXML(InfluenceDiagram_double self, std::string name, PyObject * l=(PyObject *) 0) -> bool
        loadBIFXML(InfluenceDiagram_double self, std::string name) -> bool
        """
        return _pyAgrum.InfluenceDiagram_double_loadBIFXML(self, *args)

    def saveBIFXML(self, *args) -> "void" :
        """saveBIFXML(InfluenceDiagram_double self, std::string name)"""
        return _pyAgrum.InfluenceDiagram_double_saveBIFXML(self, *args)

InfluenceDiagram_double_swigregister = _pyAgrum.InfluenceDiagram_double_swigregister
InfluenceDiagram_double_swigregister(InfluenceDiagram_double)

class InfluenceDiagramInference_double(_object):
    """Proxy of C++ gum::InfluenceDiagramInference<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InfluenceDiagramInference_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InfluenceDiagramInference_double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(gum::InfluenceDiagramInference<(double)> self, InfluenceDiagram_double infDiag) -> InfluenceDiagramInference_double"""
        this = _pyAgrum.new_InfluenceDiagramInference_double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyAgrum.delete_InfluenceDiagramInference_double
    __del__ = lambda self : None;
    def makeInference(self) -> "void" :
        """makeInference(InfluenceDiagramInference_double self)"""
        return _pyAgrum.InfluenceDiagramInference_double_makeInference(self)

    def getMEU(self) -> "double" :
        """getMEU(InfluenceDiagramInference_double self) -> double"""
        return _pyAgrum.InfluenceDiagramInference_double_getMEU(self)

    def getBestDecisionChoice(self, *args) -> "gum::Idx" :
        """getBestDecisionChoice(InfluenceDiagramInference_double self, gum::NodeId decisionId) -> gum::Idx"""
        return _pyAgrum.InfluenceDiagramInference_double_getBestDecisionChoice(self, *args)

    def displayResult(self) -> "std::string" :
        """displayResult(InfluenceDiagramInference_double self) -> std::string"""
        return _pyAgrum.InfluenceDiagramInference_double_displayResult(self)

    def insertEvidence(self, *args) -> "void" :
        """insertEvidence(InfluenceDiagramInference_double self, gum::List< gum::Potential< double > const * > const & evidenceList)"""
        return _pyAgrum.InfluenceDiagramInference_double_insertEvidence(self, *args)

    def eraseEvidence(self, *args) -> "void" :
        """eraseEvidence(InfluenceDiagramInference_double self, Potential_double evidence)"""
        return _pyAgrum.InfluenceDiagramInference_double_eraseEvidence(self, *args)

    def eraseAllEvidence(self) -> "void" :
        """eraseAllEvidence(InfluenceDiagramInference_double self)"""
        return _pyAgrum.InfluenceDiagramInference_double_eraseAllEvidence(self)

    def displayStrongJunctionTree(self, *args) -> "void" :
        """displayStrongJunctionTree(InfluenceDiagramInference_double self, std::ostream & stream=std::cout)"""
        return _pyAgrum.InfluenceDiagramInference_double_displayStrongJunctionTree(self, *args)

    def influenceDiagram(self) -> "gum::InfluenceDiagram< double > const &" :
        """influenceDiagram(InfluenceDiagramInference_double self) -> InfluenceDiagram_double"""
        return _pyAgrum.InfluenceDiagramInference_double_influenceDiagram(self)

    def setEvidence(self, evidces):
        if not isinstance(evidces, dict):
            raise TypeError("setEvidence parameter must be dict, not %s"%(type(evidces)))
        bn = self.influenceDiagram()

        # set evidences
        self.list_pot = []

        try:
          items=evidces.iteritems()
        except AttributeError:
          items=evidces.items()

        for var_name, evidce in items:
            pot = Potential_double()

            if isinstance(var_name, int):
                var = bn.variable(var_name)
            elif isinstance(var_name, str):
                var = bn.variableFromName(var_name)
            else:
                raise TypeError('values of the dict must be int or string')

            pot.add(var)
            if isinstance(evidce, (int, float, str)):
                pot[:] = 0
                # determine the var type
                try:
                    cast_var = var.toLabelizedVar()
                    if isinstance(evidce, int):
                        index = evidce
                    elif isinstance(evidce, str):
                        index = cast_var[evidce]
                    else:
                        raise TypeError('values of the dict must be int or string')
                except RuntimeError:
                    try:
                        cast_var = var.toRangeVar()
                        if isinstance(evidce, int):
                            index = cast_var[str(evidce)]
                        elif isinstance(evidce, str):
                            index = cast_var[evidce]
                        else:
                            raise TypeError('values of the dict must be int or string')
                    except RuntimeError:
                        cast_var = var.toDiscretizedVar()
                        if isinstance(evidce, float):
                            index = cast_var.index(evidce)
                        elif isinstance(evidce, str):
                            index = cast_var.index(float(evidce))
                        else:
                            raise TypeError('values of the dict must be float or string')
                pot[index] = 1
            elif isinstance(evidce, (list, tuple)):
                pot[:] = evidce
            else:
                raise TypeError('dict values must be number, string or sequence')
            self.list_pot.append(pot)

        self.eraseAllEvidence()
        self._setEvidence(self.list_pot)


    def _setEvidence(self, *args) -> "void" :
        """_setEvidence(InfluenceDiagramInference_double self, PyObject * evidences)"""
        return _pyAgrum.InfluenceDiagramInference_double__setEvidence(self, *args)

    def junctionTreeToDot(self) -> "std::string const" :
        """junctionTreeToDot(InfluenceDiagramInference_double self) -> std::string const"""
        return _pyAgrum.InfluenceDiagramInference_double_junctionTreeToDot(self)

InfluenceDiagramInference_double_swigregister = _pyAgrum.InfluenceDiagramInference_double_swigregister
InfluenceDiagramInference_double_swigregister(InfluenceDiagramInference_double)

Potential = Potential_double
UtilityTable = UtilityTable_double

randomDistribution = randomDistribution_double

SimpleBayesNet = IBayesNet_double
BayesNet = BayesNet_double
LazyPropagation = LazyPropagation_double
GibbsInference = GibbsInference_double

BruteForceKL = BruteForceKL_double
GibbsKL = GibbsKL_double

CredalNet = CredalNet_double
CNMonteCarloSampling = CNMonteCarloSampling_double
CNLoopyPropagation = CNLoopyPropagation_double

DiscretizedVariable = DiscretizedVariable_double

InfluenceDiagram = InfluenceDiagram_double
InfluenceDiagramInference = InfluenceDiagramInference_double

# This file is compatible with both classic and new-style classes.


